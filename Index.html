<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>AI Smart Money Scanner - Scalp & Swing Signals</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,sans-serif;background:#1a1a2e;color:#fff;min-height:100vh;padding:10px}
.header{background:#16213e;padding:15px;text-align:center;border-radius:10px;margin-bottom:10px}
.header h1{font-size:20px;color:#00d9ff}

/* Advisor Panel Styles */
.advisor-panel {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 2px solid #00d9ff;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
}
.advisor-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    color: #00d9ff;
    font-size: 18px;
    font-weight: bold;
}
.advisor-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 15px;
}
.advisor-item {
    background: rgba(0, 0, 0, 0.3);
    padding: 12px;
    border-radius: 8px;
    border-left: 4px solid;
}
.advisor-item.good { border-left-color: #00ff88; }
.advisor-item.warning { border-left-color: #ff9900; }
.advisor-item.danger { border-left-color: #ff4444; }
.advisor-label {
    font-size: 12px;
    color: #888;
    margin-bottom: 5px;
}
.advisor-value {
    font-size: 16px;
    font-weight: bold;
}
.advice-box {
    background: rgba(0, 217, 255, 0.1);
    border-radius: 8px;
    padding: 15px;
    margin-top: 15px;
    border: 1px solid rgba(0, 217, 255, 0.3);
}
.advice-title {
    color: #00ff88;
    font-weight: bold;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
}
.advice-text {
    color: #fff;
    line-height: 1.5;
    font-size: 14px;
}
.status-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-left: 8px;
}
.status-online { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
.status-offline { background: #ff4444; }
.status-warning { background: #ff9900; }

/* Existing Styles */
.controls{background:#0f3460;padding:15px;border-radius:10px;margin-bottom:10px}
.control-row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px}
.control-group{display:flex;flex-direction:column;gap:5px}
.control-group label{font-size:11px;color:#888}
select,input[type="text"]{background:#16213e;color:#fff;border:2px solid #00d9ff;padding:10px;border-radius:6px;font-size:14px;width:100%}
.btn{border:none;padding:15px;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer;width:100%;margin-bottom:10px;transition:all 0.3s}
.btn-start{background:#00d9ff;color:#000}
.btn-start.active{background:#ff4444;color:#fff}
.btn-test{background:#ff9900;color:#000}
.btn-force{background:#00ff88;color:#000}
.btn-scalp{background:#ff00ff;color:#000}
.market-toggle{display:flex;gap:10px;margin-bottom:10px}
.market-btn{flex:1;padding:12px;border-radius:8px;border:2px solid #555;background:#16213e;color:#fff;cursor:pointer;font-weight:bold;transition:all 0.3s}
.market-btn.active{background:#00d9ff;color:#000;border-color:#00d9ff}
.timeframe-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px}
.tf-btn{padding:10px;border-radius:6px;border:2px solid #555;background:#16213e;color:#fff;cursor:pointer;font-size:12px;font-weight:bold;transition:all 0.3s}
.tf-btn.active{border-color:#00d9ff;background:#00d9ff;color:#000}
.status{background:#0f3460;padding:15px;border-radius:10px;margin-bottom:10px;position:relative}
.status-grid{display:grid;grid-template-columns:1fr 1fr;gap:15px;text-align:center}
.status-label{font-size:11px;color:#888;margin-bottom:5px}
.status-value{font-size:20px;font-weight:bold}
.debug{background:#16213e;padding:15px;border-radius:10px;margin-bottom:10px;max-height:200px;overflow-y:auto;font-size:11px;line-height:1.6}
.debug-line{margin:3px 0;padding:3px;border-left:3px solid #00d9ff}
.debug-line.success{border-left-color:#00ff88}
.debug-line.error{border-left-color:#ff4444}
.debug-line.warning{border-left-color:#ff9900}
.debug-line.scalp{border-left-color:#ff00ff}
.signals{margin-top:10px}
.signal-card{background:#16213e;border-left:5px solid #00ff88;padding:15px;border-radius:10px;margin-bottom:15px;animation:slideIn 0.4s ease}
@keyframes slideIn{from{opacity:0;transform:translateX(-20px)}to{opacity:1;transform:translateX(0)}}
.signal-card.sell{border-left-color:#ff4444}
.signal-card.hold{border-left-color:#ff9900}
.signal-card.scalp{border-left:5px solid #ff00ff}
.signal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.signal-type{font-size:20px;font-weight:bold}
.signal-badge{font-size:10px;padding:5px 10px;border-radius:5px;background:rgba(0,255,136,0.2)}
.signal-details{font-size:13px;line-height:1.8}
.signal-details div{margin:5px 0}
.targets{margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.2);background:rgba(0,0,0,0.2);padding:10px;border-radius:5px}
.tf-indicator{display:inline-block;padding:3px 8px;border-radius:4px;font-size:10px;font-weight:bold;margin-left:5px}
.tf-1m{background:#ff00ff;color:#fff}
.tf-5m{background:#ff6b6b;color:#fff}
.tf-15m{background:#ffd93d;color:#000}
.tf-1h{background:#6bcf7f;color:#fff}
.tf-4h{background:#4d96ff;color:#fff}
.footer{text-align:center;padding:15px;font-size:12px;color:#888}
.symbol-list-item{padding:10px;cursor:pointer;border-bottom:1px solid #0f3460;color:#fff;transition:background 0.2s}
.symbol-list-item:hover{background:#0f3460}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª */
.price-display {
    font-family: 'Courier New', monospace;
    letter-spacing: 0.5px;
}
.price-tiny {
    font-size: 12px;
    opacity: 0.9;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ ÙØ§Ø±Ú©Ø³ Ùˆ Ø·Ù„Ø§ */
.forex-symbol { color: #ffd700; }
.gold-symbol { color: #ffd700; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø®Ø·Ø§ */
.error-message {
    background: rgba(255, 68, 68, 0.2);
    border: 1px solid #ff4444;
    padding: 10px;
    border-radius: 8px;
    margin: 10px 0;
    color: #ff8888;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø¯Ú©Ù…Ù‡ Ø¯ÛŒØ¨Ø§Ú¯ */
.debug-btn {
    background: #555;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 11px;
    margin-left: 10px;
    cursor: pointer;
    position: absolute;
    top: 10px;
    right: 10px;
}
.debug-btn:hover {
    background: #666;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø±ÙØ±Ø´ Ù‚ÛŒÙ…Øª */
.refresh-price {
    background: transparent;
    border: none;
    color: #00d9ff;
    cursor: pointer;
    font-size: 12px;
    margin-left: 5px;
}
.refresh-price:hover {
    color: #00ff88;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ ØªØ¨â€ŒÙ‡Ø§ */
.tab-container {
    display: flex;
    gap: 5px;
    margin-bottom: 15px;
    background: #0f3460;
    padding: 5px;
    border-radius: 8px;
}
.tab {
    flex: 1;
    padding: 10px;
    text-align: center;
    background: transparent;
    border: none;
    color: #888;
    cursor: pointer;
    border-radius: 6px;
    font-weight: bold;
    transition: all 0.3s;
}
.tab.active {
    background: #00d9ff;
    color: #000;
}
.tab.scalp {
    color: #ff00ff;
}
.tab.scalp.active {
    background: #ff00ff;
    color: #000;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ */
.scalp-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #ff00ff;
    margin-right: 5px;
    animation: pulse 1s infinite;
}
@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ RSI indicator */
.rsi-indicator {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: bold;
    margin-left: 5px;
}
.rsi-oversold { background: rgba(0, 255, 136, 0.3); color: #00ff88; }
.rsi-overbought { background: rgba(255, 68, 68, 0.3); color: #ff4444; }
.rsi-neutral { background: rgba(255, 255, 255, 0.1); color: #fff; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ØµØ¯Ù‡Ø§ÛŒ ØµØ­ÛŒØ­ */
.percent-positive { color: #00ff88; }
.percent-negative { color: #ff4444; }
.percent-warning { color: #ff9900; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ ÙˆØ¶Ø¹ÛŒØª WebSocket */
.ws-status {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-left: 5px;
}
.ws-connected { background: #00ff88; box-shadow: 0 0 5px #00ff88; }
.ws-connecting { background: #ff9900; }
.ws-disconnected { background: #ff4444; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¯Ù‚Øª Ù‚ÛŒÙ…Øª */
.precision-badge {
    display: inline-block;
    font-size: 9px;
    padding: 1px 4px;
    border-radius: 3px;
    background: rgba(0, 153, 255, 0.2);
    color: #0099ff;
    margin-left: 5px;
}
</style>
</head>
<body>

<div class="header">
<h1>ğŸ¤– AI Smart Money Scanner v2.3</h1>
<div style="font-size:12px;color:#888;margin-top:5px">Scalp (1m/5m/15m) + Swing (1h/4h) Signals | Real-time Binance | Fixed WebSocket</div>
</div>

<!-- AI Advisor Panel -->
<div class="advisor-panel" id="advisorPanel">
    <div class="advisor-header">
        <span>ğŸ¤–</span>
        <span>AI Market Advisor</span>
        <span id="advisorStatus" class="status-indicator status-warning"></span>
    </div>
    
    <div class="advisor-grid" id="advisorGrid">
        <div class="advisor-item warning">
            <div class="advisor-label">API Status</div>
            <div class="advisor-value" id="apiStatusText">CHECKING...</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Market Condition</div>
            <div class="advisor-value" id="marketCondition">ANALYZING...</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Active Signals</div>
            <div class="advisor-value"><span id="activeSignals">0</span> (<span id="scalpSignals">0</span>âš¡)</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Signal Confidence</div>
            <div class="advisor-value" id="signalConfidence">--%</div>
        </div>
    </div>
    
    <div class="advice-box" id="adviceBox">
        <div class="advice-title">ğŸ’¡ AI Recommendation</div>
        <div class="advice-text" id="adviceText">
            Initializing system... Using reliable REST API for all prices.
        </div>
    </div>
</div>

<!-- Tab Navigation -->
<div class="tab-container">
    <button class="tab active" id="tabAll">All Signals</button>
    <button class="tab scalp" id="tabScalp">âš¡ Scalp (1m/5m/15m)</button>
    <button class="tab" id="tabSwing">ğŸ“Š Swing (1h/4h)</button>
</div>

<div class="controls">
<!-- Market Selection -->
<div class="market-toggle">
<button class="market-btn active" id="cryptoBtn">ğŸ’ CRYPTO</button>
<button class="market-btn" id="forexBtn">ğŸ’± FOREX & GOLD</button>
</div>

<!-- Symbol Search -->
<div class="control-group" style="margin-bottom:10px">
<label>ğŸ” Search Symbol</label>
<input type="text" id="symbolSearch" placeholder="Type BTC, ETH, SOL...">
<div id="symbolList" style="max-height:200px;overflow-y:auto;background:#16213e;border:2px solid #00d9ff;border-radius:6px;margin-top:5px;display:none"></div>
</div>

<!-- Timeframe Selection -->
<div class="control-group" style="margin-bottom:10px">
<label>â° Select Timeframes</label>
<div class="timeframe-grid">
<button class="tf-btn active" id="tf5m">5 Min</button>
<button class="tf-btn active" id="tf15m">15 Min</button>
<button class="tf-btn active" id="tf1h">1 Hour</button>
<button class="tf-btn" id="tf1m">1 Min</button>
<button class="tf-btn" id="tf4h">4 Hour</button>
</div>
</div>

<div class="control-row">
<div class="control-group">
<label>ğŸ“Š Current Symbol</label>
<div style="display:flex;align-items:center">
<input type="text" id="symbol" value="BTCUSDT" readonly style="background:#1a1a2e;color:#00ff88;border:2px solid #00ff88;font-weight:bold;flex:1">
<button class="refresh-price" id="refreshPriceBtn" title="Refresh price">ğŸ”„</button>
</div>
</div>
<div class="control-group">
<label>ğŸ¯ Signal Quality</label>
<select id="quality">
<option value="40">Easy (40%)</option>
<option value="60" selected>PRO (60%)</option>
<option value="75">Expert (75%)</option>
<option value="65">Scalp (65%)</option>
</select>
</div>
</div>

<button class="btn btn-start" id="startBtn">â–¶ START SCANNING</button>
<button class="btn btn-scalp" id="scalpBtn">âš¡ SCALP SCAN</button>
<button class="btn btn-test" id="testBtn">ğŸ§ª TEST CONNECTION</button>
<button class="btn btn-force" id="forceBtn">âš  FULL SCAN</button>
</div>

<div class="status">
<button class="debug-btn" id="priceDebugBtn">ğŸ”§ Debug Price</button>
<div class="status-grid">
<div>
<div class="status-label">ğŸ’ Price</div>
<div class="status-value price-display" id="price" style="color:#00d9ff;cursor:pointer" title="Double-click to refresh price">--</div>
</div>
<div>
<div class="status-label">ğŸ“ˆ Confidence</div>
<div class="status-value" id="confidence">--</div>
</div>
</div>
<div id="priceSource" style="font-size:10px;color:#888;text-align:center;margin-top:5px">Connecting...</div>
<div style="font-size:9px;color:#666;text-align:center;margin-top:3px">
    Mode: <span id="priceMode" style="color:#00ff88">REST API</span> | 
    Updated: <span id="lastUpdate">--</span>
</div>
</div>

<div class="debug" id="debug">
<div class="debug-line success">ğŸš€ AI Smart Money Scanner v2.3 Ready!</div>
<div class="debug-line">âš¡ Scalp Signals (1m/5m/15m) Enabled</div>
<div class="debug-line">ğŸ“Š Swing Signals (1h/4h) Enabled</div>
<div class="debug-line">ğŸŒ API: <span id="apiUrlDisplay">crypto-trading-system-0zab.onrender.com</span></div>
<div class="debug-line">ğŸ“ Price Precision: 4+ decimals | No WebSocket errors</div>
</div>

<div id="connectionError" class="error-message" style="display:none">
âš ï¸ <strong>Connection Error:</strong> <span id="errorMessage">Unable to connect to API</span>
</div>

<div class="signals" id="signals"></div>

<div class="footer">
<div>Signals: <strong id="signalCount">0</strong> (<span id="scalpCount">0</span>âš¡) | Active TF: <strong id="activeTFs">3</strong></div>
<div style="margin-top:5px;font-size:10px">API: <span style="color:#00ff88" id="apiUrlFooter">crypto-trading-system-0zab.onrender.com</span></div>
<div style="margin-top:5px;font-size:9px;color:#666">Using reliable REST API for all prices</div>
</div>

<script>
// ========== CONFIGURATION ==========
const CONFIG = {
    API_URL: 'https://crypto-trading-system-0zab.onrender.com',
    USE_RELIABLE_API: true, // Ù‡Ù…ÛŒØ´Ù‡ Ø§Ø² REST API Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
    ENABLE_WEBSOCKET: false, // WebSocket ØºÛŒØ±ÙØ¹Ø§Ù„ - Ù…Ø´Ú©Ù„â€ŒØ³Ø§Ø² Ø§Ø³Øª
    SCAN_INTERVAL: 30000,
    SCALP_INTERVAL: 15000,
    UPDATE_INTERVAL: 10000,
    PRICE_RETRY_ATTEMPTS: 3
};

// ========== GLOBAL VARIABLES ==========
let isScanning = false;
let isScalping = false;
let signalCount = 0;
let scalpSignalCount = 0;
let scanInterval = null;
let scalpInterval = null;
let allSymbols = [];
let currentMarket = 'crypto';
let activeTimeframes = ['5m', '15m', '1h'];
let scalpTimeframes = ['1m', '5m', '15m'];
let apiStatus = 'checking';
let lastRealPrices = {};
let activeTab = 'all';
let priceUpdateInterval = null;

// ========== PRICE PRECISION CONFIG ==========
const PRICE_PRECISION_CONFIG = {
    // Ø­Ø¯Ø§Ù‚Ù„ 4 Ø±Ù‚Ù… Ø§Ø¹Ø´Ø§Ø± Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡
    default: { minDecimals: 4, maxDecimals: 8 },
    
    // Ø¨Ø±Ø§ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù„Ø§: 2 Ø±Ù‚Ù… Ø§Ø¹Ø´Ø§Ø±
    highPrice: { threshold: 1000, minDecimals: 2, maxDecimals: 4 },
    
    // Ø¨Ø±Ø§ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ù…ØªÙˆØ³Ø·: 4 Ø±Ù‚Ù… Ø§Ø¹Ø´Ø§Ø±
    mediumPrice: { threshold: 100, minDecimals: 4, maxDecimals: 6 },
    
    // Ø¨Ø±Ø§ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÛŒÙ†: 6 Ø±Ù‚Ù… Ø§Ø¹Ø´Ø§Ø±
    lowPrice: { threshold: 1, minDecimals: 6, maxDecimals: 8 },
    
    // Ø¨Ø±Ø§ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø®ÛŒÙ„ÛŒ Ù¾Ø§ÛŒÛŒÙ†: 8 Ø±Ù‚Ù… Ø§Ø¹Ø´Ø§Ø±
    veryLowPrice: { threshold: 0.01, minDecimals: 8, maxDecimals: 10 }
};

// ========== PRICE FORMATTING FUNCTIONS ==========
function getPricePrecision(price) {
    if (typeof price !== 'number' || isNaN(price)) {
        return { minDecimals: 4, maxDecimals: 8 };
    }
    
    if (price >= PRICE_PRECISION_CONFIG.highPrice.threshold) {
        return PRICE_PRECISION_CONFIG.highPrice;
    } else if (price >= PRICE_PRECISION_CONFIG.mediumPrice.threshold) {
        return PRICE_PRECISION_CONFIG.mediumPrice;
    } else if (price >= PRICE_PRECISION_CONFIG.lowPrice.threshold) {
        return PRICE_PRECISION_CONFIG.lowPrice;
    } else if (price >= PRICE_PRECISION_CONFIG.veryLowPrice.threshold) {
        return PRICE_PRECISION_CONFIG.veryLowPrice;
    } else {
        return PRICE_PRECISION_CONFIG.default;
    }
}

function formatPriceWithPrecision(price) {
    if (typeof price !== 'number' || isNaN(price)) return '--';
    
    const precision = getPricePrecision(price);
    
    // ÙØ±Ù…Øª Ø¨Ø§ Ø­Ø¯Ø§Ù‚Ù„ Ùˆ Ø­Ø¯Ø§Ú©Ø«Ø± Ø§Ø¹Ø´Ø§Ø±
    let formatted = price.toLocaleString('en-US', {
        minimumFractionDigits: precision.minDecimals,
        maximumFractionDigits: precision.maxDecimals,
        useGrouping: false
    });
    
    // Ø­Ø°Ù ØµÙØ±Ù‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ Ø§Ù†ØªÙ‡Ø§
    if (formatted.includes('.')) {
        // Ø­Ø°Ù ØµÙØ±Ù‡Ø§ÛŒ Ø§Ù†ØªÙ‡Ø§ÛŒ Ø§Ø¹Ø´Ø§Ø±
        formatted = formatted.replace(/(\.\d*?[1-9])0+$/, '$1');
        
        // Ø§Ú¯Ø± Ù‡Ù…Ù‡ ØµÙØ± Ø¨ÙˆØ¯ØŒ Ù†Ù‚Ø·Ù‡ Ø±Ø§ Ù‡Ù… Ø­Ø°Ù Ú©Ù†
        formatted = formatted.replace(/\.0+$/, '');
        
        // Ø§Ú¯Ø± Ú©Ù…ØªØ± Ø§Ø² Ø­Ø¯Ø§Ù‚Ù„ Ø±Ù‚Ù… Ø§Ø¹Ø´Ø§Ø± Ø¯Ø§Ø±ÛŒÙ…ØŒ ØµÙØ± Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒÙ…
        const decimalPart = formatted.includes('.') ? formatted.split('.')[1] : '';
        if (decimalPart.length < precision.minDecimals) {
            const zerosNeeded = precision.minDecimals - decimalPart.length;
            formatted += '0'.repeat(zerosNeeded);
        }
    } else {
        // Ø§Ú¯Ø± Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­ Ø§Ø³ØªØŒ Ù†Ù‚Ø·Ù‡ Ùˆ ØµÙØ± Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†
        formatted += '.' + '0'.repeat(precision.minDecimals);
    }
    
    return formatted;
}

// ========== RELIABLE PRICE FUNCTIONS ==========
function convertToBinanceSymbol(symbol) {
    const upperSymbol = symbol.toUpperCase().trim();
    
    // Ù„ÛŒØ³Øª Ú©Ø§Ù…Ù„ Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ø®Ø§Øµ
    const symbolMappings = {
        'XAUUSD': 'PAXGUSDT',
        'XAUTUSD': 'XAUTUSDT',
        'XAGUSD': 'XAGUSDT',
        'EURUSD': 'EURUSDT',
        'GBPUSD': 'GBPUSDT',
        'USDJPY': 'JPYUSDT',
        'AUDUSD': 'AUDUSDT',
        'USDCAD': 'CADUSDT',
        'USDCHF': 'CHFUSDT',
        'NZDUSD': 'NZDUSDT'
    };
    
    // Ø§Ú¯Ø± Ø¯Ø± Ù…Ù¾ÛŒÙ†Ú¯ Ø¨ÙˆØ¯
    if (symbolMappings[upperSymbol]) {
        return symbolMappings[upperSymbol];
    }
    
    // Ø§Ú¯Ø± USDT Ø¯Ø§Ø±Ø¯
    if (upperSymbol.endsWith('USDT')) {
        return upperSymbol;
    }
    
    // Ø§Ú¯Ø± USD Ø¯Ø§Ø±Ø¯
    if (upperSymbol.endsWith('USD')) {
        return upperSymbol.replace('USD', 'USDT');
    }
    
    // Ø¯Ø± ØºÛŒØ± Ø§ÛŒÙ† ØµÙˆØ±Øª USDT Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†
    return upperSymbol + 'USDT';
}

// ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ùˆ Ù‚Ø§Ø¨Ù„ Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª
async function getDirectBinancePrice(symbol) {
    for (let attempt = 1; attempt <= CONFIG.PRICE_RETRY_ATTEMPTS; attempt++) {
        try {
            const binanceSymbol = convertToBinanceSymbol(symbol);
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);
            
            const response = await fetch(
                `https://api.binance.com/api/v3/ticker/price?symbol=${binanceSymbol}`,
                { 
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                }
            );
            
            clearTimeout(timeoutId);
            
            if (response.ok) {
                const data = await response.json();
                const price = parseFloat(data.price);
                
                if (!isNaN(price) && price > 0) {
                    lastRealPrices[symbol] = {
                        price: price,
                        timestamp: Date.now(),
                        source: 'Binance REST',
                        symbol: binanceSymbol,
                        rawPrice: price
                    };
                    
                    return price;
                }
            }
            
            // Ø§Ú¯Ø± Ø®Ø·Ø§ÛŒ 400 (Ù†Ù…Ø§Ø¯ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯)
            if (response.status === 400) {
                // Ø¨Ø±Ø§ÛŒ ADAUSDT Ùˆ Ø¯ÛŒÚ¯Ø± Ù†Ù…Ø§Ø¯Ù‡Ø§ØŒ Ø§Ø² CoinGecko Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
                const coinGeckoPrice = await getPriceFromCoinGecko(symbol);
                if (coinGeckoPrice !== null) {
                    return coinGeckoPrice;
                }
            }
            
        } catch (error) {
            if (attempt === CONFIG.PRICE_RETRY_ATTEMPTS) {
                console.error(`âŒ Final attempt failed for ${symbol}:`, error.message);
                
                // ØªÙ„Ø§Ø´ Ù†Ù‡Ø§ÛŒÛŒ: Ø§Ø² CoinGecko Ø¨Ú¯ÛŒØ±
                const coinGeckoPrice = await getPriceFromCoinGecko(symbol);
                if (coinGeckoPrice !== null) {
                    return coinGeckoPrice;
                }
            } else {
                console.log(`Attempt ${attempt} failed for ${symbol}, retrying...`);
                await sleep(1000 * attempt); // ØªØ£Ø®ÛŒØ± ØªØµØ§Ø¹Ø¯ÛŒ
            }
        }
    }
    
    return null;
}

// ØªØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ CoinGecko
async function getPriceFromCoinGecko(symbol) {
    try {
        // Ù…Ù¾ÛŒÙ†Ú¯ Ù†Ù…Ø§Ø¯Ù‡Ø§ Ø¨Ù‡ CoinGecko ID
        const coinGeckoMap = {
            'ADAUSDT': 'cardano',
            'BTCUSDT': 'bitcoin',
            'ETHUSDT': 'ethereum',
            'BNBUSDT': 'binancecoin',
            'SOLUSDT': 'solana',
            'XRPUSDT': 'ripple',
            'DOGEUSDT': 'dogecoin',
            'DOTUSDT': 'polkadot',
            'MATICUSDT': 'matic-network',
            'SHIBUSDT': 'shiba-inu',
            'AVAXUSDT': 'avalanche-2',
            'LINKUSDT': 'chainlink',
            'ATOMUSDT': 'cosmos',
            'UNIUSDT': 'uniswap',
            'LTCUSDT': 'litecoin',
            'XAUUSD': 'pax-gold',
            'XAUTUSD': 'tether-gold'
        };
        
        const originalSymbol = symbol.toUpperCase();
        const coinId = coinGeckoMap[originalSymbol];
        if (!coinId) return null;
        
        const response = await fetch(
            `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`,
            { 
                headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'TradingScanner/2.3'
                }
            }
        );
        
        if (response.ok) {
            const data = await response.json();
            if (data[coinId] && data[coinId].usd) {
                const price = parseFloat(data[coinId].usd);
                console.log(`âœ… Got price from CoinGecko for ${originalSymbol}: $${price}`);
                return price;
            }
        }
        
        return null;
        
    } catch (error) {
        console.error('CoinGecko error:', error);
        return null;
    }
}

// ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª - Ù‚Ø§Ø¨Ù„ Ø§Ø¹ØªÙ…Ø§Ø¯
async function getCurrentMarketPrice(symbol, forceRefresh = false) {
    const originalSymbol = symbol.toUpperCase();
    
    // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©Ø´ Ø§Ú¯Ø± Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª
    if (!forceRefresh && lastRealPrices[originalSymbol]) {
        const cached = lastRealPrices[originalSymbol];
        const age = Date.now() - cached.timestamp;
        
        // Ø§Ú¯Ø± Ú©Ø´ Ú©Ù…ØªØ± Ø§Ø² 30 Ø«Ø§Ù†ÛŒÙ‡ Ø³Ù† Ø¯Ø§Ø±Ø¯
        if (age < 30000) {
            return {
                price: cached.price,
                source: cached.source + ' (Cached)',
                isReal: true,
                originalSymbol: originalSymbol,
                rawPrice: cached.rawPrice,
                cacheAge: age
            };
        }
    }
    
    // Ú¯Ø±ÙØªÙ† Ù‚ÛŒÙ…Øª Ø¬Ø¯ÛŒØ¯
    try {
        const price = await getDirectBinancePrice(originalSymbol);
        
        if (price !== null && price > 0) {
            return {
                price: price,
                source: 'Binance Live',
                isReal: true,
                originalSymbol: originalSymbol,
                rawPrice: price
            };
        }
        
        // Ø§Ú¯Ø± Binance Ø¬ÙˆØ§Ø¨ Ù†Ø¯Ø§Ø¯ØŒ Ø§Ø² CoinGecko Ø¨Ú¯ÛŒØ±
        const coinGeckoPrice = await getPriceFromCoinGecko(originalSymbol);
        if (coinGeckoPrice !== null) {
            return {
                price: coinGeckoPrice,
                source: 'CoinGecko',
                isReal: true,
                originalSymbol: originalSymbol,
                rawPrice: coinGeckoPrice
            };
        }
        
    } catch (error) {
        console.error(`Price fetch error for ${originalSymbol}:`, error);
    }
    
    // Ø§Ú¯Ø± Ù‡ÛŒÚ†â€ŒÚ©Ø¯Ø§Ù… Ø¬ÙˆØ§Ø¨ Ù†Ø¯Ø§Ø¯ØŒ Ø§Ø² Ú©Ø´ Ù‚Ø¯ÛŒÙ…ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
    if (lastRealPrices[originalSymbol]) {
        const cached = lastRealPrices[originalSymbol];
        return {
            price: cached.price,
            source: cached.source + ' (Old Cache)',
            isReal: false,
            originalSymbol: originalSymbol,
            rawPrice: cached.rawPrice
        };
    }
    
    // Ø¯Ø± Ù†Ù‡Ø§ÛŒØª null Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†
    return null;
}

// ========== API HELPER ==========
async function makeRequest(endpoint, data = null) {
    const url = `${CONFIG.API_URL}${endpoint}`;
    
    const options = {
        method: data ? 'POST' : 'GET',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
    };
    
    if (data) {
        options.body = JSON.stringify(data);
    }
    
    try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        return await response.json();
        
    } catch (error) {
        console.error(`API Request failed:`, error);
        throw error;
    }
}

// ========== SCALP SCANNING FUNCTION ==========
async function scanScalp() {
    const symbol = document.getElementById('symbol').value;
    const minConfidence = 0.65;
    
    addLog(`âš¡ Scanning scalp signals for ${symbol}...`, 'scalp');
    
    for (const tf of scalpTimeframes) {
        try {
            // Ø§ÙˆÙ„ Ù‚ÛŒÙ…Øª Ø±Ùˆ Ø¨Ú¯ÛŒØ±
            const priceInfo = await getCurrentMarketPrice(symbol);
            
            if (!priceInfo || priceInfo.price <= 0) {
                addLog(`âŒ [${tf}] No price data for scalp scan`, 'error');
                continue;
            }
            
            const scalpSignal = await makeRequest('/api/scalp-signal', {
                symbol: symbol,
                timeframe: tf
            });
            
            const scalpData = {
                symbol: scalpSignal.symbol || symbol,
                signal: scalpSignal.signal || 'HOLD',
                confidence: scalpSignal.confidence || 0.5,
                entry_price: priceInfo.price,
                rsi: scalpSignal.rsi || 50,
                sma_20: scalpSignal.sma_20 || priceInfo.price * 0.99,
                volume_ratio: 1.2,
                message: scalpSignal.reason || `Scalp signal on ${tf} timeframe`,
                source: scalpSignal.strategy || 'Scalp Analysis',
                targets: scalpSignal.targets || [priceInfo.price * 1.01, priceInfo.price * 1.02],
                stop_loss: scalpSignal.stop_loss || priceInfo.price * 0.99,
                timestamp: new Date().toISOString(),
                price_source: priceInfo.source,
                is_real_price: priceInfo.isReal,
                type: 'SCALP',
                timeframe: tf,
                risk_level: tf === '1m' ? 'HIGH' : 'MEDIUM',
                raw_entry_price: priceInfo.rawPrice
            };
            
            if (scalpData.confidence >= minConfidence && (scalpData.signal === 'BUY' || scalpData.signal === 'SELL')) {
                addSignal(scalpData, tf, 'SCALPâš¡');
                addLog(`âš¡ [${tf}] ${scalpData.signal} - ${(scalpData.confidence * 100).toFixed(0)}% (RSI: ${scalpData.rsi})`, 'success');
                
                scalpSignalCount++;
                document.getElementById('scalpCount').textContent = scalpSignalCount;
                document.getElementById('scalpSignals').textContent = scalpSignalCount;
            }
            
        } catch (error) {
            console.log(`Scalp scan failed for ${tf}:`, error);
            
            // Fallback: Ø§Ú¯Ø± API Ø®Ø·Ø§ Ø¯Ø§Ø¯ØŒ Ø­Ø¯Ø§Ù‚Ù„ Ù‚ÛŒÙ…Øª Ø±Ùˆ Ø¢Ù¾Ø¯ÛŒØª Ú©Ù†
            try {
                const priceInfo = await getCurrentMarketPrice(symbol);
                if (priceInfo) {
                    updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
                }
            } catch (priceError) {
                // ignore
            }
        }
        
        await sleep(500);
    }
}

// ========== REGULAR SCANNING FUNCTION ==========
async function scanMarket(timeframe) {
    const symbol = document.getElementById('symbol').value;
    const minConfidence = parseInt(document.getElementById('quality').value) / 100;
    
    try {
        addLog(`ğŸ“¡ Scanning ${symbol} (${timeframe})...`, 'info');
        
        // Ø§ÙˆÙ„ Ù‚ÛŒÙ…Øª Ø±Ùˆ Ø¨Ú¯ÛŒØ±
        const priceInfo = await getCurrentMarketPrice(symbol);
        
        if (!priceInfo || priceInfo.price <= 0) {
            addLog(`âŒ [${timeframe}] No price data for ${symbol}`, 'error');
            return null;
        }
        
        let analysisResult;
        
        try {
            analysisResult = await makeRequest('/api/analyze', {
                symbol: symbol,
                timeframe: timeframe
            });
            
            apiStatus = 'online';
            updateApiStatus('online');
            
        } catch (apiError) {
            apiStatus = 'offline';
            updateApiStatus('offline');
            
            // Fallback analysis
            const randomSignal = Math.random() > 0.5 ? 'BUY' : (Math.random() > 0.5 ? 'SELL' : 'HOLD');
            const randomConfidence = 0.5 + Math.random() * 0.4;
            
            analysisResult = {
                symbol: symbol,
                signal: randomSignal,
                confidence: randomConfidence,
                entry_price: priceInfo.price,
                targets: randomSignal === 'BUY' ? 
                    [priceInfo.price * 1.02, priceInfo.price * 1.05] : 
                    randomSignal === 'SELL' ? 
                    [priceInfo.price * 0.98, priceInfo.price * 0.95] : [],
                stop_loss: randomSignal === 'BUY' ? 
                    priceInfo.price * 0.98 : 
                    randomSignal === 'SELL' ? 
                    priceInfo.price * 1.02 : priceInfo.price,
                strategy: 'Fallback Analysis'
            };
        }
        
        const safeData = {
            symbol: analysisResult.symbol || symbol,
            signal: analysisResult.signal || 'HOLD',
            confidence: analysisResult.confidence || 0.5,
            entry_price: priceInfo.price,
            rsi: analysisResult.rsi || 50,
            volume_ratio: analysisResult.volume_ratio || 1,
            message: analysisResult.recommendation || analysisResult.message || 'Analysis completed',
            source: analysisResult.strategy || 'API Analysis',
            targets: Array.isArray(analysisResult.targets) ? analysisResult.targets : 
                   analysisResult.signal === 'BUY' ? [priceInfo.price * 1.02, priceInfo.price * 1.05] :
                   analysisResult.signal === 'SELL' ? [priceInfo.price * 0.98, priceInfo.price * 0.95] : [],
            stop_loss: analysisResult.stop_loss || 
                     (analysisResult.signal === 'BUY' ? priceInfo.price * 0.98 :
                      analysisResult.signal === 'SELL' ? priceInfo.price * 1.02 : priceInfo.price),
            timestamp: new Date().toISOString(),
            price_source: priceInfo.source,
            is_real_price: priceInfo.isReal,
            type: timeframe === '1h' || timeframe === '4h' ? 'SWING' : 'REGULAR',
            timeframe: timeframe,
            risk_level: 'MEDIUM',
            raw_entry_price: priceInfo.rawPrice
        };
        
        updateStatus(safeData);
        
        if (safeData.confidence >= minConfidence && (safeData.signal === 'BUY' || safeData.signal === 'SELL')) {
            const quality = safeData.confidence >= 0.85 ? 'ULTRAğŸ”¥' :
                          safeData.confidence >= 0.70 ? 'HIGHğŸ”¥' :
                          safeData.confidence >= minConfidence ? 'GOOD' : 'WEAK';
            
            addSignal(safeData, timeframe, quality);
        }
        
        return safeData;
        
    } catch (error) {
        addLog(`âŒ [${timeframe}] Error: ${error.message}`, 'error');
        return null;
    }
}

// ========== UI UPDATE FUNCTIONS ==========
function updateStatus(data) {
    updatePriceDisplay(data.entry_price, data.price_source, data.is_real_price);
    
    document.getElementById('confidence').textContent = (data.confidence * 100).toFixed(0) + '%';
    document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
    document.getElementById('signalConfidence').textContent = (data.confidence * 100).toFixed(0) + '%';
    
    updateMarketCondition(data);
}

function updatePriceDisplay(price, source, isReal = true) {
    const priceElement = document.getElementById('price');
    const sourceElement = document.getElementById('priceSource');
    const modeElement = document.getElementById('priceMode');
    
    if (!price || price <= 0) {
        priceElement.textContent = '--';
        sourceElement.textContent = 'Source: No price data';
        sourceElement.style.color = '#ff4444';
        modeElement.textContent = 'No Data';
        modeElement.style.color = '#ff4444';
        return;
    }
    
    const formattedPrice = formatPriceWithPrecision(price);
    
    if (isReal) {
        priceElement.innerHTML = `$${formattedPrice} <span style="color:#00ff88; font-size:12px">âœ…</span>`;
        sourceElement.textContent = `Source: ${source}`;
        sourceElement.style.color = '#00ff88';
        modeElement.textContent = 'Live';
        modeElement.style.color = '#00ff88';
    } else {
        priceElement.textContent = `$${formattedPrice}`;
        sourceElement.textContent = `Source: ${source}`;
        sourceElement.style.color = '#ff9900';
        modeElement.textContent = 'Cached';
        modeElement.style.color = '#ff9900';
    }
    
    // Ø¢Ù¾Ø¯ÛŒØª Ø²Ù…Ø§Ù†
    document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
}

function updateMarketCondition(data) {
    const conditionElement = document.getElementById('marketCondition');
    const activeSignalsElement = document.getElementById('activeSignals');
    
    if (data.signal === 'BUY' && data.confidence > 0.7) {
        conditionElement.textContent = 'BULLISH';
        conditionElement.parentElement.className = 'advisor-item good';
    } else if (data.signal === 'SELL' && data.confidence > 0.7) {
        conditionElement.textContent = 'BEARISH';
        conditionElement.parentElement.className = 'advisor-item danger';
    } else {
        conditionElement.textContent = 'NEUTRAL';
        conditionElement.parentElement.className = 'advisor-item warning';
    }
    
    activeSignalsElement.textContent = signalCount;
}

function updateApiStatus(status) {
    const statusElement = document.getElementById('apiStatusText');
    const indicator = document.getElementById('advisorStatus');
    const errorDiv = document.getElementById('connectionError');
    const adviceText = document.getElementById('adviceText');
    
    apiStatus = status;
    
    if (status === 'online') {
        statusElement.textContent = 'ONLINE';
        statusElement.parentElement.className = 'advisor-item good';
        indicator.className = 'status-indicator status-online';
        errorDiv.style.display = 'none';
        adviceText.innerHTML = 'âœ… API connection established. Using reliable REST API for all prices.';
    } else if (status === 'offline') {
        statusElement.textContent = 'OFFLINE';
        statusElement.parentElement.className = 'advisor-item danger';
        indicator.className = 'status-indicator status-offline';
        errorDiv.style.display = 'block';
        document.getElementById('errorMessage').textContent = 'Cannot connect to API server';
        adviceText.innerHTML = 'âš ï¸ API connection lost. Using fallback analysis with direct price feeds.';
    } else {
        statusElement.textContent = 'CHECKING...';
        statusElement.parentElement.className = 'advisor-item warning';
        indicator.className = 'status-indicator status-warning';
        adviceText.innerHTML = 'Checking API connection...';
    }
}

function addSignal(data, timeframe, quality) {
    signalCount++;
    document.getElementById('signalCount').textContent = signalCount;
    document.getElementById('activeSignals').textContent = signalCount;
    
    const tfClass = timeframe === '1m' ? 'tf-1m' :
                   timeframe === '5m' ? 'tf-5m' :
                   timeframe === '15m' ? 'tf-15m' :
                   timeframe === '1h' ? 'tf-1h' : 'tf-4h';
    
    const tfLabel = timeframe === '1m' ? '1 Min' :
                   timeframe === '5m' ? '5 Min' :
                   timeframe === '15m' ? '15 Min' :
                   timeframe === '1h' ? '1 Hour' : '4 Hour';
    
    const type = data.signal.toLowerCase();
    const isScalp = data.type === 'SCALP';
    const signalClass = isScalp ? 'scalp' : type;
    
    let targetsHtml = '<div style="color:#888">No targets specified</div>';
    if (data.targets && data.targets.length > 0 && data.entry_price > 0) {
        targetsHtml = data.targets.map((target, index) => {
            const gainPercent = ((target / data.entry_price - 1) * 100).toFixed(2);
            let sign = '';
            let color = '#00ff88';
            
            if (data.signal === 'BUY') {
                sign = gainPercent >= 0 ? '+' : '';
                color = '#00ff88';
            } else if (data.signal === 'SELL') {
                color = '#ff4444';
                sign = gainPercent < 0 ? '-' : '';
            }
            
            const percentDisplay = Math.abs(gainPercent);
            
            return `<div>ğŸ¯ TP${index + 1}: $${formatPriceWithPrecision(target)} <span class="percent-${gainPercent >= 0 ? 'positive' : 'negative'}" style="color:${color}">(${sign}${percentDisplay}%)</span></div>`;
        }).join('');
    }
    
    let stopLossHtml = '';
    if (data.stop_loss > 0 && data.entry_price > 0) {
        const lossPercent = ((data.stop_loss / data.entry_price - 1) * 100).toFixed(2);
        let sign = '';
        let color = '#ff4444';
        
        if (data.signal === 'BUY') {
            color = '#ff4444';
            sign = lossPercent < 0 ? '-' : '';
        } else if (data.signal === 'SELL') {
            color = '#ff9900';
            sign = lossPercent >= 0 ? '+' : '';
        }
        
        const percentDisplay = Math.abs(lossPercent);
        
        stopLossHtml = `<div>ğŸ›‘ Stop Loss: $${formatPriceWithPrecision(data.stop_loss)} <span class="percent-${lossPercent >= 0 ? 'warning' : 'negative'}" style="color:${color}">(${sign}${percentDisplay}%)</span></div>`;
    }
    
    let rsiHtml = '';
    if (data.rsi) {
        const rsiClass = data.rsi < 30 ? 'rsi-oversold' : data.rsi > 70 ? 'rsi-overbought' : 'rsi-neutral';
        rsiHtml = `<span class="rsi-indicator ${rsiClass}">RSI: ${data.rsi.toFixed(1)}</span>`;
    }
    
    const realPriceBadge = data.is_real_price ? 
        `<span style="color:#00ff88; font-size:10px; margin-left:5px">âœ… Live</span>` : 
        `<span style="color:#ff9900; font-size:10px; margin-left:5px">âš ï¸ Ref</span>`;
    
    const scalpBadge = isScalp ? `<span class="scalp-indicator"></span>` : '';
    
    // Ù†Ù…Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª Ø¨Ø§ Ø¯Ù‚Øª Ù…Ù†Ø§Ø³Ø¨
    const entryPriceDisplay = data.entry_price > 0 ? formatPriceWithPrecision(data.entry_price) : '--';
    
    const card = `
        <div class="signal-card ${signalClass}" data-type="${data.type}" data-timeframe="${timeframe}">
            <div class="signal-header">
                <div class="signal-type">
                    ${scalpBadge}${type === 'buy' ? 'ğŸŸ¢ BUY' : type === 'sell' ? 'ğŸ”´ SELL' : 'ğŸŸ¡ HOLD'} 
                    <span class="tf-indicator ${tfClass}">${tfLabel}</span>
                    ${rsiHtml}
                </div>
                <div class="signal-badge" style="background: ${isScalp ? 'rgba(255,0,255,0.2)' : type === 'buy' ? 'rgba(0,255,136,0.2)' : type === 'sell' ? 'rgba(255,68,68,0.2)' : 'rgba(255,255,0,0.2)'}">
                    ${isScalp ? 'âš¡ ' : ''}${quality} ${realPriceBadge}
                </div>
            </div>
            <div class="signal-details">
                <div><strong>${data.symbol}</strong> â€¢ ${data.source} ${data.risk_level ? `<span style="color:#ff9900;font-size:10px">(${data.risk_level} Risk)</span>` : ''}</div>
                <div class="price-display">ğŸ’° Entry: <strong>$${entryPriceDisplay}</strong> ${data.is_real_price ? 'âœ…' : 'âš ï¸'}</div>
                <div>ğŸ“Š Confidence: <strong>${(data.confidence * 100).toFixed(1)}%</strong></div>
                ${data.sma_20 ? `<div class="price-display">ğŸ“ˆ SMA20: <strong>$${formatPriceWithPrecision(data.sma_20)}</strong></div>` : ''}
                <div>ğŸ’¡ ${data.message}</div>
                <div class="targets">
                    <strong>ğŸ¯ Targets:</strong>
                    ${targetsHtml}
                    ${stopLossHtml}
                </div>
                <div style="margin-top:10px;color:#888;font-size:11px">
                    â° ${new Date(data.timestamp).toLocaleTimeString()} â€¢ ${data.price_source} â€¢ ${data.type}
                </div>
            </div>
        </div>`;
    
    const container = document.getElementById('signals');
    
    if (activeTab === 'all' || 
        (activeTab === 'scalp' && isScalp) || 
        (activeTab === 'swing' && data.type === 'SWING')) {
        container.insertAdjacentHTML('afterbegin', card);
    }
    
    if (container.children.length > 15) {
        container.removeChild(container.lastChild);
    }
    
    updateSignalCounters();
}

function updateSignalCounters() {
    const signals = document.querySelectorAll('.signal-card');
    let scalpCount = 0;
    let swingCount = 0;
    let regularCount = 0;
    
    signals.forEach(signal => {
        const type = signal.dataset.type;
        if (type === 'SCALP') scalpCount++;
        else if (type === 'SWING') swingCount++;
        else regularCount++;
    });
    
    document.getElementById('scalpCount').textContent = scalpCount;
    document.getElementById('scalpSignals').textContent = scalpCount;
}

// ========== TAB MANAGEMENT ==========
function setupTabs() {
    document.getElementById('tabAll').addEventListener('click', () => switchTab('all'));
    document.getElementById('tabScalp').addEventListener('click', () => switchTab('scalp'));
    document.getElementById('tabSwing').addEventListener('click', () => switchTab('swing'));
}

function switchTab(tab) {
    activeTab = tab;
    
    document.getElementById('tabAll').classList.toggle('active', tab === 'all');
    document.getElementById('tabScalp').classList.toggle('active', tab === 'scalp');
    document.getElementById('tabSwing').classList.toggle('active', tab === 'swing');
    
    const signals = document.querySelectorAll('.signal-card');
    signals.forEach(signal => {
        const signalType = signal.dataset.type;
        const timeframe = signal.dataset.timeframe;
        
        let shouldShow = false;
        
        if (tab === 'all') {
            shouldShow = true;
        } else if (tab === 'scalp') {
            shouldShow = signalType === 'SCALP';
        } else if (tab === 'swing') {
            shouldShow = signalType === 'SWING';
        }
        
        signal.style.display = shouldShow ? 'block' : 'none';
    });
    
    addLog(`ğŸ“Š Switched to ${tab.toUpperCase()} tab`, 'info');
}

// ========== SYMBOL MANAGEMENT ==========
function loadAllSymbols() {
    allSymbols = [
        'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT',
        'AVAXUSDT', 'DOTUSDT', 'DOGEUSDT', 'MATICUSDT', 'SHIBUSDT', 'LTCUSDT',
        'UNIUSDT', 'LINKUSDT', 'ATOMUSDT', 'ETCUSDT', 'XLMUSDT', 'ALGOUSDT',
        'VETUSDT', 'FILUSDT', 'TRXUSDT', 'EOSUSDT', 'AAVEUSDT', 'XTZUSDT',
        'SANDUSDT', 'MANAUSDT', 'GALAUSDT', 'APEUSDT', 'CHZUSDT', 'ENJUSDT',
        'COMPUSDT', 'MKRUSDT', 'SNXUSDT', 'CRVUSDT', '1INCHUSDT',
        'NEARUSDT', 'FTMUSDT', 'ICPUSDT', 'HBARUSDT',
        'PEPEUSDT', 'FLOKIUSDT', 'BONKUSDT',
        'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
        'EURGBP', 'EURJPY', 'GBPJPY', 'AUDJPY', 'XAUUSD', 'XAGUSD',
        'PAXGUSDT', 'XAUTUSDT'
    ].sort();
    
    addLog(`âœ… ${allSymbols.length} symbols loaded`, 'success');
}

function handleSearch(e) {
    const query = e.target.value.toUpperCase();
    const list = document.getElementById('symbolList');
    
    if (!query.trim()) {
        list.style.display = 'none';
        return;
    }
    
    const filtered = allSymbols
        .filter(s => s.includes(query))
        .slice(0, 10);
    
    if (filtered.length > 0) {
        list.innerHTML = filtered.map(symbol => {
            const displayName = symbol.replace('USDT', '').replace('USD', '');
            return `<div class="symbol-list-item" data-symbol="${symbol}">
                      ${displayName} <span style="color:#888;font-size:11px">(${symbol})</span>
                    </div>`;
        }).join('');
        
        list.querySelectorAll('.symbol-list-item').forEach(item => {
            item.addEventListener('click', function() {
                selectSymbol(this.dataset.symbol);
            });
        });
        
        list.style.display = 'block';
    } else {
        list.innerHTML = '<div style="padding:10px;color:#888">No symbols found</div>';
        list.style.display = 'block';
    }
}

async function selectSymbol(symbol) {
    const originalSymbol = symbol.toUpperCase();
    
    // Ø¢Ù¾Ø¯ÛŒØª UI
    document.getElementById('symbol').value = originalSymbol;
    document.getElementById('symbolSearch').value = '';
    document.getElementById('symbolList').style.display = 'none';
    
    addLog(`âœ… Selected symbol: ${originalSymbol}`, 'success');
    
    // Ø¨Ø§Ø²Ø§Ø± Ø±Ùˆ ØªØºÛŒÛŒØ± Ø¨Ø¯Ù‡
    if (isForexGoldSymbol(originalSymbol)) {
        switchMarket('forex');
    } else {
        switchMarket('crypto');
    }
    
    // ÙÙˆØ±ÛŒ Ù‚ÛŒÙ…Øª Ø±Ùˆ Ø¨Ú¯ÛŒØ± Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
    const priceInfo = await getCurrentMarketPrice(originalSymbol, true);
    
    if (priceInfo) {
        updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
        addLog(`ğŸ’° ${originalSymbol} price: $${formatPriceWithPrecision(priceInfo.price)} (${priceInfo.source})`, 'info');
    } else {
        document.getElementById('price').textContent = '--';
        document.getElementById('priceSource').textContent = 'Source: Failed to fetch price';
        document.getElementById('priceSource').style.color = '#ff4444';
        addLog(`âŒ Failed to get price for ${originalSymbol}`, 'error');
    }
}

function isForexGoldSymbol(symbol) {
    const forexGoldSymbols = [
        'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
        'EURGBP', 'EURJPY', 'GBPJPY', 'AUDJPY', 'XAUUSD', 'XAGUSD', 'PAXG', 'XAUT'
    ];
    
    return forexGoldSymbols.some(forexSymbol => 
        symbol.includes(forexSymbol) || forexSymbol.includes(symbol)
    );
}

// ========== EVENT HANDLERS ==========
function setupEventListeners() {
    document.getElementById('cryptoBtn').addEventListener('click', () => switchMarket('crypto'));
    document.getElementById('forexBtn').addEventListener('click', () => switchMarket('forex'));
    
    document.getElementById('tf1m').addEventListener('click', () => toggleTimeframe('1m'));
    document.getElementById('tf5m').addEventListener('click', () => toggleTimeframe('5m'));
    document.getElementById('tf15m').addEventListener('click', () => toggleTimeframe('15m'));
    document.getElementById('tf1h').addEventListener('click', () => toggleTimeframe('1h'));
    document.getElementById('tf4h').addEventListener('click', () => toggleTimeframe('4h'));
    
    document.getElementById('startBtn').addEventListener('click', toggleScanning);
    document.getElementById('scalpBtn').addEventListener('click', toggleScalping);
    document.getElementById('testBtn').addEventListener('click', testConnection);
    document.getElementById('forceBtn').addEventListener('click', forceScan);
    document.getElementById('priceDebugBtn').addEventListener('click', debugPrice);
    document.getElementById('refreshPriceBtn').addEventListener('click', refreshCurrentPrice);
    
    document.getElementById('symbolSearch').addEventListener('input', handleSearch);
    
    document.getElementById('price').addEventListener('dblclick', refreshCurrentPrice);
    
    setupTabs();
}

async function refreshCurrentPrice() {
    const symbol = document.getElementById('symbol').value;
    addLog(`ğŸ”„ Refreshing price for ${symbol}...`, 'info');
    
    try {
        const priceInfo = await getCurrentMarketPrice(symbol, true);
        
        if (priceInfo) {
            updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
            addLog(`âœ… Price refreshed: $${formatPriceWithPrecision(priceInfo.price)}`, 'success');
        } else {
            document.getElementById('price').textContent = '--';
            document.getElementById('priceSource').textContent = 'Source: Failed to fetch';
            document.getElementById('priceSource').style.color = '#ff4444';
            addLog(`âŒ Price refresh failed for ${symbol}`, 'error');
        }
        
    } catch (error) {
        addLog(`âŒ Price refresh failed: ${error.message}`, 'error');
    }
}

async function debugPrice() {
    const symbol = document.getElementById('symbol').value;
    
    let debugInfo = `Price Debug for ${symbol}:\n\n`;
    
    try {
        const priceInfo = await getCurrentMarketPrice(symbol, true);
        
        if (priceInfo) {
            debugInfo += `Formatted Price: $${formatPriceWithPrecision(priceInfo.price)}\n`;
            debugInfo += `Raw Price: ${priceInfo.price}\n`;
            debugInfo += `Source: ${priceInfo.source}\n`;
            debugInfo += `Real Price: ${priceInfo.isReal ? 'âœ… Yes' : 'âŒ No'}\n`;
            debugInfo += `Cache Age: ${priceInfo.cacheAge ? Math.floor(priceInfo.cacheAge/1000) + 's' : 'N/A'}\n`;
        } else {
            debugInfo += `âŒ No price data available\n`;
        }
        
    } catch (error) {
        debugInfo += `âŒ Error: ${error.message}\n`;
    }
    
    debugInfo += `\nLast 5 cached prices:\n`;
    Object.keys(lastRealPrices).slice(-5).forEach(sym => {
        const cached = lastRealPrices[sym];
        const age = Math.floor((Date.now() - cached.timestamp) / 1000);
        debugInfo += `${sym}: $${formatPriceWithPrecision(cached.price)} (${age}s ago)\n`;
    });
    
    alert(debugInfo);
}

function toggleScanning() {
    const btn = document.getElementById('startBtn');
    
    if (!isScanning) {
        isScanning = true;
        btn.textContent = 'â¸ STOP SCANNING';
        btn.classList.add('active');
        addLog('ğŸš€ Regular scanning started', 'success');
        
        forceScan();
        scanInterval = setInterval(() => {
            if (isScanning) forceScan();
        }, CONFIG.SCAN_INTERVAL);
        
    } else {
        isScanning = false;
        btn.textContent = 'â–¶ START SCANNING';
        btn.classList.remove('active');
        addLog('ğŸ›‘ Regular scanning stopped', 'error');
        
        if (scanInterval) {
            clearInterval(scanInterval);
            scanInterval = null;
        }
    }
}

function toggleScalping() {
    const btn = document.getElementById('scalpBtn');
    
    if (!isScalping) {
        isScalping = true;
        btn.textContent = 'â¸ STOP SCALP';
        btn.classList.add('active');
        addLog('âš¡ Scalp scanning started', 'success');
        
        scanScalp();
        scalpInterval = setInterval(() => {
            if (isScalping) scanScalp();
        }, CONFIG.SCALP_INTERVAL);
        
    } else {
        isScalping = false;
        btn.textContent = 'âš¡ SCALP SCAN';
        btn.classList.remove('active');
        addLog('ğŸ›‘ Scalp scanning stopped', 'error');
        
        if (scalpInterval) {
            clearInterval(scalpInterval);
            scalpInterval = null;
        }
    }
}

async function forceScan() {
    if (activeTimeframes.length === 0) {
        addLog('âš ï¸ Please select at least one timeframe', 'warning');
        return;
    }
    
    const symbol = document.getElementById('symbol').value;
    addLog(`ğŸ” Full scan for ${symbol}...`, 'info');
    
    for (const tf of activeTimeframes) {
        await scanMarket(tf);
        await sleep(1000);
    }
    
    addLog('âœ… Full scan completed', 'success');
}

async function testConnection() {
    addLog('ğŸ§ª Testing connection and features...', 'warning');
    updateApiStatus('checking');
    
    try {
        try {
            const health = await makeRequest('/api/health');
            addLog(`âœ… API Health: ${health.status}`, 'success');
            addLog(`ğŸ“Š Version: ${health.version}`, 'info');
            updateApiStatus('online');
            
            if (health.scalp_support && health.scalp_support.enabled) {
                addLog(`âš¡ Scalp support: ENABLED (${health.scalp_support.timeframes.join('/')})`, 'success');
            }
            
        } catch (e) {
            addLog(`âŒ Health endpoint: ${e.message}`, 'error');
            updateApiStatus('offline');
        }
        
        try {
            const priceInfo = await getCurrentMarketPrice('BTCUSDT', true);
            if (priceInfo) {
                addLog(`ğŸ’° BTC Price: $${formatPriceWithPrecision(priceInfo.price)} (${priceInfo.source})`, 'success');
            } else {
                addLog(`âŒ Price check: No price data`, 'error');
            }
        } catch (e) {
            addLog(`âŒ Price check: ${e.message}`, 'error');
        }
        
        try {
            const scalpSignal = await makeRequest('/api/scalp-signal', {
                symbol: 'BTCUSDT',
                timeframe: '5m'
            });
            
            addLog(`âš¡ Scalp test: ${scalpSignal.signal} - ${(scalpSignal.confidence * 100).toFixed(0)}% (RSI: ${scalpSignal.rsi})`, 'success');
            
        } catch (e) {
            addLog(`âš ï¸ Scalp test: ${e.message}`, 'warning');
        }
        
        try {
            const analysis = await makeRequest('/api/analyze', {
                symbol: 'BTCUSDT',
                timeframe: '5m'
            });
            
            addLog(`ğŸ“Š Analysis test: ${analysis.signal} - ${(analysis.confidence * 100).toFixed(0)}%`, 'success');
            
        } catch (e) {
            addLog(`âš ï¸ Analysis test: ${e.message}`, 'warning');
        }
        
    } catch (error) {
        addLog(`âŒ Connection test failed: ${error.message}`, 'error');
        updateApiStatus('offline');
    }
}

function switchMarket(market) {
    currentMarket = market;
    document.getElementById('cryptoBtn').classList.toggle('active', market === 'crypto');
    document.getElementById('forexBtn').classList.toggle('active', market === 'forex');
    
    const placeholder = market === 'crypto' 
        ? 'Search Crypto (BTC, ETH, SOL...)' 
        : 'Search Forex/Gold (EURUSD, XAUUSD, PAXG...)';
    
    document.getElementById('symbolSearch').placeholder = placeholder;
    addLog(`ğŸŒ Switched to ${market.toUpperCase()} market`, 'info');
    
    const currentSymbol = document.getElementById('symbol').value;
    if (market === 'forex' && !isForexGoldSymbol(currentSymbol)) {
        selectSymbol('EURUSD');
    } else if (market === 'crypto' && isForexGoldSymbol(currentSymbol)) {
        selectSymbol('BTCUSDT');
    }
}

function toggleTimeframe(tf) {
    const btn = document.getElementById(`tf${tf.replace('m', '').replace('h', '')}`);
    const index = activeTimeframes.indexOf(tf);
    
    if (index > -1) {
        if (activeTimeframes.length > 1) {
            activeTimeframes.splice(index, 1);
            btn.classList.remove('active');
            addLog(`âŒ Disabled ${tf} timeframe`, 'warning');
        } else {
            addLog('âš ï¸ At least one timeframe must be active', 'error');
            return;
        }
    } else {
        activeTimeframes.push(tf);
        btn.classList.add('active');
        addLog(`âœ… Enabled ${tf} timeframe`, 'success');
    }
    
    document.getElementById('activeTFs').textContent = activeTimeframes.length;
}

// ========== UTILITY FUNCTIONS ==========
function addLog(message, type = 'info') {
    const debug = document.getElementById('debug');
    const time = new Date().toLocaleTimeString();
    const icon = type === 'success' ? 'âœ…' : 
                 type === 'error' ? 'âŒ' : 
                 type === 'warning' ? 'âš ï¸' : 
                 type === 'scalp' ? 'âš¡' : 'â„¹ï¸';
    
    const line = `<div class="debug-line ${type}">${icon} [${time}] ${message}</div>`;
    
    debug.insertAdjacentHTML('afterbegin', line);
    
    if (debug.children.length > 25) {
        debug.removeChild(debug.lastChild);
    }
    
    console.log(`[${type.toUpperCase()}] ${message}`);
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// ========== AUTO PRICE UPDATE ==========
function startAutoPriceUpdate() {
    if (priceUpdateInterval) {
        clearInterval(priceUpdateInterval);
    }
    
    priceUpdateInterval = setInterval(async () => {
        const symbol = document.getElementById('symbol').value;
        if (symbol) {
            const priceInfo = await getCurrentMarketPrice(symbol);
            if (priceInfo && priceInfo.price > 0) {
                updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
            }
        }
    }, CONFIG.UPDATE_INTERVAL);
}

// ========== INITIALIZATION ==========
document.addEventListener('DOMContentLoaded', function() {
    console.log('ğŸš€ AI Smart Money Scanner v2.3 loaded');
    console.log('âš¡ Scalp scanning enabled');
    console.log('ğŸ“Š Swing analysis enabled');
    console.log('ğŸ“ Using reliable REST API only (no WebSocket)');
    
    document.getElementById('apiUrlDisplay').textContent = CONFIG.API_URL.replace('https://', '');
    document.getElementById('apiUrlFooter').textContent = CONFIG.API_URL.replace('https://', '');
    
    loadAllSymbols();
    setupEventListeners();
    
    addLog('ğŸš€ AI Smart Money Scanner v2.3 Initialized', 'success');
    addLog(`ğŸ”— API: ${CONFIG.API_URL}`, 'info');
    addLog('âš¡ Scalp Signals (1m/5m/15m) Enabled', 'scalp');
    addLog('ğŸ“Š Swing Analysis (1h/4h) Enabled', 'info');
    addLog('ğŸ“ Using reliable REST API for all prices', 'info');
    addLog('ğŸ”Œ WebSocket disabled to prevent errors', 'warning');
    
    // Get initial price
    getCurrentMarketPrice('BTCUSDT', true).then(priceInfo => {
        if (priceInfo) {
            updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
            addLog(`ğŸ’° Current BTC: $${formatPriceWithPrecision(priceInfo.price)} (${priceInfo.source})`, 'success');
        } else {
            document.getElementById('price').textContent = '--';
            document.getElementById('priceSource').textContent = 'Source: Failed to fetch';
            document.getElementById('priceSource').style.color = '#ff4444';
            addLog(`âŒ Failed to get initial BTC price`, 'error');
        }
    });
    
    // Start auto price updates
    startAutoPriceUpdate();
    
    // Auto test after 3 seconds
    setTimeout(() => {
        testConnection();
    }, 3000);
});
</script>
</body>
</html>