<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>AI Smart Money Scanner - Scalp & Swing Signals</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,sans-serif;background:#1a1a2e;color:#fff;min-height:100vh;padding:10px}
.header{background:#16213e;padding:15px;text-align:center;border-radius:10px;margin-bottom:10px}
.header h1{font-size:20px;color:#00d9ff}

/* Advisor Panel Styles */
.advisor-panel {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 2px solid #00d9ff;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
}
.advisor-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    color: #00d9ff;
    font-size: 18px;
    font-weight: bold;
}
.advisor-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 15px;
}
.advisor-item {
    background: rgba(0, 0, 0, 0.3);
    padding: 12px;
    border-radius: 8px;
    border-left: 4px solid;
}
.advisor-item.good { border-left-color: #00ff88; }
.advisor-item.warning { border-left-color: #ff9900; }
.advisor-item.danger { border-left-color: #ff4444; }
.advisor-label {
    font-size: 12px;
    color: #888;
    margin-bottom: 5px;
}
.advisor-value {
    font-size: 16px;
    font-weight: bold;
}
.advice-box {
    background: rgba(0, 217, 255, 0.1);
    border-radius: 8px;
    padding: 15px;
    margin-top: 15px;
    border: 1px solid rgba(0, 217, 255, 0.3);
}
.advice-title {
    color: #00ff88;
    font-weight: bold;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
}
.advice-text {
    color: #fff;
    line-height: 1.5;
    font-size: 14px;
}
.status-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-left: 8px;
}
.status-online { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
.status-offline { background: #ff4444; }
.status-warning { background: #ff9900; }

/* Existing Styles */
.controls{background:#0f3460;padding:15px;border-radius:10px;margin-bottom:10px}
.control-row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px}
.control-group{display:flex;flex-direction:column;gap:5px}
.control-group label{font-size:11px;color:#888}
select,input[type="text"]{background:#16213e;color:#fff;border:2px solid #00d9ff;padding:10px;border-radius:6px;font-size:14px;width:100%}
.btn{border:none;padding:15px;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer;width:100%;margin-bottom:10px;transition:all 0.3s}
.btn-start{background:#00d9ff;color:#000}
.btn-start.active{background:#ff4444;color:#fff}
.btn-test{background:#ff9900;color:#000}
.btn-force{background:#00ff88;color:#000}
.btn-scalp{background:#ff00ff;color:#000}
.market-toggle{display:flex;gap:10px;margin-bottom:10px}
.market-btn{flex:1;padding:12px;border-radius:8px;border:2px solid #555;background:#16213e;color:#fff;cursor:pointer;font-weight:bold;transition:all 0.3s}
.market-btn.active{background:#00d9ff;color:#000;border-color:#00d9ff}
.timeframe-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px}
.tf-btn{padding:10px;border-radius:6px;border:2px solid #555;background:#16213e;color:#fff;cursor:pointer;font-size:12px;font-weight:bold;transition:all 0.3s}
.tf-btn.active{border-color:#00d9ff;background:#00d9ff;color:#000}
.status{background:#0f3460;padding:15px;border-radius:10px;margin-bottom:10px;position:relative}
.status-grid{display:grid;grid-template-columns:1fr 1fr;gap:15px;text-align:center}
.status-label{font-size:11px;color:#888;margin-bottom:5px}
.status-value{font-size:20px;font-weight:bold}
.debug{background:#16213e;padding:15px;border-radius:10px;margin-bottom:10px;max-height:200px;overflow-y:auto;font-size:11px;line-height:1.6}
.debug-line{margin:3px 0;padding:3px;border-left:3px solid #00d9ff}
.debug-line.success{border-left-color:#00ff88}
.debug-line.error{border-left-color:#ff4444}
.debug-line.warning{border-left-color:#ff9900}
.debug-line.scalp{border-left-color:#ff00ff}
.signals{margin-top:10px}
.signal-card{background:#16213e;border-left:5px solid #00ff88;padding:15px;border-radius:10px;margin-bottom:15px;animation:slideIn 0.4s ease}
@keyframes slideIn{from{opacity:0;transform:translateX(-20px)}to{opacity:1;transform:translateX(0)}}
.signal-card.sell{border-left-color:#ff4444}
.signal-card.hold{border-left-color:#ff9900}
.signal-card.scalp{border-left:5px solid #ff00ff}
.signal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.signal-type{font-size:20px;font-weight:bold}
.signal-badge{font-size:10px;padding:5px 10px;border-radius:5px;background:rgba(0,255,136,0.2)}
.signal-details{font-size:13px;line-height:1.8}
.signal-details div{margin:5px 0}
.targets{margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.2);background:rgba(0,0,0,0.2);padding:10px;border-radius:5px}
.tf-indicator{display:inline-block;padding:3px 8px;border-radius:4px;font-size:10px;font-weight:bold;margin-left:5px}
.tf-1m{background:#ff00ff;color:#fff}
.tf-5m{background:#ff6b6b;color:#fff}
.tf-15m{background:#ffd93d;color:#000}
.tf-1h{background:#6bcf7f;color:#fff}
.tf-4h{background:#4d96ff;color:#fff}
.footer{text-align:center;padding:15px;font-size:12px;color:#888}
.symbol-list-item{padding:10px;cursor:pointer;border-bottom:1px solid #0f3460;color:#fff;transition:background 0.2s}
.symbol-list-item:hover{background:#0f3460}

/* ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá: ÿßÿ≥ÿ™ÿß€åŸÑ ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ ŸÇ€åŸÖÿ™ */
.price-display {
    font-family: 'Courier New', monospace;
    letter-spacing: 0.5px;
}
.price-tiny {
    font-size: 12px;
    opacity: 0.9;
}

/* ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá: ÿßÿ≥ÿ™ÿß€åŸÑ ÿ®ÿ±ÿß€å ŸÜŸÖÿßÿØŸáÿß€å ŸÅÿßÿ±⁄©ÿ≥ Ÿà ÿ∑ŸÑÿß */
.forex-symbol { color: #ffd700; }
.gold-symbol { color: #ffd700; }

/* ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá: ÿßÿ≥ÿ™ÿß€åŸÑ ÿ®ÿ±ÿß€å Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ÿÆÿ∑ÿß */
.error-message {
    background: rgba(255, 68, 68, 0.2);
    border: 1px solid #ff4444;
    padding: 10px;
    border-radius: 8px;
    margin: 10px 0;
    color: #ff8888;
}

/* ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá: ÿßÿ≥ÿ™ÿß€åŸÑ ÿ®ÿ±ÿß€å ÿØ⁄©ŸÖŸá ÿØ€åÿ®ÿß⁄Ø */
.debug-btn {
    background: #555;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 11px;
    margin-left: 10px;
    cursor: pointer;
    position: absolute;
    top: 10px;
    right: 10px;
}
.debug-btn:hover {
    background: #666;
}

/* ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá: ÿßÿ≥ÿ™ÿß€åŸÑ ÿ®ÿ±ÿß€å ÿ±ŸÅÿ±ÿ¥ ŸÇ€åŸÖÿ™ */
.refresh-price {
    background: transparent;
    border: none;
    color: #00d9ff;
    cursor: pointer;
    font-size: 12px;
    margin-left: 5px;
}
.refresh-price:hover {
    color: #00ff88;
}

/* ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá: ÿßÿ≥ÿ™ÿß€åŸÑ ÿ®ÿ±ÿß€å ÿ™ÿ®‚ÄåŸáÿß */
.tab-container {
    display: flex;
    gap: 5px;
    margin-bottom: 15px;
    background: #0f3460;
    padding: 5px;
    border-radius: 8px;
}
.tab {
    flex: 1;
    padding: 10px;
    text-align: center;
    background: transparent;
    border: none;
    color: #888;
    cursor: pointer;
    border-radius: 6px;
    font-weight: bold;
    transition: all 0.3s;
}
.tab.active {
    background: #00d9ff;
    color: #000;
}
.tab.scalp {
    color: #ff00ff;
}
.tab.scalp.active {
    background: #ff00ff;
    color: #000;
}

/* ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá: ÿßÿ≥ÿ™ÿß€åŸÑ ÿ®ÿ±ÿß€å ÿ≥€å⁄ØŸÜÿßŸÑ‚ÄåŸáÿß€å ÿßÿ≥⁄©ÿßŸÑŸæ */
.scalp-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #ff00ff;
    margin-right: 5px;
    animation: pulse 1s infinite;
}
@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá: ÿßÿ≥ÿ™ÿß€åŸÑ ÿ®ÿ±ÿß€å RSI indicator */
.rsi-indicator {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: bold;
    margin-left: 5px;
}
.rsi-oversold { background: rgba(0, 255, 136, 0.3); color: #00ff88; }
.rsi-overbought { background: rgba(255, 68, 68, 0.3); color: #ff4444; }
.rsi-neutral { background: rgba(255, 255, 255, 0.1); color: #fff; }

/* ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá: ÿßÿ≥ÿ™ÿß€åŸÑ ÿ®ÿ±ÿß€å ÿØÿ±ÿµÿØŸáÿß€å ÿµÿ≠€åÿ≠ */
.percent-positive { color: #00ff88; }
.percent-negative { color: #ff4444; }
.percent-warning { color: #ff9900; }
</style>
</head>
<body>

<div class="header">
<h1>ü§ñ AI Smart Money Scanner v2.1</h1>
<div style="font-size:12px;color:#888;margin-top:5px">Scalp (1m/5m/15m) + Swing (1h/4h) Signals | Real-time Binance</div>
</div>

<!-- AI Advisor Panel -->
<div class="advisor-panel" id="advisorPanel">
    <div class="advisor-header">
        <span>ü§ñ</span>
        <span>AI Market Advisor</span>
        <span id="advisorStatus" class="status-indicator status-warning"></span>
    </div>
    
    <div class="advisor-grid" id="advisorGrid">
        <div class="advisor-item warning">
            <div class="advisor-label">API Status</div>
            <div class="advisor-value" id="apiStatusText">CHECKING...</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Market Condition</div>
            <div class="advisor-value" id="marketCondition">ANALYZING...</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Active Signals</div>
            <div class="advisor-value"><span id="activeSignals">0</span> (<span id="scalpSignals">0</span>‚ö°)</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Signal Confidence</div>
            <div class="advisor-value" id="signalConfidence">--%</div>
        </div>
    </div>
    
    <div class="advice-box" id="adviceBox">
        <div class="advice-title">üí° AI Recommendation</div>
        <div class="advice-text" id="adviceText">
            Initializing system... Click "TEST CONNECTION" to verify API connection.
        </div>
    </div>
</div>

<!-- Tab Navigation -->
<div class="tab-container">
    <button class="tab active" id="tabAll">All Signals</button>
    <button class="tab scalp" id="tabScalp">‚ö° Scalp (1m/5m/15m)</button>
    <button class="tab" id="tabSwing">üìä Swing (1h/4h)</button>
</div>

<div class="controls">
<!-- Market Selection -->
<div class="market-toggle">
<button class="market-btn active" id="cryptoBtn">üíé CRYPTO</button>
<button class="market-btn" id="forexBtn">üí± FOREX & GOLD</button>
</div>

<!-- Symbol Search -->
<div class="control-group" style="margin-bottom:10px">
<label>üîç Search Symbol</label>
<input type="text" id="symbolSearch" placeholder="Type BTC, ETH, SOL...">
<div id="symbolList" style="max-height:200px;overflow-y:auto;background:#16213e;border:2px solid #00d9ff;border-radius:6px;margin-top:5px;display:none"></div>
</div>

<!-- Timeframe Selection -->
<div class="control-group" style="margin-bottom:10px">
<label>‚è∞ Select Timeframes</label>
<div class="timeframe-grid">
<button class="tf-btn active" id="tf5m">5 Min</button>
<button class="tf-btn active" id="tf15m">15 Min</button>
<button class="tf-btn active" id="tf1h">1 Hour</button>
<button class="tf-btn" id="tf1m">1 Min</button>
<button class="tf-btn" id="tf4h">4 Hour</button>
</div>
</div>

<div class="control-row">
<div class="control-group">
<label>üìä Current Symbol</label>
<div style="display:flex;align-items:center">
<input type="text" id="symbol" value="BTCUSDT" readonly style="background:#1a1a2e;color:#00ff88;border:2px solid #00ff88;font-weight:bold;flex:1">
<button class="refresh-price" id="refreshPriceBtn" title="Refresh price">üîÑ</button>
</div>
</div>
<div class="control-group">
<label>üéØ Signal Quality</label>
<select id="quality">
<option value="40">Easy (40%)</option>
<option value="60" selected>PRO (60%)</option>
<option value="75">Expert (75%)</option>
<option value="65">Scalp (65%)</option>
</select>
</div>
</div>

<button class="btn btn-start" id="startBtn">‚ñ∂ START SCANNING</button>
<button class="btn btn-scalp" id="scalpBtn">‚ö° SCALP SCAN</button>
<button class="btn btn-test" id="testBtn">üß™ TEST CONNECTION</button>
<button class="btn btn-force" id="forceBtn">‚ö† FULL SCAN</button>
</div>

<div class="status">
<button class="debug-btn" id="priceDebugBtn">üîß Debug Price</button>
<div class="status-grid">
<div>
<div class="status-label">üíé Price</div>
<div class="status-value price-display" id="price" style="color:#00d9ff;cursor:pointer" title="Double-click to refresh price">--</div>
</div>
<div>
<div class="status-label">üìà Confidence</div>
<div class="status-value" id="confidence">--</div>
</div>
</div>
<div id="priceSource" style="font-size:10px;color:#888;text-align:center;margin-top:5px">--</div>
</div>

<div class="debug" id="debug">
<div class="debug-line success">üöÄ AI Smart Money Scanner v2.1 Ready!</div>
<div class="debug-line">‚ö° Scalp Signals (1m/5m/15m) Enabled</div>
<div class="debug-line">üìä Swing Signals (1h/4h) Enabled</div>
<div class="debug-line">üåê API: <span id="apiUrlDisplay">crypto-trading-system-0zab.onrender.com</span></div>
</div>

<div id="connectionError" class="error-message" style="display:none">
‚ö†Ô∏è <strong>Connection Error:</strong> <span id="errorMessage">Unable to connect to API</span>
</div>

<div class="signals" id="signals"></div>

<div class="footer">
<div>Signals: <strong id="signalCount">0</strong> (<span id="scalpCount">0</span>‚ö°) | Active TF: <strong id="activeTFs">3</strong></div>
<div style="margin-top:5px;font-size:10px">API: <span style="color:#00ff88" id="apiUrlFooter">crypto-trading-system-0zab.onrender.com</span> | Last Scan: <span id="lastUpdate">--</span></div>
</div>

<script>
// ========== CONFIGURATION ==========
const CONFIG = {
    API_URL: 'https://crypto-trading-system-0zab.onrender.com',
    USE_PROXY: false,
    ENABLE_REAL_DATA: true,
    SCAN_INTERVAL: 30000,
    SCALP_INTERVAL: 15000,
    UPDATE_INTERVAL: 10000
};

// ========== GLOBAL VARIABLES ==========
let isScanning = false;
let isScalping = false;
let signalCount = 0;
let scalpSignalCount = 0;
let scanInterval = null;
let scalpInterval = null;
let allSymbols = [];
let currentMarket = 'crypto';
let activeTimeframes = ['5m', '15m', '1h'];
let scalpTimeframes = ['1m', '5m', '15m'];
let apiStatus = 'checking';
let lastRealPrices = {};
let activeTab = 'all';
let priceWebSockets = {};

// ========== PRICE FORMATTING ==========
function formatPrice(price) {
    if (typeof price !== 'number' || isNaN(price)) return '--';
    
    if (price < 0.00001) return parseFloat(price.toFixed(8)).toString();
    if (price < 0.001) return parseFloat(price.toFixed(6)).toString();
    
    const formatted = price.toFixed(5);
    return parseFloat(formatted).toString();
}

function formatPriceWithPrecision(price) {
    if (typeof price !== 'number' || isNaN(price)) return '--';
    
    if (Number.isInteger(price)) {
        return price.toFixed(2);
    }
    
    const formatted = price.toFixed(5);
    let result = formatted;
    
    if (result.includes('.')) {
        while (result.endsWith('0')) {
            result = result.slice(0, -1);
        }
        if (result.endsWith('.')) {
            result = result.slice(0, -1);
        }
    }
    
    return result;
}

// ========== REAL-TIME PRICE FUNCTIONS ==========
function convertToBinanceSymbol(symbol) {
    const upperSymbol = symbol.toUpperCase();
    
    if (upperSymbol === 'XAUUSD') return 'PAXGUSDT';
    if (upperSymbol === 'XAUTUSD') return 'XAUTUSDT';
    
    if (!upperSymbol.endsWith('USDT') && !upperSymbol.endsWith('BUSD')) {
        if (upperSymbol.includes('USD') || upperSymbol.endsWith('USD')) {
            return upperSymbol.replace(/USD$/g, 'USDT');
        }
        return upperSymbol + 'USDT';
    }
    
    return upperSymbol;
}

// ÿ™ÿßÿ®ÿπ ÿßÿµŸÑ€å Ÿà ÿØÿ±ÿ≥ÿ™ ÿ®ÿ±ÿß€å ÿØÿ±€åÿßŸÅÿ™ ŸÇ€åŸÖÿ™ ÿßÿ≤ Binance
async function getDirectBinancePrice(symbol) {
    try {
        const binanceSymbol = convertToBinanceSymbol(symbol);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        
        const response = await fetch(
            `https://api.binance.com/api/v3/ticker/price?symbol=${binanceSymbol}`,
            { signal: controller.signal }
        );
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
            const data = await response.json();
            const price = parseFloat(data.price);
            
            if (!isNaN(price) && price > 0) {
                lastRealPrices[symbol] = {
                    price: price,
                    timestamp: Date.now(),
                    source: 'Binance',
                    symbol: binanceSymbol
                };
                
                return price;
            }
        }
        
        return null;
        
    } catch (error) {
        if (error.name === 'AbortError') {
            console.log(`Timeout for ${symbol}`);
        } else {
            console.error(`Binance error for ${symbol}:`, error.message);
        }
        return null;
    }
}

// ÿ™ÿßÿ®ÿπ WebSocket ÿ®ÿ±ÿß€å ŸÇ€åŸÖÿ™‚ÄåŸáÿß€å ŸÑÿ≠ÿ∏Ÿá‚Äåÿß€å
function connectPriceWebSocket(symbol) {
    const originalSymbol = symbol.toUpperCase();
    let binanceSymbol = convertToBinanceSymbol(symbol).toLowerCase();
    
    if (priceWebSockets[originalSymbol]) {
        try {
            priceWebSockets[originalSymbol].close();
        } catch (e) {}
    }
    
    if (typeof WebSocket === 'undefined') {
        console.log('WebSocket not supported');
        return;
    }
    
    const wsUrl = `wss://stream.binance.com:9443/ws/${binanceSymbol}@ticker`;
    
    try {
        const ws = new WebSocket(wsUrl);
        
        ws.onopen = () => {
            addLog(`üîå WebSocket connected for ${originalSymbol}`, 'success');
        };
        
        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                const price = parseFloat(data.c);
                
                if (!isNaN(price) && price > 0) {
                    lastRealPrices[originalSymbol] = {
                        price: price,
                        timestamp: Date.now(),
                        source: 'Binance WebSocket',
                        symbol: binanceSymbol.toUpperCase()
                    };
                    
                    if (document.getElementById('symbol').value === originalSymbol) {
                        const priceElement = document.getElementById('price');
                        const formattedPrice = formatPriceWithPrecision(price);
                        priceElement.innerHTML = `$${formattedPrice} <span style="color:#00ff88; font-size:12px">üî¥ LIVE</span>`;
                        
                        const priceSourceElement = document.getElementById('priceSource');
                        priceSourceElement.textContent = 'Source: Binance WebSocket (Real-time)';
                        priceSourceElement.style.color = '#00ff88';
                    }
                }
            } catch (error) {
                console.error('WebSocket message error:', error);
            }
        };
        
        ws.onerror = (error) => {
            addLog(`‚ùå WebSocket error for ${originalSymbol}`, 'error');
        };
        
        ws.onclose = () => {
            addLog(`üîå WebSocket closed for ${originalSymbol}`, 'warning');
            
            setTimeout(() => {
                if (document.getElementById('symbol').value === originalSymbol) {
                    connectPriceWebSocket(originalSymbol);
                }
            }, 5000);
        };
        
        priceWebSockets[originalSymbol] = ws;
        
    } catch (error) {
        console.error('Error creating WebSocket:', error);
    }
}

// ÿ™ÿßÿ®ÿπ ÿßÿµŸÑ€å ÿØÿ±€åÿßŸÅÿ™ ŸÇ€åŸÖÿ™ - ÿ®ÿØŸàŸÜ ŸÇ€åŸÖÿ™ ÿ´ÿßÿ®ÿ™ ÿßÿ¥ÿ™ÿ®ÿßŸá
async function getCurrentMarketPrice(symbol, forceRefresh = false) {
    const originalSymbol = symbol.toUpperCase();
    
    if (!priceWebSockets[originalSymbol]) {
        connectPriceWebSocket(originalSymbol);
    }
    
    if (!forceRefresh && lastRealPrices[originalSymbol]) {
        const cached = lastRealPrices[originalSymbol];
        const age = Date.now() - cached.timestamp;
        
        if (age < 10000) {
            return {
                price: cached.price,
                source: cached.source,
                isReal: true,
                originalSymbol: originalSymbol
            };
        }
    }
    
    const binancePrice = await getDirectBinancePrice(originalSymbol);
    
    if (binancePrice !== null) {
        return {
            price: binancePrice,
            source: 'Binance REST API',
            isReal: true,
            originalSymbol: originalSymbol
        };
    }
    
    // ÿß⁄Øÿ± Ÿá€å⁄Ü‚Äå⁄©ÿØÿßŸÖ ÿ¨Ÿàÿßÿ® ŸÜÿØÿßÿØÿå null ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜ
    return null;
}

// ========== API HELPER ==========
async function makeRequest(endpoint, data = null) {
    const url = `${CONFIG.API_URL}${endpoint}`;
    
    const options = {
        method: data ? 'POST' : 'GET',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
    };
    
    if (data) {
        options.body = JSON.stringify(data);
    }
    
    try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        return await response.json();
        
    } catch (error) {
        console.error(`API Request failed:`, error);
        throw error;
    }
}

// ========== SCALP SCANNING FUNCTION ==========
async function scanScalp() {
    const symbol = document.getElementById('symbol').value;
    const minConfidence = 0.65;
    
    addLog(`‚ö° Scanning scalp signals for ${symbol}...`, 'scalp');
    
    for (const tf of scalpTimeframes) {
        try {
            const scalpSignal = await makeRequest('/api/scalp-signal', {
                symbol: symbol,
                timeframe: tf
            });
            
            const priceInfo = await getCurrentMarketPrice(symbol);
            
            const scalpData = {
                symbol: scalpSignal.symbol || symbol,
                signal: scalpSignal.signal || 'HOLD',
                confidence: scalpSignal.confidence || 0.5,
                entry_price: priceInfo ? priceInfo.price : 0,
                rsi: scalpSignal.rsi || 50,
                sma_20: scalpSignal.sma_20 || (priceInfo ? priceInfo.price * 0.99 : 0),
                volume_ratio: 1.2,
                message: scalpSignal.reason || `Scalp signal on ${tf} timeframe`,
                source: scalpSignal.strategy || 'Scalp Analysis',
                targets: scalpSignal.targets || (priceInfo ? [priceInfo.price * 1.01, priceInfo.price * 1.02] : []),
                stop_loss: scalpSignal.stop_loss || (priceInfo ? priceInfo.price * 0.99 : 0),
                timestamp: new Date().toISOString(),
                price_source: priceInfo ? priceInfo.source : 'No price',
                is_real_price: priceInfo ? priceInfo.isReal : false,
                type: 'SCALP',
                timeframe: tf,
                risk_level: tf === '1m' ? 'HIGH' : 'MEDIUM'
            };
            
            if (scalpData.confidence >= minConfidence && (scalpData.signal === 'BUY' || scalpData.signal === 'SELL') && scalpData.entry_price > 0) {
                addSignal(scalpData, tf, 'SCALP‚ö°');
                addLog(`‚ö° [${tf}] ${scalpData.signal} - ${(scalpData.confidence * 100).toFixed(0)}% (RSI: ${scalpData.rsi})`, 'success');
                
                scalpSignalCount++;
                document.getElementById('scalpCount').textContent = scalpSignalCount;
                document.getElementById('scalpSignals').textContent = scalpSignalCount;
            }
            
        } catch (error) {
            console.log(`Scalp scan failed for ${tf}:`, error);
        }
        
        await sleep(500);
    }
}

// ========== REGULAR SCANNING FUNCTION ==========
async function scanMarket(timeframe) {
    const symbol = document.getElementById('symbol').value;
    const minConfidence = parseInt(document.getElementById('quality').value) / 100;
    
    try {
        addLog(`üì° Scanning ${symbol} (${timeframe})...`, 'info');
        
        const priceInfo = await getCurrentMarketPrice(symbol);
        
        let analysisResult;
        
        try {
            analysisResult = await makeRequest('/api/analyze', {
                symbol: symbol,
                timeframe: timeframe
            });
            
            apiStatus = 'online';
            updateApiStatus('online');
            
        } catch (apiError) {
            apiStatus = 'offline';
            updateApiStatus('offline');
            
            const randomSignal = Math.random() > 0.5 ? 'BUY' : (Math.random() > 0.5 ? 'SELL' : 'HOLD');
            const randomConfidence = 0.5 + Math.random() * 0.4;
            
            analysisResult = {
                symbol: symbol,
                signal: randomSignal,
                confidence: randomConfidence,
                entry_price: priceInfo ? priceInfo.price : 0,
                targets: randomSignal === 'BUY' ? 
                    [priceInfo ? priceInfo.price * 1.02 : 0, priceInfo ? priceInfo.price * 1.05 : 0] : 
                    randomSignal === 'SELL' ? 
                    [priceInfo ? priceInfo.price * 0.98 : 0, priceInfo ? priceInfo.price * 0.95 : 0] : 
                    [],
                stop_loss: randomSignal === 'BUY' ? 
                    (priceInfo ? priceInfo.price * 0.98 : 0) : 
                    randomSignal === 'SELL' ? 
                    (priceInfo ? priceInfo.price * 1.02 : 0) : 
                    (priceInfo ? priceInfo.price : 0),
                strategy: 'Fallback Analysis'
            };
        }
        
        const safeData = {
            symbol: analysisResult.symbol || symbol,
            signal: analysisResult.signal || 'HOLD',
            confidence: analysisResult.confidence || 0.5,
            entry_price: analysisResult.entry_price || (priceInfo ? priceInfo.price : 0),
            rsi: analysisResult.rsi || 50,
            volume_ratio: analysisResult.volume_ratio || 1,
            message: analysisResult.recommendation || analysisResult.message || 'Analysis completed',
            source: analysisResult.strategy || 'API Analysis',
            targets: Array.isArray(analysisResult.targets) ? analysisResult.targets : 
                   analysisResult.signal === 'BUY' ? [priceInfo ? priceInfo.price * 1.02 : 0, priceInfo ? priceInfo.price * 1.05 : 0] :
                   analysisResult.signal === 'SELL' ? [priceInfo ? priceInfo.price * 0.98 : 0, priceInfo ? priceInfo.price * 0.95 : 0] : [],
            stop_loss: analysisResult.stop_loss || 
                     (analysisResult.signal === 'BUY' ? (priceInfo ? priceInfo.price * 0.98 : 0) :
                      analysisResult.signal === 'SELL' ? (priceInfo ? priceInfo.price * 1.02 : 0) : (priceInfo ? priceInfo.price : 0)),
            timestamp: new Date().toISOString(),
            price_source: priceInfo ? priceInfo.source : 'No price',
            is_real_price: priceInfo ? priceInfo.isReal : false,
            type: timeframe === '1h' || timeframe === '4h' ? 'SWING' : 'REGULAR',
            timeframe: timeframe,
            risk_level: 'MEDIUM'
        };
        
        updateStatus(safeData);
        
        if (safeData.confidence >= minConfidence && (safeData.signal === 'BUY' || safeData.signal === 'SELL') && safeData.entry_price > 0) {
            const quality = safeData.confidence >= 0.85 ? 'ULTRAüî•' :
                          safeData.confidence >= 0.70 ? 'HIGHüî•' :
                          safeData.confidence >= minConfidence ? 'GOOD' : 'WEAK';
            
            addSignal(safeData, timeframe, quality);
        }
        
        return safeData;
        
    } catch (error) {
        addLog(`‚ùå [${timeframe}] Error: ${error.message}`, 'error');
        return null;
    }
}

// ========== UI UPDATE FUNCTIONS ==========
function updateStatus(data) {
    const priceElement = document.getElementById('price');
    const priceSourceElement = document.getElementById('priceSource');
    
    if (data.entry_price > 0) {
        const priceValue = formatPriceWithPrecision(data.entry_price);
        
        if (data.is_real_price) {
            priceElement.innerHTML = `$${priceValue} <span style="color:#00ff88; font-size:12px">‚úÖ</span>`;
            priceSourceElement.textContent = `Source: ${data.price_source}`;
            priceSourceElement.style.color = '#00ff88';
        } else {
            priceElement.textContent = `$${priceValue}`;
            priceSourceElement.textContent = `Source: ${data.price_source} (Reference)`;
            priceSourceElement.style.color = '#ff9900';
        }
    } else {
        priceElement.textContent = '--';
        priceSourceElement.textContent = 'Source: No price data';
        priceSourceElement.style.color = '#ff4444';
    }
    
    document.getElementById('confidence').textContent = (data.confidence * 100).toFixed(0) + '%';
    document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
    document.getElementById('signalConfidence').textContent = (data.confidence * 100).toFixed(0) + '%';
    
    updateMarketCondition(data);
}

function updateMarketCondition(data) {
    const conditionElement = document.getElementById('marketCondition');
    const activeSignalsElement = document.getElementById('activeSignals');
    
    if (data.signal === 'BUY' && data.confidence > 0.7) {
        conditionElement.textContent = 'BULLISH';
        conditionElement.parentElement.className = 'advisor-item good';
    } else if (data.signal === 'SELL' && data.confidence > 0.7) {
        conditionElement.textContent = 'BEARISH';
        conditionElement.parentElement.className = 'advisor-item danger';
    } else {
        conditionElement.textContent = 'NEUTRAL';
        conditionElement.parentElement.className = 'advisor-item warning';
    }
    
    activeSignalsElement.textContent = signalCount;
}

function updateApiStatus(status) {
    const statusElement = document.getElementById('apiStatusText');
    const indicator = document.getElementById('advisorStatus');
    const errorDiv = document.getElementById('connectionError');
    const adviceText = document.getElementById('adviceText');
    
    apiStatus = status;
    
    if (status === 'online') {
        statusElement.textContent = 'ONLINE';
        statusElement.parentElement.className = 'advisor-item good';
        indicator.className = 'status-indicator status-online';
        errorDiv.style.display = 'none';
        adviceText.innerHTML = '‚úÖ API connection established. Scalp & Swing analysis active.';
    } else if (status === 'offline') {
        statusElement.textContent = 'OFFLINE';
        statusElement.parentElement.className = 'advisor-item danger';
        indicator.className = 'status-indicator status-offline';
        errorDiv.style.display = 'block';
        document.getElementById('errorMessage').textContent = 'Cannot connect to API server';
        adviceText.innerHTML = '‚ö†Ô∏è API connection lost. Using fallback analysis.';
    } else {
        statusElement.textContent = 'CHECKING...';
        statusElement.parentElement.className = 'advisor-item warning';
        indicator.className = 'status-indicator status-warning';
        adviceText.innerHTML = 'Checking API connection...';
    }
}

function addSignal(data, timeframe, quality) {
    signalCount++;
    document.getElementById('signalCount').textContent = signalCount;
    document.getElementById('activeSignals').textContent = signalCount;
    
    const tfClass = timeframe === '1m' ? 'tf-1m' :
                   timeframe === '5m' ? 'tf-5m' :
                   timeframe === '15m' ? 'tf-15m' :
                   timeframe === '1h' ? 'tf-1h' : 'tf-4h';
    
    const tfLabel = timeframe === '1m' ? '1 Min' :
                   timeframe === '5m' ? '5 Min' :
                   timeframe === '15m' ? '15 Min' :
                   timeframe === '1h' ? '1 Hour' : '4 Hour';
    
    const type = data.signal.toLowerCase();
    const isScalp = data.type === 'SCALP';
    const signalClass = isScalp ? 'scalp' : type;
    
    let targetsHtml = '<div style="color:#888">No targets specified</div>';
    if (data.targets && data.targets.length > 0 && data.entry_price > 0) {
        targetsHtml = data.targets.map((target, index) => {
            const gainPercent = ((target / data.entry_price - 1) * 100).toFixed(2);
            let sign = '';
            let color = '#00ff88';
            
            if (data.signal === 'BUY') {
                sign = gainPercent >= 0 ? '+' : '';
                color = '#00ff88';
            } else if (data.signal === 'SELL') {
                color = '#ff4444';
                sign = gainPercent < 0 ? '-' : '';
            }
            
            const percentDisplay = Math.abs(gainPercent);
            
            return `<div>üéØ TP${index + 1}: $${formatPriceWithPrecision(target)} <span class="percent-${gainPercent >= 0 ? 'positive' : 'negative'}" style="color:${color}">(${sign}${percentDisplay}%)</span></div>`;
        }).join('');
    }
    
    let stopLossHtml = '';
    if (data.stop_loss > 0 && data.entry_price > 0) {
        const lossPercent = ((data.stop_loss / data.entry_price - 1) * 100).toFixed(2);
        let sign = '';
        let color = '#ff4444';
        
        if (data.signal === 'BUY') {
            color = '#ff4444';
            sign = lossPercent < 0 ? '-' : '';
        } else if (data.signal === 'SELL') {
            color = '#ff9900';
            sign = lossPercent >= 0 ? '+' : '';
        }
        
        const percentDisplay = Math.abs(lossPercent);
        
        stopLossHtml = `<div>üõë Stop Loss: $${formatPriceWithPrecision(data.stop_loss)} <span class="percent-${lossPercent >= 0 ? 'warning' : 'negative'}" style="color:${color}">(${sign}${percentDisplay}%)</span></div>`;
    }
    
    let rsiHtml = '';
    if (data.rsi) {
        const rsiClass = data.rsi < 30 ? 'rsi-oversold' : data.rsi > 70 ? 'rsi-overbought' : 'rsi-neutral';
        rsiHtml = `<span class="rsi-indicator ${rsiClass}">RSI: ${data.rsi.toFixed(1)}</span>`;
    }
    
    const realPriceBadge = data.is_real_price ? 
        `<span style="color:#00ff88; font-size:10px; margin-left:5px">‚úÖ Live</span>` : 
        `<span style="color:#ff9900; font-size:10px; margin-left:5px">‚ö†Ô∏è Ref</span>`;
    
    const scalpBadge = isScalp ? `<span class="scalp-indicator"></span>` : '';
    
    const card = `
        <div class="signal-card ${signalClass}" data-type="${data.type}" data-timeframe="${timeframe}">
            <div class="signal-header">
                <div class="signal-type">
                    ${scalpBadge}${type === 'buy' ? 'üü¢ BUY' : type === 'sell' ? 'üî¥ SELL' : 'üü° HOLD'} 
                    <span class="tf-indicator ${tfClass}">${tfLabel}</span>
                    ${rsiHtml}
                </div>
                <div class="signal-badge" style="background: ${isScalp ? 'rgba(255,0,255,0.2)' : type === 'buy' ? 'rgba(0,255,136,0.2)' : type === 'sell' ? 'rgba(255,68,68,0.2)' : 'rgba(255,255,0,0.2)'}">
                    ${isScalp ? '‚ö° ' : ''}${quality} ${realPriceBadge}
                </div>
            </div>
            <div class="signal-details">
                <div><strong>${data.symbol}</strong> ‚Ä¢ ${data.source} ${data.risk_level ? `<span style="color:#ff9900;font-size:10px">(${data.risk_level} Risk)</span>` : ''}</div>
                <div class="price-display">üí∞ Entry: <strong>$${formatPriceWithPrecision(data.entry_price)}</strong> ${data.is_real_price ? '‚úÖ' : '‚ö†Ô∏è'}</div>
                <div>üìä Confidence: <strong>${(data.confidence * 100).toFixed(1)}%</strong></div>
                ${data.sma_20 ? `<div class="price-display">üìà SMA20: <strong>$${formatPriceWithPrecision(data.sma_20)}</strong></div>` : ''}
                <div>üí° ${data.message}</div>
                <div class="targets">
                    <strong>üéØ Targets:</strong>
                    ${targetsHtml}
                    ${stopLossHtml}
                </div>
                <div style="margin-top:10px;color:#888;font-size:11px">
                    ‚è∞ ${new Date(data.timestamp).toLocaleTimeString()} ‚Ä¢ ${data.price_source} ‚Ä¢ ${data.type}
                </div>
            </div>
        </div>`;
    
    const container = document.getElementById('signals');
    
    if (activeTab === 'all' || 
        (activeTab === 'scalp' && isScalp) || 
        (activeTab === 'swing' && data.type === 'SWING')) {
        container.insertAdjacentHTML('afterbegin', card);
    }
    
    if (container.children.length > 15) {
        container.removeChild(container.lastChild);
    }
    
    updateSignalCounters();
}

function updateSignalCounters() {
    const signals = document.querySelectorAll('.signal-card');
    let scalpCount = 0;
    let swingCount = 0;
    let regularCount = 0;
    
    signals.forEach(signal => {
        const type = signal.dataset.type;
        if (type === 'SCALP') scalpCount++;
        else if (type === 'SWING') swingCount++;
        else regularCount++;
    });
    
    document.getElementById('scalpCount').textContent = scalpCount;
    document.getElementById('scalpSignals').textContent = scalpCount;
}

// ========== TAB MANAGEMENT ==========
function setupTabs() {
    document.getElementById('tabAll').addEventListener('click', () => switchTab('all'));
    document.getElementById('tabScalp').addEventListener('click', () => switchTab('scalp'));
    document.getElementById('tabSwing').addEventListener('click', () => switchTab('swing'));
}

function switchTab(tab) {
    activeTab = tab;
    
    document.getElementById('tabAll').classList.toggle('active', tab === 'all');
    document.getElementById('tabScalp').classList.toggle('active', tab === 'scalp');
    document.getElementById('tabSwing').classList.toggle('active', tab === 'swing');
    
    const signals = document.querySelectorAll('.signal-card');
    signals.forEach(signal => {
        const signalType = signal.dataset.type;
        const timeframe = signal.dataset.timeframe;
        
        let shouldShow = false;
        
        if (tab === 'all') {
            shouldShow = true;
        } else if (tab === 'scalp') {
            shouldShow = signalType === 'SCALP';
        } else if (tab === 'swing') {
            shouldShow = signalType === 'SWING';
        }
        
        signal.style.display = shouldShow ? 'block' : 'none';
    });
    
    addLog(`üìä Switched to ${tab.toUpperCase()} tab`, 'info');
}

// ========== SYMBOL MANAGEMENT ==========
function loadAllSymbols() {
    allSymbols = [
        'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT',
        'AVAXUSDT', 'DOTUSDT', 'DOGEUSDT', 'MATICUSDT', 'SHIBUSDT', 'LTCUSDT',
        'UNIUSDT', 'LINKUSDT', 'ATOMUSDT', 'ETCUSDT', 'XLMUSDT', 'ALGOUSDT',
        'VETUSDT', 'FILUSDT', 'TRXUSDT', 'EOSUSDT', 'AAVEUSDT', 'XTZUSDT',
        'SANDUSDT', 'MANAUSDT', 'GALAUSDT', 'APEUSDT', 'CHZUSDT', 'ENJUSDT',
        'COMPUSDT', 'MKRUSDT', 'SNXUSDT', 'CRVUSDT', '1INCHUSDT',
        'NEARUSDT', 'FTMUSDT', 'ICPUSDT', 'HBARUSDT',
        'PEPEUSDT', 'FLOKIUSDT', 'BONKUSDT',
        'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
        'EURGBP', 'EURJPY', 'GBPJPY', 'AUDJPY', 'XAUUSD', 'XAGUSD',
        'PAXGUSDT', 'XAUTUSDT'
    ].sort();
    
    addLog(`‚úÖ ${allSymbols.length} symbols loaded`, 'success');
}

function handleSearch(e) {
    const query = e.target.value.toUpperCase();
    const list = document.getElementById('symbolList');
    
    if (!query.trim()) {
        list.style.display = 'none';
        return;
    }
    
    const filtered = allSymbols
        .filter(s => s.includes(query))
        .slice(0, 10);
    
    if (filtered.length > 0) {
        list.innerHTML = filtered.map(symbol => {
            const displayName = symbol.replace('USDT', '').replace('USD', '');
            return `<div class="symbol-list-item" data-symbol="${symbol}">
                      ${displayName} <span style="color:#888;font-size:11px">(${symbol})</span>
                    </div>`;
        }).join('');
        
        list.querySelectorAll('.symbol-list-item').forEach(item => {
            item.addEventListener('click', function() {
                selectSymbol(this.dataset.symbol);
            });
        });
        
        list.style.display = 'block';
    } else {
        list.innerHTML = '<div style="padding:10px;color:#888">No symbols found</div>';
        list.style.display = 'block';
    }
}

async function selectSymbol(symbol) {
    document.getElementById('symbol').value = symbol;
    document.getElementById('symbolSearch').value = '';
    document.getElementById('symbolList').style.display = 'none';
    addLog(`‚úÖ Selected symbol: ${symbol}`, 'success');
    
    connectPriceWebSocket(symbol);
    
    if (isForexGoldSymbol(symbol)) {
        switchMarket('forex');
    } else {
        switchMarket('crypto');
    }
    
    const priceInfo = await getCurrentMarketPrice(symbol, true);
    
    if (priceInfo) {
        const formattedPrice = formatPriceWithPrecision(priceInfo.price);
        
        if (priceInfo.isReal) {
            document.getElementById('price').innerHTML = `$${formattedPrice} <span style="color:#00ff88; font-size:12px">‚úÖ LIVE</span>`;
        } else {
            document.getElementById('price').textContent = '$' + formattedPrice;
        }
        
        document.getElementById('priceSource').textContent = `Source: ${priceInfo.source}`;
        document.getElementById('priceSource').style.color = priceInfo.isReal ? '#00ff88' : '#ff9900';
        addLog(`üí∞ ${symbol} price: $${formattedPrice} (${priceInfo.source})`, 'info');
    } else {
        document.getElementById('price').textContent = '--';
        document.getElementById('priceSource').textContent = 'Source: Failed to fetch price';
        document.getElementById('priceSource').style.color = '#ff4444';
        addLog(`‚ùå Failed to get price for ${symbol}`, 'error');
    }
}

function isForexGoldSymbol(symbol) {
    const forexGoldSymbols = [
        'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
        'EURGBP', 'EURJPY', 'GBPJPY', 'AUDJPY', 'XAUUSD', 'XAGUSD', 'PAXG', 'XAUT'
    ];
    
    return forexGoldSymbols.some(forexSymbol => 
        symbol.includes(forexSymbol) || forexSymbol.includes(symbol)
    );
}

// ========== EVENT HANDLERS ==========
function setupEventListeners() {
    document.getElementById('cryptoBtn').addEventListener('click', () => switchMarket('crypto'));
    document.getElementById('forexBtn').addEventListener('click', () => switchMarket('forex'));
    
    document.getElementById('tf1m').addEventListener('click', () => toggleTimeframe('1m'));
    document.getElementById('tf5m').addEventListener('click', () => toggleTimeframe('5m'));
    document.getElementById('tf15m').addEventListener('click', () => toggleTimeframe('15m'));
    document.getElementById('tf1h').addEventListener('click', () => toggleTimeframe('1h'));
    document.getElementById('tf4h').addEventListener('click', () => toggleTimeframe('4h'));
    
    document.getElementById('startBtn').addEventListener('click', toggleScanning);
    document.getElementById('scalpBtn').addEventListener('click', toggleScalping);
    document.getElementById('testBtn').addEventListener('click', testConnection);
    document.getElementById('forceBtn').addEventListener('click', forceScan);
    document.getElementById('priceDebugBtn').addEventListener('click', debugPrice);
    document.getElementById('refreshPriceBtn').addEventListener('click', refreshCurrentPrice);
    
    document.getElementById('symbolSearch').addEventListener('input', handleSearch);
    
    document.getElementById('price').addEventListener('dblclick', refreshCurrentPrice);
    
    setupTabs();
}

async function refreshCurrentPrice() {
    const symbol = document.getElementById('symbol').value;
    addLog(`üîÑ Refreshing price for ${symbol}...`, 'info');
    
    try {
        const priceInfo = await getCurrentMarketPrice(symbol, true);
        
        if (priceInfo) {
            const formattedPrice = formatPriceWithPrecision(priceInfo.price);
            
            if (priceInfo.isReal) {
                document.getElementById('price').innerHTML = `$${formattedPrice} <span style="color:#00ff88; font-size:12px">‚úÖ</span>`;
                document.getElementById('priceSource').textContent = `Source: ${priceInfo.source} (Live)`;
                document.getElementById('priceSource').style.color = '#00ff88';
            } else {
                document.getElementById('price').textContent = '$' + formattedPrice;
                document.getElementById('priceSource').textContent = `Source: ${priceInfo.source} (Reference)`;
                document.getElementById('priceSource').style.color = '#ff9900';
            }
        } else {
            document.getElementById('price').textContent = '--';
            document.getElementById('priceSource').textContent = 'Source: Failed to fetch';
            document.getElementById('priceSource').style.color = '#ff4444';
        }
        
    } catch (error) {
        addLog(`‚ùå Price refresh failed: ${error.message}`, 'error');
    }
}

async function debugPrice() {
    const symbol = document.getElementById('symbol').value;
    const priceInfo = await getCurrentMarketPrice(symbol, true);
    
    let debugInfo = `Price Debug for ${symbol}:\n\n`;
    
    if (priceInfo) {
        debugInfo += `Formatted Price: $${formatPriceWithPrecision(priceInfo.price)}\n`;
        debugInfo += `Raw Price: ${priceInfo.price}\n`;
        debugInfo += `Source: ${priceInfo.source}\n`;
        debugInfo += `Real Price: ${priceInfo.isReal ? '‚úÖ Yes' : '‚ùå No'}\n`;
    } else {
        debugInfo += `‚ùå No price data available\n`;
    }
    
    debugInfo += `\nCached: ${lastRealPrices[symbol] ? 'Yes' : 'No'}`;
    
    alert(debugInfo);
}

function toggleScanning() {
    const btn = document.getElementById('startBtn');
    
    if (!isScanning) {
        isScanning = true;
        btn.textContent = '‚è∏ STOP SCANNING';
        btn.classList.add('active');
        addLog('üöÄ Regular scanning started', 'success');
        
        forceScan();
        scanInterval = setInterval(() => {
            if (isScanning) forceScan();
        }, CONFIG.SCAN_INTERVAL);
        
    } else {
        isScanning = false;
        btn.textContent = '‚ñ∂ START SCANNING';
        btn.classList.remove('active');
        addLog('üõë Regular scanning stopped', 'error');
        
        if (scanInterval) {
            clearInterval(scanInterval);
            scanInterval = null;
        }
    }
}

function toggleScalping() {
    const btn = document.getElementById('scalpBtn');
    
    if (!isScalping) {
        isScalping = true;
        btn.textContent = '‚è∏ STOP SCALP';
        btn.classList.add('active');
        addLog('‚ö° Scalp scanning started', 'success');
        
        scanScalp();
        scalpInterval = setInterval(() => {
            if (isScalping) scanScalp();
        }, CONFIG.SCALP_INTERVAL);
        
    } else {
        isScalping = false;
        btn.textContent = '‚ö° SCALP SCAN';
        btn.classList.remove('active');
        addLog('üõë Scalp scanning stopped', 'error');
        
        if (scalpInterval) {
            clearInterval(scalpInterval);
            scalpInterval = null;
        }
    }
}

async function forceScan() {
    if (activeTimeframes.length === 0) {
        addLog('‚ö†Ô∏è Please select at least one timeframe', 'warning');
        return;
    }
    
    const symbol = document.getElementById('symbol').value;
    addLog(`üîç Full scan for ${symbol}...`, 'info');
    
    for (const tf of activeTimeframes) {
        await scanMarket(tf);
        await sleep(1000);
    }
    
    addLog('‚úÖ Full scan completed', 'success');
}

async function testConnection() {
    addLog('üß™ Testing connection and features...', 'warning');
    updateApiStatus('checking');
    
    try {
        try {
            const health = await makeRequest('/api/health');
            addLog(`‚úÖ API Health: ${health.status}`, 'success');
            addLog(`üìä Version: ${health.version}`, 'info');
            updateApiStatus('online');
            
            if (health.scalp_support && health.scalp_support.enabled) {
                addLog(`‚ö° Scalp support: ENABLED (${health.scalp_support.timeframes.join('/')})`, 'success');
            }
            
        } catch (e) {
            addLog(`‚ùå Health endpoint: ${e.message}`, 'error');
            updateApiStatus('offline');
        }
        
        try {
            const priceInfo = await getCurrentMarketPrice('BTCUSDT', true);
            if (priceInfo) {
                addLog(`üí∞ BTC Price: $${formatPriceWithPrecision(priceInfo.price)} (${priceInfo.source})`, 'success');
            } else {
                addLog(`‚ùå Price check: No price data`, 'error');
            }
        } catch (e) {
            addLog(`‚ùå Price check: ${e.message}`, 'error');
        }
        
        try {
            const scalpSignal = await makeRequest('/api/scalp-signal', {
                symbol: 'BTCUSDT',
                timeframe: '5m'
            });
            
            addLog(`‚ö° Scalp test: ${scalpSignal.signal} - ${(scalpSignal.confidence * 100).toFixed(0)}% (RSI: ${scalpSignal.rsi})`, 'success');
            
        } catch (e) {
            addLog(`‚ö†Ô∏è Scalp test: ${e.message}`, 'warning');
        }
        
        try {
            const analysis = await makeRequest('/api/analyze', {
                symbol: 'BTCUSDT',
                timeframe: '5m'
            });
            
            addLog(`üìä Analysis test: ${analysis.signal} - ${(analysis.confidence * 100).toFixed(0)}%`, 'success');
            
        } catch (e) {
            addLog(`‚ö†Ô∏è Analysis test: ${e.message}`, 'warning');
        }
        
    } catch (error) {
        addLog(`‚ùå Connection test failed: ${error.message}`, 'error');
        updateApiStatus('offline');
    }
}

function switchMarket(market) {
    currentMarket = market;
    document.getElementById('cryptoBtn').classList.toggle('active', market === 'crypto');
    document.getElementById('forexBtn').classList.toggle('active', market === 'forex');
    
    const placeholder = market === 'crypto' 
        ? 'Search Crypto (BTC, ETH, SOL...)' 
        : 'Search Forex/Gold (EURUSD, XAUUSD, PAXG...)';
    
    document.getElementById('symbolSearch').placeholder = placeholder;
    addLog(`üåê Switched to ${market.toUpperCase()} market`, 'info');
    
    const currentSymbol = document.getElementById('symbol').value;
    if (market === 'forex' && !isForexGoldSymbol(currentSymbol)) {
        selectSymbol('EURUSD');
    } else if (market === 'crypto' && isForexGoldSymbol(currentSymbol)) {
        selectSymbol('BTCUSDT');
    }
}

function toggleTimeframe(tf) {
    const btn = document.getElementById(`tf${tf.replace('m', '').replace('h', '')}`);
    const index = activeTimeframes.indexOf(tf);
    
    if (index > -1) {
        if (activeTimeframes.length > 1) {
            activeTimeframes.splice(index, 1);
            btn.classList.remove('active');
            addLog(`‚ùå Disabled ${tf} timeframe`, 'warning');
        } else {
            addLog('‚ö†Ô∏è At least one timeframe must be active', 'error');
            return;
        }
    } else {
        activeTimeframes.push(tf);
        btn.classList.add('active');
        addLog(`‚úÖ Enabled ${tf} timeframe`, 'success');
    }
    
    document.getElementById('activeTFs').textContent = activeTimeframes.length;
}

// ========== UTILITY FUNCTIONS ==========
function addLog(message, type = 'info') {
    const debug = document.getElementById('debug');
    const time = new Date().toLocaleTimeString();
    const icon = type === 'success' ? '‚úÖ' : 
                 type === 'error' ? '‚ùå' : 
                 type === 'warning' ? '‚ö†Ô∏è' : 
                 type === 'scalp' ? '‚ö°' : '‚ÑπÔ∏è';
    
    const line = `<div class="debug-line ${type}">${icon} [${time}] ${message}</div>`;
    
    debug.insertAdjacentHTML('afterbegin', line);
    
    if (debug.children.length > 25) {
        debug.removeChild(debug.lastChild);
    }
    
    console.log(`[${type.toUpperCase()}] ${message}`);
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// ========== INITIALIZATION ==========
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ AI Smart Money Scanner v2.1 loaded');
    console.log('‚ö° Scalp scanning enabled');
    console.log('üìä Swing analysis enabled');
    
    document.getElementById('apiUrlDisplay').textContent = CONFIG.API_URL.replace('https://', '');
    document.getElementById('apiUrlFooter').textContent = CONFIG.API_URL.replace('https://', '');
    
    loadAllSymbols();
    setupEventListeners();
    
    addLog('üöÄ AI Smart Money Scanner v2.1 Initialized', 'success');
    addLog(`üîó API: ${CONFIG.API_URL}`, 'info');
    addLog('‚ö° Scalp Signals (1m/5m/15m) Enabled', 'scalp');
    addLog('üìä Swing Analysis (1h/4h) Enabled', 'info');
    
    // Get initial price
    getCurrentMarketPrice('BTCUSDT', true).then(priceInfo => {
        if (priceInfo) {
            const formattedPrice = formatPriceWithPrecision(priceInfo.price);
            
            if (priceInfo.isReal) {
                document.getElementById('price').innerHTML = `$${formattedPrice} <span style="color:#00ff88; font-size:12px">‚úÖ</span>`;
                document.getElementById('priceSource').textContent = `Source: ${priceInfo.source}`;
                document.getElementById('priceSource').style.color = '#00ff88';
                addLog(`üí∞ Current BTC: $${formattedPrice} (Live)`, 'success');
            } else {
                document.getElementById('price').textContent = '$' + formattedPrice;
                document.getElementById('priceSource').textContent = `Source: ${priceInfo.source} (Reference)`;
                document.getElementById('priceSource').style.color = '#ff9900';
                addLog(`üí∞ Current BTC: $${formattedPrice} (Reference)`, 'warning');
            }
        } else {
            document.getElementById('price').textContent = '--';
            document.getElementById('priceSource').textContent = 'Source: Failed to fetch';
            document.getElementById('priceSource').style.color = '#ff4444';
            addLog(`‚ùå Failed to get initial BTC price`, 'error');
        }
    });
    
    // Auto test after 3 seconds
    setTimeout(() => {
        testConnection();
    }, 3000);
    
    // Clean up WebSockets on page unload
    window.addEventListener('beforeunload', function() {
        Object.values(priceWebSockets).forEach(ws => {
            try {
                ws.close();
            } catch (e) {}
        });
    });
});
</script>
</body>
</html>