# Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ÛŒØ§ÙØªÙ‡ Ø¨Ø±Ø§ÛŒ main.py from pydantic import BaseModel, validator from slowapi import Limiter from slowapi.util import get_remote_address import os from dotenv import load_dotenv load_dotenv() # ============================================================================== # Configuration Ø¨Ø§ Environment Variables # ============================================================================== class Config: API_VERSION = os.getenv("API_VERSION", "7.2.1") PORT = int(os.getenv("PORT", 8000)) ALLOWED_ORIGINS = os.getenv("ALLOWED_ORIGINS", "http://localhost:3000").split(",") RATE_LIMIT = os.getenv("RATE_LIMIT", "10/minute") LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO") # ============================================================================== # Pydantic Models Ø¨Ø§ Validation # ============================================================================== class AnalysisRequest(BaseModel): symbol: str timeframe: str = "5m" @validator('symbol') def validate_symbol(cls, v): if not v or len(v) < 3: raise ValueError('Symbol must be at least 3 characters') # ÙÙ‚Ø· Ø­Ø±ÙˆÙ Ùˆ Ø§Ø¹Ø¯Ø§Ø¯ Ù…Ø¬Ø§Ø² if not v.replace('USDT', '').replace('BUSD', '').isalnum(): raise ValueError('Invalid symbol format') return v.upper() @validator('timeframe') def validate_timeframe(cls, v): allowed = ['1m', '5m', '15m', '1h', '4h', '1d'] if v not in allowed: raise ValueError(f'Timeframe must be one of {allowed}') return v class ScalpRequest(BaseModel): symbol: str timeframe: str = "5m" @validator('symbol') def validate_symbol(cls, v): if not v or len(v) < 3: raise ValueError('Symbol must be at least 3 characters') return v.upper() @validator('timeframe') def validate_timeframe(cls, v): allowed = ['1m', '5m', '15m'] if v not in allowed: raise ValueError(f'Scalp timeframe must be one of {allowed}') return v # ============================================================================== # FastAPI Ø¨Ø§ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ù…Ù†ÛŒØªÛŒ # ============================================================================== app = FastAPI( title=f"Crypto AI Trading System v{Config.API_VERSION}", description="Multi-source signal API with Scalp Support", version=Config.API_VERSION, docs_url="/api/docs", redoc_url="/api/redoc" ) # CORS Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª app.add_middleware( CORSMiddleware, allow_origins=Config.ALLOWED_ORIGINS, allow_credentials=True, allow_methods=["GET", "POST"], allow_headers=["*"], ) # Rate Limiting limiter = Limiter(key_func=get_remote_address) app.state.limiter = limiter # ============================================================================== # ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ÛŒØ§ÙØªÙ‡ # ============================================================================== def mock_calculate_simple_rsi(data, period=14): """Ù…Ø­Ø§Ø³Ø¨Ù‡ RSI Ø³Ø§Ø¯Ù‡ Ø¨Ø§ Ø±ÙØ¹ Ù…Ø´Ú©Ù„ division by zero""" if not data or len(data) <= period: return 50 closes = [] for candle in data[-(period+1):]: try: closes.append(float(candle[4])) except: closes.append(0) gains = 0 losses = 0 for i in range(1, len(closes)): change = closes[i] - closes[i-1] if change > 0: gains += change else: losses += abs(change) avg_gain = gains / period # Ø±ÙØ¹ Ù…Ø´Ú©Ù„ division by zero avg_loss = losses / period if losses > 0 else 0.0001 rs = avg_gain / avg_loss rsi = 100 - (100 / (1 + rs)) return round(rsi, 2) def calculate_targets_and_stop(signal: str, entry_price: float, trade_type: str = "STANDARD"): """ Ù…Ø­Ø§Ø³Ø¨Ù‡ ØµØ­ÛŒØ­ ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ Ùˆ Ø§Ø³ØªØ§Ù¾ Ù„Ø§Ø³ Args: signal: "BUY" or "SELL" entry_price: Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯ trade_type: "STANDARD" or "SCALP" Returns: dict Ø¨Ø§ targets Ùˆ stop_loss """ if entry_price <= 0: raise ValueError("Entry price must be positive") if trade_type == "SCALP": # Ø§Ø³Ú©Ø§Ù„Ù¾: ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ÛŒ Ú©ÙˆÚ†Ú©â€ŒØªØ± if signal == "BUY": return { "targets": [ round(entry_price * 1.01, 2), # +1% round(entry_price * 1.02, 2), # +2% round(entry_price * 1.03, 2) # +3% ], "stop_loss": round(entry_price * 0.99, 2) # -1% } elif signal == "SELL": return { "targets": [ round(entry_price * 0.99, 2), # -1% round(entry_price * 0.98, 2), # -2% round(entry_price * 0.97, 2) # -3% ], "stop_loss": round(entry_price * 1.01, 2) # +1% } else: # STANDARD: ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯â€ŒØªØ± if signal == "BUY": return { "targets": [ round(entry_price * 1.02, 2), # +2% round(entry_price * 1.05, 2) # +5% ], "stop_loss": round(entry_price * 0.98, 2) # -2% } elif signal == "SELL": return { "targets": [ round(entry_price * 0.98, 2), # -2% round(entry_price * 0.95, 2) # -5% ], "stop_loss": round(entry_price * 1.02, 2) # +2% } # HOLD return { "targets": [], "stop_loss": entry_price } # ============================================================================== # Endpoints Ø¨Ù‡Ø¨ÙˆØ¯ÛŒØ§ÙØªÙ‡ # ============================================================================== @app.post("/api/analyze") @limiter.limit(Config.RATE_LIMIT) async def analyze_crypto(request: AnalysisRequest): """ØªØ­Ù„ÛŒÙ„ ÛŒÚ© Ù†Ù…Ø§Ø¯ Ø¨Ø§ Rate Limiting Ùˆ Error Handling Ø¨Ù‡ØªØ±""" logger.info(f"ğŸ“ˆ Analysis request: {request.symbol} ({request.timeframe})") try: # Validate symbol exists (optional: check against exchange) if not request.symbol: raise HTTPException(status_code=400, detail="Symbol is required") # Ø§Ù†Ø¬Ø§Ù… ØªØ­Ù„ÛŒÙ„ analysis = analyze_func(request.symbol) # Ù…Ø­Ø§Ø³Ø¨Ù‡ ØµØ­ÛŒØ­ ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ targets_data = calculate_targets_and_stop( signal=analysis["signal"], entry_price=analysis["entry_price"], trade_type="STANDARD" ) analysis.update(targets_data) analysis["requested_timeframe"] = request.timeframe analysis["analysis_type"] = "STANDARD" analysis["version"] = Config.API_VERSION analysis["timestamp"] = datetime.now().isoformat() return analysis except ValueError as e: logger.warning(f"Validation error: {e}") raise HTTPException(status_code=400, detail=str(e)) except Exception as e: logger.error(f"âŒ Analysis error for {request.symbol}: {e}", exc_info=True) raise HTTPException( status_code=500, detail="Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø±Ø®ÙˆØ§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯." ) @app.post("/api/scalp-signal") @limiter.limit(Config.RATE_LIMIT) async def get_scalp_signal(request: ScalpRequest): """Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø§Ø³Ú©Ø§Ù„Ù¾ Ø¨Ø§ Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ø¯Ù‚ÛŒÙ‚""" logger.info(f"âš¡ Scalp request: {request.symbol} ({request.timeframe})") try: # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ Ø¨Ø§Ø²Ø§Ø± market_data = get_market_data_func(request.symbol, request.timeframe, 50) if not market_data: raise HTTPException( status_code=404, detail=f"No market data available for {request.symbol}" ) # ØªØ­Ù„ÛŒÙ„ Ø§Ø³Ú©Ø§Ù„Ù¾ scalp_analysis = analyze_scalp_signal(request.symbol, request.timeframe, market_data) # Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ current_price = scalp_analysis.get("current_price", 0) if current_price <= 0: raise ValueError("Invalid current price") # Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ Ø¨Ø§ ØªØ§Ø¨Ø¹ Ù…Ø³ØªÙ‚Ù„ targets_data = calculate_targets_and_stop( signal=scalp_analysis["signal"], entry_price=current_price, trade_type="SCALP" ) response = { "symbol": request.symbol, "timeframe": request.timeframe, "signal": scalp_analysis["signal"], "confidence": scalp_analysis["confidence"], "entry_price": current_price, "rsi": scalp_analysis["rsi"], "sma_20": scalp_analysis["sma_20"], **targets_data, # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† targets Ùˆ stop_loss "type": "SCALP", "reason": scalp_analysis["reason"], "strategy": f"Scalp Strategy ({request.timeframe})", "version": Config.API_VERSION, "timestamp": datetime.now().isoformat(), "risk_level": "HIGH" if request.timeframe == "1m" else "MEDIUM" } logger.info(f"âœ… Scalp signal: {request.symbol} - {scalp_analysis['signal']}") return response except HTTPException: raise except ValueError as e: logger.warning(f"Validation error: {e}") raise HTTPException(status_code=400, detail=str(e)) except Exception as e: logger.error(f"âŒ Scalp signal error: {e}", exc_info=True) raise HTTPException( status_code=500, detail="Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø§Ø³Ú©Ø§Ù„Ù¾" ) # ============================================================================== # Health Check Ø¨Ø§ Ø¬Ø²Ø¦ÛŒØ§Øª Ø¨ÛŒØ´ØªØ± # ============================================================================== @app.get("/api/health") async def health_check(): """Ø¨Ø±Ø±Ø³ÛŒ Ø³Ù„Ø§Ù…Øª Ø³ÛŒØ³ØªÙ… Ø¨Ø§ Ø¬Ø²Ø¦ÛŒØ§Øª""" import psutil return { "status": "healthy", "timestamp": datetime.now().isoformat(), "version": Config.API_VERSION, "modules": { "utils": UTILS_AVAILABLE, "data_collector": DATA_COLLECTOR_AVAILABLE, "collectors": COLLECTORS_AVAILABLE }, "system": { "cpu_percent": psutil.cpu_percent(), "memory_percent": psutil.virtual_memory().percent, "disk_percent": psutil.disk_usage('/').percent }, "features": { "rate_limiting": True, "cors_enabled": True, "validation": True } }