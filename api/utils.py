

Ø¨Ù„Ù‡ØŒ ÙØ§ÛŒÙ„ `utils.py` Ø´Ù…Ø§ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø±Ø¯Ù…. Ø§ÛŒÙ† ÙØ§ÛŒÙ„ ØªÙˆØ§Ø¨Ø¹ Ù¾Ø§ÛŒÙ‡ RSI Ùˆ SMA Ø±Ø§ Ø¯Ø§Ø±Ø¯ØŒ Ø§Ù…Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ **ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ (Divergence)** Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ **Ø³Ø±ÛŒ Ú©Ø§Ù…Ù„ Ù…Ù‚Ø§Ø¯ÛŒØ± RSI** (Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ù†Ù‚Ø§Ø· Ú¯Ø°Ø´ØªÙ‡) Ø±Ø§ Ù†Ø¯Ø§Ø±Ø¯.

Ù…Ù† Ú©Ø¯ Ø²ÛŒØ± Ø±Ø§ Ø¨Ø§ Ø§Ø¯ØºØ§Ù… Ú©Ø±Ø¯Ù† Ù…Ù†Ø·Ù‚ ÙˆØ§Ù‚Ø¹ÛŒ RSI Ùˆ ØªØ´Ø®ÛŒØµ ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ (Ú©Ù‡ Ø¯Ø± Ù…Ø±Ø­Ù„Ù‡ Ù‚Ø¨Ù„ Ø¨Ø±Ø§ÛŒ `main.py` Ù†ÙˆØ´ØªÙ…) Ø¯Ø± ÙØ§ÛŒÙ„ `utils.py` Ø¨Ø§Ø²Ù†ÙˆÛŒØ³ÛŒ Ú©Ø±Ø¯Ù….

**ØªØºÛŒÛŒØ±Ø§Øª Ù…Ù‡Ù… Ø¯Ø± Ø§ÛŒÙ† Ù†Ø³Ø®Ù‡:**
1.  Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯ `calculate_rsi_series`: Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ù„ÛŒØ³Øª Ú©Ø§Ù…Ù„ RSIâ€ŒÙ‡Ø§ Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
2.  Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯ `detect_divergence`: Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ù¾ÛŒÚ©â€ŒÙ‡Ø§ Ùˆ Ø¯Ø±Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø±Ø¯Ù‡ Ùˆ ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ ØµØ¹ÙˆØ¯ÛŒ/Ù†Ø²ÙˆÙ„ÛŒ Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
3.  Ø§ØµÙ„Ø§Ø­ Ø´Ø¯ `calculate_simple_rsi`: Ø§Ú©Ù†ÙˆÙ† Ø§Ø² Ù…Ù†Ø·Ù‚ Ø³Ø±ÛŒ RSI (Series) Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ú©Ù‡ Ø¯Ù‚ÛŒÙ‚â€ŒØªØ± Ø§Ø³Øª.
4.  Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ `__all__`: ØªÙˆØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ Ù„ÛŒØ³Øª ØµØ§Ø¯Ø±Ø§Øª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù†Ø¯ ØªØ§ `main.py` Ø¨ØªÙˆØ§Ù†Ø¯ Ø¢Ù†â€ŒÙ‡Ø§ Ø±Ø§ ØµØ¯Ø§ Ø¨Ø²Ù†Ø¯.

Ø§ÛŒÙ† ÙØ§ÛŒÙ„ Ú©Ø§Ù…Ù„ `utils.py` Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡ Ø§Ø³Øª:

```python
# api/utils.py - Ù†Ø³Ø®Ù‡ 7.5.0 Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ Ù¾ÛŒØ´Ø±ÙØªÙ‡ØŒ RSI ÙˆØ§Ù‚Ø¹ÛŒ Ùˆ ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ
"""
Utility Functions - Render Optimized Version
Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ú©Ø§Ù…Ù„ Ø§Ø² ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„ Ø¨Ø±Ø§ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ Ùˆ Ø³ÙˆØ¦ÛŒÙ†Ú¯
Ù†Ø³Ø®Ù‡ Ú©Ø§Ù…Ù„ Ø¨Ø§ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ Ù¾ÛŒØ´Ø±ÙØªÙ‡ØŒ Ø®Ø·ÙˆØ· Ú©ÛŒÙÛŒØª Ùˆ Ø·Ù„Ø§ÛŒÛŒ
+ ØªØ´Ø®ÛŒØµ ÙˆØ§Ù‚Ø¹ÛŒ ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ (Divergence) Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø±ÛŒ RSI
"""

import requests
import logging
import random
from datetime import datetime, timedelta
import time
import json

logger = logging.getLogger(__name__)

# ==============================================================================
# ğŸ“Š ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ (Ø³Ø§Ø¯Ù‡â€ŒØ´Ø¯Ù‡) - Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø²Ú¯Ø§Ø±ÛŒ
# ==============================================================================

def get_market_data_with_fallback(symbol, interval="5m", limit=100, return_source=False):
    """
    Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± - Ù†Ø³Ø®Ù‡ Ø³Ø§Ø²Ú¯Ø§Ø±
    
    Parameters:
    -----------
    symbol : str
        Ù†Ù…Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ
    interval : str
        ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…
    limit : int
        ØªØ¹Ø¯Ø§Ø¯ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
    return_source : bool
        Ø§Ú¯Ø± True Ø¨Ø§Ø´Ø¯ØŒ Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¨Ø§ Ø¯Ø§Ø¯Ù‡ Ùˆ source Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯
    
    Returns:
    --------
    list or dict
        Ù„ÛŒØ³Øª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ ÛŒØ§ Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¨Ø§ Ø¯Ø§Ø¯Ù‡ Ùˆ source
    """
    logger.info(f"ğŸ“Š Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ {symbol} ({interval})")
    
    source = None
    data = None
    
    # Û±. ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø§Ø² Binance
    try:
        data = get_binance_klines_simple(symbol, interval, limit)
        if data:
            logger.info(f"âœ… Ø¯Ø§Ø¯Ù‡ Ø§Ø² Binance Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯: {len(data)} Ú©Ù†Ø¯Ù„")
            source = "binance"
    except Exception as e:
        logger.warning(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Binance: {e}")
    
    # Û². Ø§Ú¯Ø± Binance Ø¬ÙˆØ§Ø¨ Ù†Ø¯Ø§Ø¯ØŒ ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø§Ø² LBank
    if not data:
        try:
            data = get_lbank_data_simple(symbol, interval, limit)
            if data:
                logger.info(f"âœ… Ø¯Ø§Ø¯Ù‡ Ø§Ø² LBank Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯: {len(data)} Ú©Ù†Ø¯Ù„")
                source = "lbank"
        except Exception as e:
            logger.warning(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± LBank: {e}")
    
    # Û³. Ø§Ú¯Ø± Ù‡ÛŒÚ† Ú©Ø¯Ø§Ù… Ø¬ÙˆØ§Ø¨ Ù†Ø¯Ø§Ø¯ØŒ Ø¯Ø§Ø¯Ù‡ Mock
    if not data:
        logger.info(f"ğŸ§ª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡ Mock Ø¨Ø±Ø§ÛŒ {symbol}")
        data = generate_mock_data_simple(symbol, limit)
        source = "mock"
    
    # Ø¨Ø± Ø§Ø³Ø§Ø³ Ù¾Ø§Ø±Ø§Ù…ØªØ± return_source ØªØµÙ…ÛŒÙ… Ø¨Ú¯ÛŒØ±ÛŒÙ… Ú†Ù‡ Ú†ÛŒØ²ÛŒ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†ÛŒÙ…
    if return_source:
        return {
            "data": data,
            "source": source,
            "success": source != "mock"
        }
    else:
        return data

# ==============================================================================
# ğŸ“Š ØªÙˆØ§Ø¨Ø¹ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ Ø§Ø² ØµØ±Ø§ÙÛŒâ€ŒÙ‡Ø§ (Ø¨Ø¯ÙˆÙ† pandas)
# ==============================================================================

def get_binance_klines_simple(symbol, interval="5m", limit=100):
    """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ Ø§Ø² Binance Ø¨Ø¯ÙˆÙ† pandas"""
    try:
        url = "https://api.binance.com/api/v3/klines"
        params = {
            'symbol': symbol.upper(),
            'interval': interval,
            'limit': min(limit, 1000)
        }
        
        response = requests.get(url, params=params, timeout=10)
        
        if response.status_code == 200:
            return response.json()  # Ù„ÛŒØ³Øª Ø®Ø§Ù… Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
        logger.error(f"Binance API error: {response.status_code}")
    except Exception as e:
        logger.error(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Binance: {e}")
    return None

def get_lbank_data_simple(symbol, interval="5m", limit=100):
    """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ Ø§Ø² LBank Ø¨Ø¯ÙˆÙ† pandas"""
    try:
        # ØªØ¨Ø¯ÛŒÙ„ interval
        interval_map = {
            '1m': '1min', '5m': '5min', '15m': '15min',
            '30m': '30min', '1h': '1hour', '4h': '4hour',
            '1d': '1day', '1w': '1week'
        }
        lbank_interval = interval_map.get(interval, '5min')
        
        # ØªØ¨Ø¯ÛŒÙ„ symbol (ÙØ±Ø¶ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… format: btc_usdt)
        lbank_symbol = symbol.lower().replace("usdt", "_usdt")
        
        url = "https://api.lbkex.com/v2/klines.do"
        params = {
            'symbol': lbank_symbol,
            'type': lbank_interval,
            'size': limit
        }
        
        response = requests.get(url, params=params, timeout=10)
        
        if response.status_code == 200:
            return response.json()
        logger.error(f"LBank API error: {response.status_code}")
    except Exception as e:
        logger.error(f"âŒ Ø®Ø·Ø§ Ø¯Ø± LBank: {e}")
    return None

# ==============================================================================
# ğŸ“Š ØªÙˆØ§Ø¨Ø¹ Mock (Ø¨Ø¯ÙˆÙ† pandas/numpy)
# ==============================================================================

def generate_mock_data_simple(symbol, limit=100):
    """ØªÙˆÙ„ÛŒØ¯ Ø¯Ø§Ø¯Ù‡ Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ Ø¨Ø¯ÙˆÙ† pandas/numpy"""
    base_prices = {
        'BTCUSDT': 88271.42, 'ETHUSDT': 3450.12, 'BNBUSDT': 590.54,
        'SOLUSDT': 175.98, 'XRPUSDT': 0.51234, 'ADAUSDT': 0.43210,
        'DOGEUSDT': 0.12345, 'SHIBUSDT': 0.00002345,
        'EURUSD': 1.08745, 'XAUUSD': 2387.65, 'PAXGUSDT': 2387.65,
        'DEFAULT': 100.50
    }
    
    base_price = base_prices.get(symbol.upper(), base_prices['DEFAULT'])
    mock_data = []
    current_time = int(time.time() * 1000)
    
    for i in range(limit):
        timestamp = current_time - (i * 5 * 60 * 1000)  # 5 Ø¯Ù‚ÛŒÙ‚Ù‡ ÙØ§ØµÙ„Ù‡
        
        # Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ø±Ú©Øª Ù‚ÛŒÙ…Øª ÙˆØ§Ù‚Ø¹ÛŒâ€ŒØªØ±
        change = random.uniform(-0.015, 0.015)  # Â±1.5%
        price = base_price * (1 + change)
        
        mock_candle = [
            timestamp,  # open time
            str(price * random.uniform(0.998, 1.000)),  # open
            str(price * random.uniform(1.000, 1.003)),  # high
            str(price * random.uniform(0.997, 1.000)),  # low
            str(price),  # close
            str(random.uniform(1000, 10000)),  # volume
            timestamp + 300000,  # close time
            "0", "0", "0", "0", "0"  # Ø³Ø§ÛŒØ± ÙÛŒÙ„Ø¯Ù‡Ø§
        ]
        
        mock_data.append(mock_candle)
    
    return mock_data

# ==============================================================================
# ğŸ“ˆ ØªØ§Ø¨Ø¹ Ù…Ø­Ø§Ø³Ø¨Ù‡ RSI Series (ÙˆØ§Ù‚Ø¹ÛŒ) - Ø¬Ø¯ÛŒØ¯
# ==============================================================================

def calculate_rsi_series(closes, period=14):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù„ÛŒØ³Øª Ú©Ø§Ù…Ù„ Ù…Ù‚Ø§Ø¯ÛŒØ± RSI Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±ÙˆØ´ Wilder's Smoothing.
    ÙˆØ±ÙˆØ¯ÛŒ: Ù„ÛŒØ³Øª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡ (Closes).
    Ø®Ø±ÙˆØ¬ÛŒ: Ù„ÛŒØ³Øª Ù…Ù‚Ø§Ø¯ÛŒØ± RSI.
    """
    if len(closes) < period + 1:
        return [50] * len(closes)
    
    rsi_values = [50] * period  # Ù¾Ø± Ú©Ø±Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒ
    
    gains = 0.0
    losses = 0.0
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø§ÙˆÙ„ÛŒÙ‡
    for i in range(1, period + 1):
        change = closes[i] - closes[i - 1]
        if change > 0:
            gains += change
        else:
            losses += abs(change)
    
    avg_gain = gains / period
    avg_loss = losses / period
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§ÙˆÙ„ÛŒÙ† RSI
    if avg_loss == 0:
        rsi_values.append(100)
    else:
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        rsi_values.append(rsi)
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ RSI Ø¨Ø±Ø§ÛŒ Ø¨Ù‚ÛŒÙ‡ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø¨Ø§ Ø±ÙˆØ´ Smoothing
    for i in range(period + 1, len(closes)):
        change = closes[i] - closes[i - 1]
        
        if change > 0:
            gain = change
            loss = 0
        else:
            gain = 0
            loss = abs(change)
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†â€ŒÙ‡Ø§ÛŒ Ù‡Ù…ÙˆØ§Ø± Ø´Ø¯Ù‡
        avg_gain = (avg_gain * (period - 1) + gain) / period
        avg_loss = (avg_loss * (period - 1) + loss) / period
        
        if avg_loss == 0:
            rsi_val = 100
        else:
            rs = avg_gain / avg_loss
            rsi_val = 100 - (100 / (1 + rs))
        
        rsi_values.append(rsi_val)
    
    return rsi_values

def detect_divergence(prices, rsi_values, lookback=5):
    """
    ØªØ´Ø®ÛŒØµ ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ ØµØ¹ÙˆØ¯ÛŒ Ùˆ Ù†Ø²ÙˆÙ„ÛŒ Ø¨Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ù¾ÛŒÚ©â€ŒÙ‡Ø§ Ùˆ Ø¯Ø±Ù‡â€ŒÙ‡Ø§.
    ÙˆØ±ÙˆØ¯ÛŒ: Ù„ÛŒØ³Øª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ØŒ Ù„ÛŒØ³Øª Ù…Ù‚Ø§Ø¯ÛŒØ± RSIØŒ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ (Lookback).
    Ø®Ø±ÙˆØ¬ÛŒ: Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø´Ø§Ù…Ù„ ÙˆØ¶Ø¹ÛŒØª ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ.
    """
    divergence = {
        "detected": False,
        "type": None,  # "bullish" (ØµØ¹ÙˆØ¯ÛŒ), "bearish" (Ù†Ø²ÙˆÙ„ÛŒ)
        "strength": None # "weak", "moderate", "strong"
    }
    
    if len(prices) < lookback * 3 or len(rsi_values) < lookback * 3:
        return divergence
    
    # ØªØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ù‚Ù„Ù‡â€ŒÙ‡Ø§ Ùˆ Ø¯Ø±Ù‡â€ŒÙ‡Ø§ (Local Extrema)
    def find_pivots(data, window=3):
        pivots = []
        for i in range(window, len(data) - window):
            is_peak = True
            is_trough = True
            
            for j in range(1, window + 1):
                if data[i] <= data[i - j] or data[i] <= data[i + j]:
                    is_peak = False
                if data[i] >= data[i - j] or data[i] >= data[i + j]:
                    is_trough = False
            
            if is_peak:
                pivots.append({"index": i, "value": data[i], "type": "peak"})
            elif is_trough:
                pivots.append({"index": i, "value": data[i], "type": "trough"})
        return pivots

    price_pivots = find_pivots(prices, window=lookback)
    rsi_pivots = find_pivots(rsi_values, window=lookback)
    
    if len(price_pivots) < 2 or len(rsi_pivots) < 2:
        return divergence

    # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¢Ø®Ø±ÛŒÙ† Ù¾ÛŒÚ© ÛŒØ§ Ø¯Ø±Ù‡ Ù…Ø´ØªØ±Ú©
    # Ù…Ø§ Ø¢Ø®Ø±ÛŒÙ† Ù¾ÛŒÙˆØª Ù…Ø´Ø§Ø¨Ù‡ Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… Ùˆ Ø¨Ø§ Ù¾ÛŒÙˆØª Ù‚Ø¨Ù„ Ø§Ø² Ø¢Ù† Ù…Ù‚Ø§ÛŒØ³Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
    
    # 1. Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø¢Ø®Ø±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø¹Ø·Ù Ù…Ø´ØªØ±Ú© (Peak ÛŒØ§ Trough)
    last_price_pivot = price_pivots[-1]
    last_rsi_pivot = rsi_pivots[-1]
    
    # Ø§Ú¯Ø± Ù†ÙˆØ¹ Ø¢Ø®Ø±ÛŒÙ† Ù¾ÛŒÙˆØª Ø¨Ø±Ø§Ø¨Ø± Ù†ÛŒØ³Øª (Ù…Ø«Ù„Ø§Ù‹ Ù‚ÛŒÙ…Øª Ù¾ÛŒÚ© Ø§Ø³Øª ÙˆÙ„ÛŒ RSI Ø¯Ø±Ù‡)ØŒ Ù…Ù‚Ø§ÛŒØ³Ù‡ Ù…Ø¹Ù†Ø§Ø¯Ø§Ø±ÛŒ Ù†Ø¯Ø§Ø±Ø¯
    if last_price_pivot['type'] != last_rsi_pivot['type']:
        return divergence

    # Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ù¾ÛŒÙˆØª Ù‚Ø¨Ù„ Ø§Ø² Ø¢Ù†
    prev_price_pivot = None
    prev_rsi_pivot = None
    
    # Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± Ù¾ÛŒÙˆØªâ€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ù‡Ù…Ø§Ù† Ù†ÙˆØ¹ (Peak ÛŒØ§ Trough)
    for pp in reversed(price_pivots[:-1]):
        if pp['type'] == last_price_pivot['type']:
            prev_price_pivot = pp
            break
    
    for rp in reversed(rsi_pivots[:-1]):
        if rp['type'] == last_rsi_pivot['type']:
            prev_rsi_pivot = rp
            break

    if not prev_price_pivot or not prev_rsi_pivot:
        return divergence

    # 2. Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø±Ø§ÛŒØ· ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ
    # Ø§Ú¯Ø± Ù†ÙˆØ¹ Ù¾ÛŒÙˆØª 'peak' (Ù‚Ù„Ù‡) Ø¨ÙˆØ¯:
    if last_price_pivot['type'] == 'peak':
        # ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ Ù†Ø²ÙˆÙ„ÛŒ (Bearish): Ù‚ÛŒÙ…Øª Ø³Ù‚Ù Ø¬Ø¯ÛŒØ¯ Ø²Ø¯Ù‡ (Higher High) Ø§Ù…Ø§ RSI Ø³Ù‚Ù Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± (Lower High) Ø²Ø¯Ù‡
        if last_price_pivot['value'] > prev_price_pivot['value'] and last_rsi_pivot['value'] < prev_rsi_pivot['value']:
            divergence["detected"] = True
            divergence["type"] = "bearish"
            divergence["strength"] = "strong"
            
    # Ø§Ú¯Ø± Ù†ÙˆØ¹ Ù¾ÛŒÙˆØª 'trough' (Ø¯Ø±Ù‡) Ø¨ÙˆØ¯:
    elif last_price_pivot['type'] == 'trough':
        # ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ ØµØ¹ÙˆØ¯ÛŒ (Bullish): Ù‚ÛŒÙ…Øª Ú©Ù Ø¬Ø¯ÛŒØ¯ Ø²Ø¯Ù‡ (Lower Low) Ø§Ù…Ø§ RSI Ú©Ù Ø¨Ø§Ù„Ø§ØªØ± (Higher Low) Ø²Ø¯Ù‡
        if last_price_pivot['value'] < prev_price_pivot['value'] and last_rsi_pivot['value'] > prev_rsi_pivot['value']:
            divergence["detected"] = True
            divergence["type"] = "bullish"
            divergence["strength"] = "strong"

    return divergence

# ==============================================================================
# ğŸ“ˆ ØªÙˆØ§Ø¨Ø¹ ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„ Ù¾Ø§ÛŒÙ‡ (Ø³Ø§Ø¯Ù‡â€ŒØ´Ø¯Ù‡) - Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡
# ==============================================================================

def calculate_simple_sma(data, period=20):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ SMA Ø³Ø§Ø¯Ù‡ (Ø¨Ø¯ÙˆÙ† pandas)
    
    Parameters:
    -----------
    data : list
        Ù„ÛŒØ³Øª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø§Ø² API ØµØ±Ø§ÙÛŒ
    period : int
        Ø¯ÙˆØ±Ù‡ SMA (Ù¾ÛŒØ´â€ŒÙØ±Ø¶: 20)
    
    Returns:
    --------
    float or None
        Ù…Ù‚Ø¯Ø§Ø± SMA ÛŒØ§ None Ø§Ú¯Ø± Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ Ù†Ø¨Ø§Ø´Ø¯
    """
    if not data or len(data) < period:
        return None
    
    closes = []
    for candle in data[-period:]:  # Ø¢Ø®Ø±ÛŒÙ† period Ú©Ù†Ø¯Ù„
        try:
            closes.append(float(candle[4]))  # index 4 = close price
        except (IndexError, ValueError, TypeError):
            closes.append(0)
    
    return sum(closes) / len(closes) if closes else 0

def calculate_simple_rsi(data, period=14):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ RSI Ø³Ø§Ø¯Ù‡ (Ø¨Ø¯ÙˆÙ† pandas) - Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯Ù‡ Ø¨Ø§ RSI Series
    Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ø§Ú©Ù†ÙˆÙ† Ù‡Ù…Ø§Ù† Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ Ø³Ø±ÛŒ RSI Ø±Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
    
    Parameters:
    -----------
    data : list
        Ù„ÛŒØ³Øª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø§Ø² API ØµØ±Ø§ÙÛŒ
    period : int
        Ø¯ÙˆØ±Ù‡ RSI (Ù¾ÛŒØ´â€ŒÙØ±Ø¶: 14)
    
    Returns:
    --------
    float
        Ù…Ù‚Ø¯Ø§Ø± RSI Ø¨ÛŒÙ† 0 ØªØ§ 100
    """
    if not data or len(data) <= period:
        return 50  # Ù…Ù‚Ø¯Ø§Ø± Ø®Ù†Ø«ÛŒ
    
    # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡
    closes = []
    for candle in data[-(period+1):]:  # Ø¨Ø±Ø§ÛŒ period+1 Ú©Ù†Ø¯Ù„
        try:
            closes.append(float(candle[4]))
        except (IndexError, ValueError, TypeError):
            closes.append(0)
    
    # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ§Ø¨Ø¹ Ø³Ø±ÛŒ RSI Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ù‚ÛŒÙ‚
    rsi_series = calculate_rsi_series(closes, period)
    
    # Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ø¢Ø®Ø±ÛŒÙ† Ù…Ù‚Ø¯Ø§Ø±
    return round(rsi_series[-1], 2)

def calculate_macd_simple(data, fast=12, slow=26, signal=9):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ MACD Ø³Ø§Ø¯Ù‡ (Ø¨Ø¯ÙˆÙ† pandas) - Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡
    
    Parameters:
    -----------
    data : list
        Ù„ÛŒØ³Øª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
    fast : int
        Ø¯ÙˆØ±Ù‡ EMA Ø³Ø±ÛŒØ¹
    slow : int
        Ø¯ÙˆØ±Ù‡ EMA Ú©Ù†Ø¯
    signal : int
        Ø¯ÙˆØ±Ù‡ Ø®Ø· Ø³ÛŒÚ¯Ù†Ø§Ù„
    
    Returns:
    --------
    dict
        {'macd': Ù…Ù‚Ø¯Ø§Ø± MACD, 'signal': Ø®Ø· Ø³ÛŒÚ¯Ù†Ø§Ù„, 'histogram': Ù‡ÛŒØ³ØªÙˆÚ¯Ø±Ø§Ù…}
    """
    if not data or len(data) < slow + signal:
        return {'macd': 0, 'signal': 0, 'histogram': 0}
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA Ø³Ø±ÛŒØ¹ Ùˆ Ú©Ù†Ø¯
    closes = []
    for candle in data[-(slow + signal):]:
        try:
            closes.append(float(candle[4]))
        except (IndexError, ValueError, TypeError):
            continue
    
    if len(closes) < slow:
        return {'macd': 0, 'signal': 0, 'histogram': 0}
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA ÙˆØ§Ù‚Ø¹ÛŒ
    def calculate_ema(prices, period):
        if not prices or len(prices) < period:
            return 0
        multiplier = 2 / (period + 1)
        ema = sum(prices[:period]) / period  # SMA Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹
        for price in prices[period:]:
            ema = (price - ema) * multiplier + ema
        return ema
    
    ema_fast = calculate_ema(closes[-fast:], fast)
    ema_slow = calculate_ema(closes, slow)
    
    macd_line = ema_fast - ema_slow
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø®Ø· Ø³ÛŒÚ¯Ù†Ø§Ù„ (EMA Ø§Ø² MACD)
    # Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø¯Ú¯ÛŒØŒ Ø§Ø² ÛŒÚ© ØªÙ‚Ø±ÛŒØ¨ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
    macd_values = [macd_line]  # Ø¯Ø± ÙˆØ§Ù‚Ø¹ Ø¨Ø§ÛŒØ¯ history Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒÙ…
    signal_line = macd_line * 0.9  # ØªÙ‚Ø±ÛŒØ¨ Ø³Ø§Ø¯Ù‡
    
    histogram = macd_line - signal_line
    
    return {
        'macd': round(macd_line, 4),
        'signal': round(signal_line, 4),
        'histogram': round(histogram, 4)
    }

# ==============================================================================
# â˜ï¸ ØªÙˆØ§Ø¨Ø¹ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø±Ø§ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ (Ø¬Ø¯ÛŒØ¯)
# ==============================================================================

def calculate_ichimoku_components(data, tenkan_period=9, kijun_period=26, senkou_b_period=52, displacement=26):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ø¬Ø²Ø§ÛŒ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ Ú©ÛŒÙ†Ú©Ùˆ Ù‡Ø§ÛŒÙˆ
    
    Parameters:
    -----------
    data : list
        Ù„ÛŒØ³Øª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
    tenkan_period : int
        Ø¯ÙˆØ±Ù‡ ØªÙ†Ú©Ø§Ù† Ø³Ù† (Ø®Ø· ØªØ¨Ø¯ÛŒÙ„)
    kijun_period : int
        Ø¯ÙˆØ±Ù‡ Ú©ÛŒØ¬ÙˆÙ† Ø³Ù† (Ø®Ø· Ù¾Ø§ÛŒÙ‡)
    senkou_b_period : int
        Ø¯ÙˆØ±Ù‡ Ø³Ù†Ú©Ùˆ Ø§Ø³Ù¾Ù† B
    displacement : int
        Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ Ø§Ø¨Ø± (Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Û²Û¶)
    
    Returns:
    --------
    dict
        ØªÙ…Ø§Ù… Ø§Ø¬Ø²Ø§ÛŒ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
    """
    if not data or len(data) < max(kijun_period, senkou_b_period, displacement) + 10:
        return None
    
    # ØªØ¨Ø¯ÛŒÙ„ Ø¯Ø§Ø¯Ù‡ Ø¨Ù‡ ÙØ±Ù…Øª Ù‚Ø§Ø¨Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´
    highs = []
    lows = []
    closes = []
    
    for candle in data:
        try:
            highs.append(float(candle[2]))  # high
            lows.append(float(candle[3]))   # low
            closes.append(float(candle[4])) # close
        except (IndexError, ValueError, TypeError):
            continue
    
    if len(highs) < max(kijun_period, senkou_b_period) + displacement:
        return None
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªÙ†Ú©Ø§Ù† Ø³Ù† (Tenkan-sen) - Ø®Ø· ØªØ¨Ø¯ÛŒÙ„
    tenkan_sen = calculate_ichimoku_line(highs, lows, tenkan_period)
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©ÛŒØ¬ÙˆÙ† Ø³Ù† (Kijun-sen) - Ø®Ø· Ù¾Ø§ÛŒÙ‡
    kijun_sen = calculate_ichimoku_line(highs, lows, kijun_period)
    
    # Ø³Ù†Ú©Ùˆ Ø§Ø³Ù¾Ù† A (Senkou Span A) - Ù„Ø¨Ù‡ Ù¾ÛŒØ´Ø±Ùˆ A
    senkou_span_a = []
    for i in range(len(tenkan_sen)):
        if i >= displacement:
            senkou_span_a.append((tenkan_sen[i] + kijun_sen[i]) / 2)
        else:
            senkou_span_a.append(None)
    
    # Ø³Ù†Ú©Ùˆ Ø§Ø³Ù¾Ù† B (Senkou Span B) - Ù„Ø¨Ù‡ Ù¾ÛŒØ´Ø±Ùˆ B
    senkou_span_b = calculate_ichimoku_line(highs, lows, senkou_b_period)
    senkou_span_b = [None] * displacement + senkou_span_b[:-displacement] if len(senkou_span_b) > displacement else [None] * len(highs)
    
    # Ú†ÛŒÚ©Ùˆ Ø§Ø³Ù¾Ù† (Chikou Span) - Ø®Ø· ØªØ§Ø®ÛŒØ±ÛŒ
    chikou_span = closes[:-displacement] + [None] * displacement if len(closes) > displacement else [None] * len(closes)
    
    # Ø§Ø¨Ø± Ú©ÙˆÙ…Ùˆ (Kumo Cloud)
    cloud_top = []
    cloud_bottom = []
    for i in range(len(senkou_span_a)):
        if senkou_span_a[i] is not None and senkou_span_b[i] is not None:
            cloud_top.append(max(senkou_span_a[i], senkou_span_b[i]))
            cloud_bottom.append(min(senkou_span_a[i], senkou_span_b[i]))
        else:
            cloud_top.append(None)
            cloud_bottom.append(None)
    
    # Ú©ÛŒÙÛŒØª Ù„Ø§ÛŒÙ† (Quality Line) - Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ù…ÙˆØ²ÙˆÙ†
    quality_line = calculate_quality_line(closes, highs, lows, period=14)
    
    # Ø®Ø· Ø·Ù„Ø§ÛŒÛŒ (Golden Line) - ØªØ±Ú©ÛŒØ¨ Ø®Ø§Øµ
    golden_line = calculate_golden_line(tenkan_sen, kijun_sen, quality_line)
    
    # Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯ (Trend Power)
    trend_power = calculate_trend_power(tenkan_sen, kijun_sen, closes)
    
    return {
        'tenkan_sen': tenkan_sen[-1] if tenkan_sen else None,
        'kijun_sen': kijun_sen[-1] if kijun_sen else None,
        'senkou_span_a': senkou_span_a[-1] if senkou_span_a else None,
        'senkou_span_b': senkou_span_b[-1] if senkou_span_b else None,
        'chikou_span': chikou_span[-1] if chikou_span else None,
        'cloud_top': cloud_top[-1] if cloud_top else None,
        'cloud_bottom': cloud_bottom[-1] if cloud_bottom else None,
        'quality_line': quality_line[-1] if quality_line else None,
        'golden_line': golden_line[-1] if golden_line else None,
        'trend_power': trend_power,
        'in_cloud': cloud_bottom[-1] <= closes[-1] <= cloud_top[-1] if cloud_bottom[-1] and cloud_top[-1] and closes[-1] else False,
        'above_cloud': closes[-1] > cloud_top[-1] if cloud_top[-1] and closes[-1] else False,
        'below_cloud': closes[-1] < cloud_bottom[-1] if cloud_bottom[-1] and closes[-1] else False,
        'cloud_thickness': (cloud_top[-1] - cloud_bottom[-1]) / cloud_bottom[-1] * 100 if cloud_top[-1] and cloud_bottom[-1] and cloud_bottom[-1] > 0 else 0,
        'current_price': closes[-1] if closes else None
    }

def calculate_ichimoku_line(highs, lows, period):
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø®Ø· Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ (HH + LL) / 2"""
    result = []
    for i in range(len(highs)):
        if i >= period - 1:
            highest_high = max(highs[i-period+1:i+1])
            lowest_low = min(lows[i-period+1:i+1])
            result.append((highest_high + lowest_low) / 2)
        else:
            result.append(None)
    return result

def calculate_quality_line(closes, highs, lows, period=14):
    """
    Ø®Ø· Ú©ÛŒÙÛŒØª (Quality Line) - Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ± Ø§Ø®ØªØµØ§ØµÛŒ
    ØªØ±Ú©ÛŒØ¨ÛŒ Ø§Ø² Ø­Ø¬Ù…ØŒ Ù…ÙˆÙ…Ù†ØªÙˆÙ… Ùˆ Ù†ÙˆØ³Ø§Ù†
    """
    if len(closes) < period:
        return [None] * len(closes)
    
    quality = []
    for i in range(len(closes)):
        if i >= period - 1:
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ÙˆØ²Ù†ÛŒ Ø¨Ø§ ØªØ§Ú©ÛŒØ¯ Ø¨Ø± Ø­Ø±Ú©Ø§Øª Ù‚ÙˆÛŒ
            weighted_sum = 0
            weight_sum = 0
            
            for j in range(period):
                idx = i - j
                if idx <= 0:
                    continue
                    
                price_change = abs(closes[idx] - closes[idx-1])
                range_size = highs[idx] - lows[idx] if highs[idx] > lows[idx] else 0.001
                
                # ÙˆØ²Ù† Ø¨ÛŒØ´ØªØ± Ø¨Ø±Ø§ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¨Ø§ Ø±Ù†Ø¬ Ø¨Ø²Ø±Ú¯
                weight = range_size / (closes[idx] + 0.001)
                weighted_sum += closes[idx] * weight
                weight_sum += weight
            
            quality.append(weighted_sum / weight_sum if weight_sum > 0 else closes[i])
        else:
            quality.append(None)
    
    return quality

def calculate_golden_line(tenkan_sen, kijun_sen, quality_line):
    """
    Ø®Ø· Ø·Ù„Ø§ÛŒÛŒ (Golden Line) - ØªØ±Ú©ÛŒØ¨ Ù¾ÛŒØ´Ø±ÙØªÙ‡
    ÙØ±Ù…ÙˆÙ„: (ØªÙ†Ú©Ø§Ù† Ã— Û°.Û´ + Ú©ÛŒØ¬ÙˆÙ† Ã— Û°.Û³ + Ú©ÛŒÙÛŒØª Ã— Û°.Û³)
    """
    if not tenkan_sen or not kijun_sen or not quality_line:
        return None
    
    golden = []
    min_len = min(len(tenkan_sen), len(kijun_sen), len(quality_line))
    
    for i in range(min_len):
        if tenkan_sen[i] is not None and kijun_sen[i] is not None and quality_line[i] is not None:
            # Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ÙˆØ²Ù†ÛŒ Ø¨Ø±Ø§ÛŒ Ø®Ø· Ø·Ù„Ø§ÛŒÛŒ
            value = (tenkan_sen[i] *0.4 + 
                    kijun_sen[i] *0.3 + 
                    quality_line[i] *0.3)
            golden.append(value)
        else:
            golden.append(None)
    
    return golden

def calculate_trend_power(tenkan_sen, kijun_sen, closes):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
    Ø¨Ø§Ø²Ú¯Ø´Øª: Û° ØªØ§ Û±Û°Û° (Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯)
    """
    if not tenkan_sen or not kijun_sen or not closes:
        return 50
    
    try:
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§ÙÛŒ
        valid_tenkan = [v for v in tenkan_sen if v is not None]
        valid_kijun = [v for v in kijun_sen if v is not None]
        
        if len(valid_tenkan) < 2 or len(valid_kijun) < 2:
            return 50
        
        # Ø¢Ø®Ø±ÛŒÙ† Ù…Ù‚Ø§Ø¯ÛŒØ±
        last_tenkan = valid_tenkan[-1]
        last_kijun = valid_kijun[-1]
        last_close = closes[-1]
        
        if last_kijun == 0:
            return 50
        
        # Û±. ÙØ§ØµÙ„Ù‡ ØªÙ†Ú©Ø§Ù†-Ú©ÛŒØ¬ÙˆÙ†
        tk_distance = abs(last_tenkan - last_kijun) / last_kijun * 100
        
        # Û². Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚ÛŒÙ…Øª Ù†Ø³Ø¨Øª Ø¨Ù‡ Ø®Ø·ÙˆØ·
        above_tenkan = 1 if last_close > last_tenkan else -1
        above_kijun = 1 if last_close > last_kijun else -1
        
        # Û³. Ø²Ø§ÙˆÛŒÙ‡ Ø±ÙˆÙ†Ø¯ (ØªÙ‚Ø±ÛŒØ¨ÛŒ)
        if len(valid_tenkan) > 5 and len(valid_kijun) > 5:
            tenkan_trend = (valid_tenkan[-1] - valid_tenkan[-5]) / valid_tenkan[-5] * 100 if valid_tenkan[-5] != 0 else 0
            kijun_trend = (valid_kijun[-1] - valid_kijun[-5]) / valid_kijun[-5] * 100 if valid_kijun[-5] != 0 else 0
            avg_trend = (tenkan_trend + kijun_trend) / 2
        else:
            avg_trend = 0
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ù‡Ø§ÛŒÛŒ Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯
        trend_power = 50  # Ø®Ù†Ø«ÛŒ
        
        # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§Ù…ØªÛŒØ§Ø²Ø§Øª
        trend_power += min(tk_distance * 2, 20)  # Ø­Ø¯Ø§Ú©Ø«Ø± Û²Û° Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø±Ø§ÛŒ ÙØ§ØµÙ„Ù‡
        
        if above_tenkan == above_kijun == 1:
            trend_power += 15  # Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ÛŒ Ù‡Ø± Ø¯Ùˆ Ø®Ø·
        elif above_tenkan == above_kijun == -1:
            trend_power -= 15  # Ù‚ÛŒÙ…Øª Ø²ÛŒØ± Ù‡Ø± Ø¯Ùˆ Ø®Ø·
        
        trend_power += avg_trend * 10  # Ø¬Ù‡Øª Ø±ÙˆÙ†Ø¯
        
        # Ù…Ø­Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Ø¨Ø§Ø²Ù‡ Û°-Û±Û°Û°
        trend_power = max(0, min(100, trend_power))
        
        return round(trend_power, 1)
    
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯: {e}")
        return 50

def analyze_ichimoku_scalp_signal(ichimoku_data):
    """
    ØªØ­Ù„ÛŒÙ„ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø§Ø³Ú©Ø§Ù„Ù¾ Ø¨Ø§ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ Ù¾ÛŒØ´Ø±ÙØªÙ‡
    
    Returns:
    --------
    dict
        Ø³ÛŒÚ¯Ù†Ø§Ù„ ØªØ­Ù„ÛŒÙ„
    """
    if not ichimoku_data:
        return {
            'signal': 'HOLD',
            'confidence': 0.5,
            'reason': 'Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ Ø¯Ø§Ø¯Ù‡ Ù†Ø§Ú©Ø§ÙÛŒ',
            'levels': {},
            'trend_power': 50
        }
    
    # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
    tenkan = ichimoku_data.get('tenkan_sen')
    kijun = ichimoku_data.get('kijun_sen')
    cloud_top = ichimoku_data.get('cloud_top')
    cloud_bottom = ichimoku_data.get('cloud_bottom')
    quality_line = ichimoku_data.get('quality_line')
    golden_line = ichimoku_data.get('golden_line')
    trend_power = ichimoku_data.get('trend_power', 50)
    current_price = ichimoku_data.get('current_price')
    
    if None in [tenkan, kijun, current_price] or current_price <= 0:
        return {
            'signal': 'HOLD',
            'confidence': 0.5,
            'reason': 'Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ Ù†Ø§Ù‚Øµ',
            'levels': {},
            'trend_power': trend_power
        }
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø±Ø§ÛŒØ·
    tenkan_above_kijun = tenkan > kijun
    price_above_tenkan = current_price > tenkan
    price_above_kijun = current_price > kijun
    price_above_cloud = current_price > cloud_top if cloud_top else False
    price_in_cloud = cloud_bottom <= current_price <= cloud_top if cloud_bottom and cloud_top else False
    
    # ØªØ­Ù„ÛŒÙ„ Ø³ÛŒÚ¯Ù†Ø§Ù„
    signal = 'HOLD'
    confidence = 0.5
    reason = "Ø¨Ø§Ø²Ø§Ø± Ø®Ù†Ø«ÛŒ"
    
    bullish_conditions = 0
    bearish_conditions = 0
    
    # Ø´Ø±Ø§ÛŒØ· Ø®Ø±ÛŒØ¯ (Bullish)
    if tenkan_above_kijun:
        bullish_conditions += 1
        reason = "ØªÙ†Ú©Ø§Ù† Ø¨Ø§Ù„Ø§ÛŒ Ú©ÛŒØ¬ÙˆÙ†"
    
    if price_above_tenkan and price_above_kijun:
        bullish_conditions += 1
        reason = "Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ÛŒ Ù‡Ø± Ø¯Ùˆ Ø®Ø·"
    
    if price_above_cloud:
        bullish_conditions += 2  # ÙˆØ²Ù† Ø¨ÛŒØ´ØªØ±
        reason = "Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ÛŒ Ø§Ø¨Ø± Ú©ÙˆÙ…Ùˆ"
    
    # Ø´Ø±Ø§ÛŒØ· ÙØ±ÙˆØ´ (Bearish)
    if not tenkan_above_kijun:
        bearish_conditions += 1
        reason = "ØªÙ†Ú©Ø§Ù† Ø²ÛŒØ± Ú©ÛŒØ¬ÙˆÙ†"
    
    if not price_above_tenkan and not price_above_kijun:
        bearish_conditions += 1
        reason = "Ù‚ÛŒÙ…Øª Ø²ÛŒØ± Ù‡Ø± Ø¯Ùˆ Ø®Ø·"
    
    if cloud_bottom and current_price < cloud_bottom:
        bearish_conditions += 2
        reason = "Ù‚ÛŒÙ…Øª Ø²ÛŒØ± Ø§Ø¨Ø± Ú©ÙˆÙ…Ùˆ"
    
    # ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ Ù†Ù‡Ø§ÛŒÛŒ
    if bullish_conditions >= 3:
        signal = 'BUY'
        confidence = min(0.5 + (bullish_conditions * 0.1) + (trend_power / 200), 0.95)
        reason = f"{reason} (Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø®Ø±ÛŒØ¯)"
    elif bearish_conditions >= 3:
        signal = 'SELL'
        confidence = min(0.5 + (bearish_conditions * 0.1) + ((100 - trend_power) / 200), 0.95)
        reason = f"{reason} (Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙØ±ÙˆØ´)"
    else:
        signal = 'HOLD'
        confidence = 0.5
    
    # Ø§Ú¯Ø± Ø¯Ø± Ø§Ø¨Ø± Ù‡Ø³ØªÛŒÙ…ØŒ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ú©Ù…â€ŒØªØ±
    if price_in_cloud:
        confidence *= 0.7
        reason += " - Ø¯Ø±ÙˆÙ† Ø§Ø¨Ø±"
    
    # Ø³Ø·ÙˆØ­ Ú©Ù„ÛŒØ¯ÛŒ
    levels = {
        'tenkan_sen': round(tenkan, 4),
        'kijun_sen': round(kijun, 4),
        'cloud_top': round(cloud_top, 4) if cloud_top else None,
        'cloud_bottom': round(cloud_bottom, 4) if cloud_bottom else None,
        'quality_line': round(quality_line, 4) if quality_line else None,
        'golden_line': round(golden_line, 4) if golden_line else None,
        'support_level': round(min(tenkan, kijun, cloud_bottom if cloud_bottom else tenkan), 4),
        'resistance_level': round(max(tenkan, kijun, cloud_top if cloud_top else kijun), 4),
        'current_price': round(current_price, 4)
    }
    
    # Ø§Ú¯Ø± Ø®Ø· Ø·Ù„Ø§ÛŒÛŒ Ø¯Ø§Ø±ÛŒÙ…ØŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù‚ÙˆÛŒâ€ŒØªØ±
    if golden_line:
        if signal == 'BUY' and current_price > golden_line:
            confidence = min(confidence * 1.2, 0.95)
            reason += " + ØªØ£ÛŒÛŒØ¯ Ø®Ø· Ø·Ù„Ø§ÛŒÛŒ"
        elif signal == 'SELL' and current_price < golden_line:
            confidence = min(confidence * 1.2, 0.95)
            reason += " + ØªØ£ÛŒÛŒØ¯ Ø®Ø· Ø·Ù„Ø§ÛŒÛŒ"
    
    # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ØªÙØ³ÛŒØ± Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯
    trend_interpretation = "Ø±ÙˆÙ†Ø¯ Ù‚ÙˆÛŒ" if trend_power >= 70 else \
                          "Ø±ÙˆÙ†Ø¯ Ù…ØªÙˆØ³Ø·" if trend_power >= 60 else \
                          "Ø±ÙˆÙ†Ø¯ Ø¶Ø¹ÛŒÙ" if trend_power >= 40 else "Ø¨Ø¯ÙˆÙ† Ø±ÙˆÙ†Ø¯"
    
    return {
        'signal': signal,
        'confidence': round(confidence, 3),
        'reason': reason,
        'levels': levels,
        'trend_power': trend_power,
        'trend_interpretation': trend_interpretation,
        'cloud_thickness': ichimoku_data.get('cloud_thickness', 0),
        'in_cloud': price_in_cloud,
        'cloud_color': 'Ø³Ø¨Ø²' if cloud_top and cloud_bottom and cloud_top > cloud_bottom else 'Ù‚Ø±Ù…Ø²'
    }

def get_ichimoku_scalp_signal(data, timeframe="5m"):
    """
    Ø¯Ø±ÛŒØ§ÙØª Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø§Ø³Ú©Ø§Ù„Ù¾ Ø¨Ø§ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
    (Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…Ø³ØªÙ‚ÛŒÙ… Ø¯Ø± Ø³Ø§ÛŒØ± Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§)
    """
    try:
        if not data or len(data) < 60:
            return None
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
        ichimoku = calculate_ichimoku_components(data)
        
        if not ichimoku:
            return None
        
        # ØªØ­Ù„ÛŒÙ„ Ø³ÛŒÚ¯Ù†Ø§Ù„
        signal = analyze_ichimoku_scalp_signal(ichimoku)
        
        # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…
        signal['timeframe'] = timeframe
        
        return signal
        
    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ: {e}")
        return None

# ==============================================================================
# ğŸš€ Ù…ÙˆØªÙˆØ± Ø§ØµÙ„ÛŒ ØªØ­Ù„ÛŒÙ„ (Ø³Ø§Ø¯Ù‡â€ŒØ´Ø¯Ù‡)
# ==============================================================================

def analyze_with_multi_timeframe_strategy(symbol):
    """
    ØªØ­Ù„ÛŒÙ„ Ú†Ù†Ø¯Ø²Ù…Ø§Ù†ÛŒ - Ù†Ø³Ø®Ù‡ Ø¨Ù‡ÛŒÙ†Ù‡ Ø¨Ø±Ø§ÛŒ Render
    
    Parameters:
    -----------
    symbol : str
        Ù†Ù…Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ (Ù…Ø«Ù„Ø§Ù‹ BTCUSDT)
    
    Returns:
    --------
    dict
        ØªØ­Ù„ÛŒÙ„ Ú©Ø§Ù…Ù„ Ø¨Ø§ Ø³ÛŒÚ¯Ù†Ø§Ù„ØŒ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†ØŒ Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯ØŒ ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ Ùˆ Ø§Ø³ØªØ§Ù¾â€ŒÙ„Ø§Ø³
    """
    logger.info(f"ğŸ¤– ØªØ­Ù„ÛŒÙ„ {symbol}")
    
    try:
        # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ Ø§Ø² ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
        result_1h = get_market_data_with_fallback(symbol, "1h", 50, return_source=True)
        result_15m = get_market_data_with_fallback(symbol, "15m", 50, return_source=True)
        result_5m = get_market_data_with_fallback(symbol, "5m", 50, return_source=True)
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
        data_1h = result_1h.get("data", [])
        data_15m = result_15m.get("data", [])
        data_5m = result_5m.get("data", [])
        
        if not data_5m:  # Ø§Ú¯Ø± Ù‡ÛŒÚ† Ø¯Ø§Ø¯Ù‡Ø§ÛŒ Ù†Ø¯Ø§Ø±ÛŒÙ…
            return get_fallback_signal(symbol)
        
        # ØªØ­Ù„ÛŒÙ„ Ù‡Ø± ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…
        trend_1h = analyze_trend_simple(data_1h)
        trend_15m = analyze_trend_simple(data_15m)
        trend_5m = analyze_trend_simple(data_5m)
        
        # ØªØ±Ú©ÛŒØ¨ Ù†ØªØ§ÛŒØ¬
        trends = [trend_1h, trend_15m, trend_5m]
        bullish_count = sum(1 for t in trends if t == "BULLISH")
        bearish_count = sum(1 for t in trends if t == "BEARISH")
        
        # ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ Ù†Ù‡Ø§ÛŒÛŒ
        if bullish_count >= 2:
            signal = "BUY"
            confidence = 0.6 + (bullish_count * 0.1)
        elif bearish_count >= 2:
            signal = "SELL"
            confidence = 0.6 + (bearish_count * 0.1)
        else:
            signal = "HOLD"
            confidence = 0.5
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§
        try:
            latest_close = float(data_5m[-1][4])
        except (IndexError, ValueError, TypeError):
            latest_close = 100.0
        
        if latest_close <= 0:
            latest_close = 100.0
        
        # âœ… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ§Ø¨Ø¹ Ù…Ø±Ú©Ø²ÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§
        if signal == "BUY":
            entry_price = latest_close * 1.001
            stop_loss = latest_close * 0.98
            targets = [
                latest_close * 1.02,  # 2% Ø¨Ø§Ù„Ø§ØªØ±
                latest_close * 1.05   # 5% Ø¨Ø§Ù„Ø§ØªØ±
            ]
        elif signal == "SELL":
            entry_price = latest_close * 0.999
            stop_loss = latest_close * 1.02
            targets = [
                latest_close * 0.98,  # 2% Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±
                latest_close * 0.95   # 5% Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±
            ]
        else:  # HOLD
            entry_price = latest_close
            stop_loss = latest_close * 0.99
            targets = []
        
        return {
            "symbol": symbol,
            "signal": signal,
            "confidence": round(min(confidence, 0.95), 2),
            "entry_price": round(entry_price, 2),
            "targets": [round(t, 2) for t in targets],
            "stop_loss": round(stop_loss, 2),
            "strategy": "Multi-Timeframe Simple",
            "analysis_details": {
                "1h": {"trend": trend_1h, "source": result_1h.get("source", "unknown")},
                "15m": {"trend": trend_15m, "source": result_15m.get("source", "unknown")},
                "5m": {"trend": trend_5m, "source": result_5m.get("source", "unknown")}
            }
        }
        
    except Exception as e:
        logger.error(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ­Ù„ÛŒÙ„ {symbol}: {e}")
        return get_fallback_signal(symbol)

def analyze_trend_simple(data):
    """
    ØªØ­Ù„ÛŒÙ„ Ø±ÙˆÙ†Ø¯ Ø³Ø§Ø¯Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ SMA Ùˆ RSI - Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡
    
    Parameters:
    -----------
    data : list
        Ù„ÛŒØ³Øª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
    
    Returns:
    --------
    str
        "BULLISH", "BEARISH", ÛŒØ§ "NEUTRAL"
    """
    if not data or len(data) < 20:
        return "NEUTRAL"
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ SMA
    sma_20 = calculate_simple_sma(data, 20)
    if sma_20 is None or sma_20 == 0:
        return "NEUTRAL"
    
    # Ø¢Ø®Ø±ÛŒÙ† Ù‚ÛŒÙ…Øª Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù†
    try:
        latest_close = float(data[-1][4])
    except (IndexError, ValueError, TypeError):
        return "NEUTRAL"
    
    if latest_close <= 0:
        return "NEUTRAL"
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ RSI (Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù†Ø³Ø®Ù‡ Ø¬Ø¯ÛŒØ¯ Ø³Ø±ÛŒ)
    rsi = calculate_simple_rsi(data, 14)
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ MACD
    macd_data = calculate_macd_simple(data)
    
    # ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ
    bullish_signals = 0
    bearish_signals = 0
    
    if latest_close > sma_20:
        bullish_signals += 1
    else:
        bearish_signals += 1
    
    if rsi < 40:
        bullish_signals += 1  # Ø§Ø´Ø¨Ø§Ø¹ ÙØ±ÙˆØ´
    elif rsi > 60:
        bearish_signals += 1  # Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯
    
    if macd_data['histogram'] > 0:
        bullish_signals += 1
    elif macd_data['histogram'] < 0:
        bearish_signals += 1
    
    if bullish_signals > bearish_signals:
        return "BULLISH"
    elif bearish_signals > bullish_signals:
        return "BEARISH"
    else:
        return "NEUTRAL"

def get_fallback_signal(symbol):
    """
    Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§ - Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡
    
    Parameters:
    -----------
    symbol : str
        Ù†Ù…Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ
    
    Returns:
    --------
    dict
        Ø³ÛŒÚ¯Ù†Ø§Ù„ fallback
    """
    # Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡ ÙˆØ§Ù‚Ø¹ÛŒâ€ŒØªØ±
    base_prices = {
        'BTCUSDT': 88271.42,
        'ETHUSDT': 3450.12,
        'BNBUSDT': 590.54,
        'SOLUSDT': 175.98,
        'DEFAULT': 100.50
    }
    
    base_price = base_prices.get(symbol.upper(), base_prices['DEFAULT'])
    
    # Ø´Ø§Ù†Ø³ Ø¨ÛŒØ´ØªØ± Ø¨Ø±Ø§ÛŒ HOLD
    signals = ["BUY", "SELL", "HOLD"]
    weights = [0.35, 0.35, 0.30]
    signal = random.choices(signals, weights=weights)[0]
    
    if signal == "HOLD":
        confidence = round(random.uniform(0.5, 0.7), 2)
    else:
        confidence = round(random.uniform(0.65, 0.85), 2)
    
    entry_price = round(base_price * random.uniform(0.99, 1.01), 2)
    
    if signal == "BUY":
        targets = [
            round(entry_price * 1.02, 2),  # 2% Ø¨Ø§Ù„Ø§ØªØ±
            round(entry_price * 1.05, 2)   # 5% Ø¨Ø§Ù„Ø§ØªØ±
        ]
        stop_loss = round(entry_price * 0.98, 2)  # 2% Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±
    elif signal == "SELL":
        targets = [
            round(entry_price * 0.98, 2),  # 2% Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±
            round(entry_price * 0.95, 2)   # 5% Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±
        ]
        stop_loss = round(entry_price * 1.02, 2)  # 2% Ø¨Ø§Ù„Ø§ØªØ±
    else:
        targets = []
        stop_loss = entry_price
    
    return {
        "symbol": symbol,
        "signal": signal,
        "confidence": confidence,
        "entry_price": entry_price,
        "targets": targets,
        "stop_loss": stop_loss,
        "strategy": "Fallback Mode",
        "note": "Analysis failed, using fallback"
    }

# ==============================================================================
# ğŸ“Š ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ
# ==============================================================================

def calculate_24h_change_from_dataframe(data):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØºÛŒÛŒØ±Ø§Øª Û²Û´ Ø³Ø§Ø¹ØªÙ‡
    
    Parameters:
    -----------
    data : list or dict
        Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±
    
    Returns:
    --------
    float
        Ø¯Ø±ØµØ¯ ØªØºÛŒÛŒØ±
    """
    # Ø§Ú¯Ø± data Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø§Ø³ØªØŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ú©Ù†
    if isinstance(data, dict) and "data" in data:
        data_list = data["data"]
    elif isinstance(data, list):
        data_list = data
    else:
        return round(random.uniform(-5, 5), 2)
    
    if not isinstance(data_list, list) or len(data_list) < 10:
        return round(random.uniform(-5, 5), 2)
    
    try:
        # Ø§ÙˆÙ„ÛŒÙ† Ú©Ù†Ø¯Ù„ (Ù‚Ø¯ÛŒÙ…ÛŒâ€ŒØªØ±ÛŒÙ†)
        first_close = float(data_list[0][4])
        # Ø¢Ø®Ø±ÛŒÙ† Ú©Ù†Ø¯Ù„
        last_close = float(data_list[-1][4])
        
        if first_close <= 0:
            return 0.0
        
        change = ((last_close - first_close) / first_close) * 100
        return round(change, 2)
    except (IndexError, ValueError, TypeError, ZeroDivisionError):
        return round(random.uniform(-5, 5), 2)

def analyze_scalp_conditions(data, timeframe):
    """
    ØªØ­Ù„ÛŒÙ„ Ø´Ø±Ø§ÛŒØ· Ø§Ø³Ú©Ø§Ù„Ù¾ Ø¨Ø±Ø§ÛŒ ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…â€ŒÙ‡Ø§ÛŒ Ú©ÙˆØªØ§Ù‡ - Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡
    
    Parameters:
    -----------
    data : list
        Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ù†Ø¯Ù„
    timeframe : str
        ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… (1m, 5m, 15m)
    
    Returns:
    --------
    dict
        ØªØ­Ù„ÛŒÙ„ Ø´Ø±Ø§ÛŒØ· Ø§Ø³Ú©Ø§Ù„Ù¾
    """
    if not data or len(data) < 20:
        return {
            "condition": "NEUTRAL",
            "rsi": 50,
            "sma_20": 0,
            "volatility": 0,
            "reason": "Insufficient data"
        }
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
    rsi = calculate_simple_rsi(data, 14)
    sma_20 = calculate_simple_sma(data, 20)
    
    # âœ… Ú†Ú© Ú©Ø±Ø¯Ù† None
    if sma_20 is None:
        sma_20 = 0
    
    try:
        latest_close = float(data[-1][4])
        prev_close = float(data[-2][4])
    except (IndexError, ValueError, TypeError):
        latest_close = 0
        prev_close = 0
    
    # Ù†ÙˆØ³Ø§Ù†â€ŒÙ¾Ø°ÛŒØ±ÛŒ
    volatility = abs((latest_close - prev_close) / prev_close * 100) if prev_close > 0 else 0
    
    # ØªØ­Ù„ÛŒÙ„ Ø´Ø±Ø§ÛŒØ·
    condition = "NEUTRAL"
    reason = "Market in equilibrium"
    
    # âœ… Ú†Ú© Ú©Ø±Ø¯Ù† Ù‚ÛŒÙ…Øª Ù…Ø¹ØªØ¨Ø±
    if latest_close <= 0 or sma_20 <= 0:
        return {
            "condition": "NEUTRAL",
            "rsi": round(rsi, 1),
            "sma_20": 0,
            "current_price": 0,
            "volatility": 0,
            "reason": "Invalid price data"
        }
    
    # Ø´Ø±Ø§ÛŒØ· Ø®Ø±ÛŒØ¯ Ø§Ø³Ú©Ø§Ù„Ù¾
    if rsi < 30 and latest_close < sma_20 * 1.01:
        condition = "BULLISH"
        reason = f"Oversold (RSI: {rsi:.1f}), price near SMA20"
    
    # Ø´Ø±Ø§ÛŒØ· ÙØ±ÙˆØ´ Ø§Ø³Ú©Ø§Ù„Ù¾
    elif rsi > 70 and latest_close > sma_20 * 0.99:
        condition = "BEARISH"
        reason = f"Overbought (RSI: {rsi:.1f}), price near SMA20"
    
    # Ø´Ø±Ø§ÛŒØ· Breakout
    elif latest_close > sma_20 * 1.02 and rsi < 60:
        condition = "BULLISH"
        reason = f"Breakout above SMA20, RSI: {rsi:.1f}"
    
    elif latest_close < sma_20 * 0.98 and rsi > 40:
        condition = "BEARISH"
        reason = f"Breakdown below SMA20, RSI: {rsi:.1f}"
    
    # Ù†ÙˆØ³Ø§Ù† Ø¨Ø§Ù„Ø§ (Ø¨Ø±Ø§ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³Øª)
    elif volatility > 1.0 and timeframe in ["1m", "5m"]:
        condition = "VOLATILE"
        reason = f"High volatility: {volatility:.2f}%"
    
    return {
        "condition": condition,
        "rsi": round(rsi, 1),
        "sma_20": round(sma_20, 2) if sma_20 else 0,
        "current_price": round(latest_close, 2),
        "volatility": round(volatility, 2),
        "reason": reason
    }

# ==============================================================================
# ğŸ¯ ØªÙˆØ§Ø¨Ø¹ Ø§Ø¶Ø§ÙÛŒ Ø¨Ø±Ø§ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø¨Ù‡ØªØ±
# ==============================================================================

def get_support_resistance_levels(data):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø·ÙˆØ­ Ø­Ù…Ø§ÛŒØª Ùˆ Ù…Ù‚Ø§ÙˆÙ…Øª Ø³Ø§Ø¯Ù‡
    """
    if not data or len(data) < 20:
        return {"support": 0, "resistance": 0}
    
    highs = []
    lows = []
    
    for candle in data[-20:]:  # Ø¢Ø®Ø±ÛŒÙ† Û²Û° Ú©Ù†Ø¯Ù„
        try:
            highs.append(float(candle[2]))
            lows.append(float(candle[3]))
        except:
            continue
    
    if not highs or not lows:
        return {"support": 0, "resistance": 0}
    
    # Ø³Ø§Ø¯Ù‡â€ŒØªØ±ÛŒÙ† Ø±ÙˆØ´: Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¨Ø§Ù„Ø§Ù‡Ø§ Ùˆ Ù¾Ø§ÛŒÛŒÙ†â€ŒÙ‡Ø§
    resistance = sum(highs) / len(highs)
    support = sum(lows) / len(lows)
    
    return {
        "support": round(support, 4),
        "resistance": round(resistance, 4),
        "range_percent": round((resistance - support) / support * 100, 2)
    }

def calculate_volatility(data, period=20):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†ÙˆØ³Ø§Ù†â€ŒÙ¾Ø°ÛŒØ±ÛŒ
    """
    if not data or len(data) < period:
        return 0
    
    changes = []
    for i in range(1, min(len(data), period)):
        try:
            current = float(data[-i][4])
            previous = float(data[-i-1][4])
            if previous > 0:
                change = abs(current - previous) / previous
                changes.append(change)
        except:
            continue
    
    if not changes:
        return 0
    
    avg_change = sum(changes) / len(changes)
    volatility = avg_change * 100  # Ø¨Ù‡ Ø¯Ø±ØµØ¯
    
    return round(volatility, 2)

# ==============================================================================
# ğŸ”§ ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
# ==============================================================================

def generate_ichimoku_recommendation(signal_data):
    """
    ØªÙˆÙ„ÛŒØ¯ ØªÙˆØµÛŒÙ‡ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
    """
    signal = signal_data.get('signal', 'HOLD')
    confidence = signal_data.get('confidence', 0.5)
    in_cloud = signal_data.get('in_cloud', False)
    trend_power = signal_data.get('trend_power', 50)
    
    recommendations = {
        'BUY': {
            'high': 'Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø®Ø±ÛŒØ¯ Ù‚ÙˆÛŒ - ÙˆØ±ÙˆØ¯ Ø¨Ø§ Ø­Ø¬Ù… Ù…Ù†Ø§Ø³Ø¨',
            'medium': 'Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø®Ø±ÛŒØ¯ Ù…ØªÙˆØ³Ø· - ÙˆØ±ÙˆØ¯ Ø¨Ø§ Ø§Ø­ØªÛŒØ§Ø·',
            'low': 'Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø®Ø±ÛŒØ¯ Ø¶Ø¹ÛŒÙ - Ù…Ù†ØªØ¸Ø± ØªØ£ÛŒÛŒØ¯ Ø¨Ù…Ø§Ù†ÛŒØ¯'
        },
        'SELL': {
            'high': 'Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙØ±ÙˆØ´ Ù‚ÙˆÛŒ - Ø®Ø±ÙˆØ¬ ÛŒØ§ Short',
            'medium': 'Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙØ±ÙˆØ´ Ù…ØªÙˆØ³Ø· - Ú©Ø§Ù‡Ø´ Ù…ÙˆÙ‚Ø¹ÛŒØª',
            'low': 'Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙØ±ÙˆØ´ Ø¶Ø¹ÛŒÙ - Ù…Ù†ØªØ¸Ø± ØªØ£ÛŒÛŒØ¯ Ø¨Ù…Ø§Ù†ÛŒØ¯'
        },
        'HOLD': {
            'in_cloud': 'Ù‚ÛŒÙ…Øª Ø¯Ø± Ø§Ø¨Ø± Ú©ÙˆÙ…Ùˆ - Ù…Ù†ØªØ¸Ø± Ø´Ú©Ø³Øª Ø¨Ù…Ø§Ù†ÛŒØ¯',
            'low_conf': 'Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù†Ø§Ù…Ø´Ø®Øµ - Ø§Ø² Ø¨Ø§Ø²Ø§Ø± Ø¯ÙˆØ±ÛŒ Ú©Ù†ÛŒØ¯',
            'default': 'Ù…ÙˆÙ‚Ø¹ÛŒØª ÙØ¹Ù„ÛŒ Ø±Ø§ Ø­ÙØ¸ Ú©Ù†ÛŒØ¯'
        }
    }
    
    if signal == 'BUY':
        if confidence > 0.7:
            return recommendations['BUY']['high']
        elif confidence > 0.6:
            return recommendations['BUY']['medium']
        else:
            return recommendations['BUY']['low']
    
    elif signal == 'SELL':
        if confidence > 0.7:
            return recommendations['SELL']['high']
        elif confidence > 0.6:
            return recommendations['SELL']['medium']
        else:
            return recommendations['SELL']['low']
    
    else:  # HOLD
        if in_cloud:
            return recommendations['HOLD']['in_cloud']
        elif confidence < 0.4 or trend_power < 30:
            return recommendations['HOLD']['low_conf']
        else:
            return recommendations['HOLD']['default']

# ==============================================================================
# ğŸ¯ ØªÙˆØ§Ø¨Ø¹ ØªØ±Ú©ÛŒØ¨ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ­Ù„ÛŒÙ„ Ø¨Ù‡ØªØ±
# ==============================================================================

def combined_analysis(data, timeframe="5m"):
    """
    ØªØ­Ù„ÛŒÙ„ ØªØ±Ú©ÛŒØ¨ÛŒ Ø¨Ø§ Ú†Ù†Ø¯ÛŒÙ† Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±
    """
    if not data or len(data) < 30:
        return None
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ù…Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
    results = {
        'rsi': calculate_simple_rsi(data, 14),
        'sma_20': calculate_simple_sma(data, 20),
        'macd': calculate_macd_simple(data),
        'ichimoku': get_ichimoku_scalp_signal(data, timeframe),
        'support_resistance': get_support_resistance_levels(data),
        'volatility': calculate_volatility(data, 20)
    }
    
    # ØªØ­Ù„ÛŒÙ„ Ù†Ù‡Ø§ÛŒÛŒ
    try:
        latest_price = float(data[-1][4])
    except:
        latest_price = 0
    
    # ÙˆØ²Ù†â€ŒØ¯Ù‡ÛŒ Ø¨Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§
    signals = {
        'buy': 0,
        'sell': 0,
        'hold': 0
    }
    
    # RSI
    if results['rsi'] < 30:
        signals['buy'] += 1.5
    elif results['rsi'] > 70:
        signals['sell'] += 1.5
    else:
        signals['hold'] += 1
    
    # SMA
    if latest_price > results['sma_20']:
        signals['buy'] += 1
    else:
        signals['sell'] += 1
    
    # MACD
    if results['macd']['histogram'] > 0:
        signals['buy'] += 1
    else:
        signals['sell'] += 1
    
    # Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
    if results['ichimoku']:
        ich_signal = results['ichimoku'].get('signal', 'HOLD')
        if ich_signal == 'BUY':
            signals['buy'] += 2  # ÙˆØ²Ù† Ø¨ÛŒØ´ØªØ± Ø¨Ø±Ø§ÛŒ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
        elif ich_signal == 'SELL':
            signals['sell'] += 2
    
    # ØªØµÙ…ÛŒÙ… Ù†Ù‡Ø§ÛŒÛŒ
    final_signal = max(signals, key=signals.get)
    confidence = signals[final_signal] / sum(signals.values()) if sum(signals.values()) > 0 else 0.5
    
    return {
        'signal': final_signal.upper(),
        'confidence': round(confidence, 3),
        'details': results,
        'price': latest_price,
        'timestamp': datetime.now().isoformat()
    }

# ==============================================================================
# ğŸ“ Version Info
# ==============================================================================

__version__ = "7.5.0"
__author__ = "Crypto AI Trading System"
__description__ = "Ø³ÛŒØ³ØªÙ… ØªØ­Ù„ÛŒÙ„ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ùˆ ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ ÙˆØ§Ù‚Ø¹ÛŒ"

# ==============================================================================
# ğŸ“¦ Export ØªÙˆØ§Ø¨Ø¹
# ==============================================================================

__all__ = [
    # ØªÙˆØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ
    'get_market_data_with_fallback',
    'analyze_with_multi_timeframe_strategy',
    
    # ØªÙˆØ§Ø¨Ø¹ ØªØ­Ù„ÛŒÙ„ Ù¾Ø§ÛŒÙ‡
    'calculate_simple_sma',
    'calculate_simple_rsi', # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯Ù‡
    'calculate_rsi_series', # Ø¬Ø¯ÛŒØ¯ - Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù„ÛŒØ³Øª RSI
    'detect_divergence', # Ø¬Ø¯ÛŒØ¯ - ØªØ´Ø®ÛŒØµ ÙˆØ§Ú¯Ø±Ø§ÛŒÛŒ
    'calculate_macd_simple',
    'analyze_trend_simple',
    
    # ØªÙˆØ§Ø¨Ø¹ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
    'calculate_ichimoku_components',
    'analyze_ichimoku_scalp_signal',
    'get_ichimoku_scalp_signal',
    'calculate_quality_line',
    'calculate_golden_line',
    
    # ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ
    'calculate_24h_change_from_dataframe',
    'analyze_scalp_conditions',
    'get_support_resistance_levels',
    'calculate_volatility',
    'combined_analysis',
    'generate_ichimoku_recommendation',
    
    # ØªÙˆØ§Ø¨Ø¹ fallback
    'get_fallback_signal'
]

print(f"âœ… utils.py v{__version__} loaded successfully!")
print(f"ğŸ“Š Features: Ichimoku Advanced, Quality Line, Golden Line, Multi-Timeframe")
print(f"âš¡ Scalp Support: 1m/5m/15m with Ichimoku")
print(f"ğŸ§  RSI Engine: Real (Series Calculation)")
print(f"âš–ï¸ Divergence Engine: Real (Peak/Trough Analysis)")
```