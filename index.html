<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>AI Smart Money Scanner - Scalp & Swing Signals</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,sans-serif;background:#1a1a2e;color:#fff;min-height:100vh;padding:10px}
.header{background:#16213e;padding:15px;text-align:center;border-radius:10px;margin-bottom:10px}
.header h1{font-size:20px;color:#00d9ff}

/* Advisor Panel Styles */
.advisor-panel {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 2px solid #00d9ff;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
}
.advisor-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    color: #00d9ff;
    font-size: 18px;
    font-weight: bold;
}
.advisor-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 15px;
}
.advisor-item {
    background: rgba(0, 0, 0, 0.3);
    padding: 12px;
    border-radius: 8px;
    border-left: 4px solid;
}
.advisor-item.good { border-left-color: #00ff88; }
.advisor-item.warning { border-left-color: #ff9900; }
.advisor-item.danger { border-left-color: #ff4444; }
.advisor-label {
    font-size: 12px;
    color: #888;
    margin-bottom: 5px;
}
.advisor-value {
    font-size: 16px;
    font-weight: bold;
}
.advice-box {
    background: rgba(0, 217, 255, 0.1);
    border-radius: 8px;
    padding: 15px;
    margin-top: 15px;
    border: 1px solid rgba(0, 217, 255, 0.3);
}
.advice-title {
    color: #00ff88;
    font-weight: bold;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
}
.advice-text {
    color: #fff;
    line-height: 1.5;
    font-size: 14px;
}
.status-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-left: 8px;
}
.status-online { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
.status-offline { background: #ff4444; }
.status-warning { background: #ff9900; }

/* Existing Styles */
.controls{background:#0f3460;padding:15px;border-radius:10px;margin-bottom:10px}
.control-row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px}
.control-group{display:flex;flex-direction:column;gap:5px}
.control-group label{font-size:11px;color:#888}
select,input[type="text"]{background:#16213e;color:#fff;border:2px solid #00d9ff;padding:10px;border-radius:6px;font-size:14px;width:100%}
.btn{border:none;padding:15px;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer;width:100%;margin-bottom:10px;transition:all 0.3s}
.btn-start{background:#00d9ff;color:#000}
.btn-start.active{background:#ff4444;color:#fff}
.btn-test{background:#ff9900;color:#000}
.btn-force{background:#00ff88;color:#000}
.btn-scalp{background:#ff00ff;color:#000}
.market-toggle{display:flex;gap:10px;margin-bottom:10px}
.market-btn{flex:1;padding:12px;border-radius:8px;border:2px solid #555;background:#16213e;color:#fff;cursor:pointer;font-weight:bold;transition:all 0.3s}
.market-btn.active{background:#00d9ff;color:#000;border-color:#00d9ff}
.timeframe-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px}
.tf-btn{padding:10px;border-radius:6px;border:2px solid #555;background:#16213e;color:#fff;cursor:pointer;font-size:12px;font-weight:bold;transition:all 0.3s}
.tf-btn.active{border-color:#00d9ff;background:#00d9ff;color:#000}
.status{background:#0f3460;padding:15px;border-radius:10px;margin-bottom:10px;position:relative}
.status-grid{display:grid;grid-template-columns:1fr 1fr;gap:15px;text-align:center}
.status-label{font-size:11px;color:#888;margin-bottom:5px}
.status-value{font-size:20px;font-weight:bold}
.debug{background:#16213e;padding:15px;border-radius:10px;margin-bottom:10px;max-height:200px;overflow-y:auto;font-size:11px;line-height:1.6}
.debug-line{margin:3px 0;padding:3px;border-left:3px solid #00d9ff}
.debug-line.success{border-left-color:#00ff88}
.debug-line.error{border-left-color:#ff4444}
.debug-line.warning{border-left-color:#ff9900}
.debug-line.scalp{border-left-color:#ff00ff}
.signals{margin-top:10px}
.signal-card{background:#16213e;border-left:5px solid #00ff88;padding:15px;border-radius:10px;margin-bottom:15px;animation:slideIn 0.4s ease}
@keyframes slideIn{from{opacity:0;transform:translateX(-20px)}to{opacity:1;transform:translateX(0)}}
.signal-card.sell{border-left-color:#ff4444}
.signal-card.hold{border-left-color:#ff9900}
.signal-card.scalp{border-left:5px solid #ff00ff}
.signal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.signal-type{font-size:20px;font-weight:bold}
.signal-badge{font-size:10px;padding:5px 10px;border-radius:5px;background:rgba(0,255,136,0.2)}
.signal-details{font-size:13px;line-height:1.8}
.signal-details div{margin:5px 0}
.targets{margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.2);background:rgba(0,0,0,0.2);padding:10px;border-radius:5px}
.tf-indicator{display:inline-block;padding:3px 8px;border-radius:4px;font-size:10px;font-weight:bold;margin-left:5px}
.tf-1m{background:#ff00ff;color:#fff}
.tf-5m{background:#ff6b6b;color:#fff}
.tf-15m{background:#ffd93d;color:#000}
.tf-1h{background:#6bcf7f;color:#fff}
.tf-4h{background:#4d96ff;color:#fff}
.footer{text-align:center;padding:15px;font-size:12px;color:#888}
.symbol-list-item{padding:10px;cursor:pointer;border-bottom:1px solid #0f3460;color:#fff;transition:background 0.2s}
.symbol-list-item:hover{background:#0f3460}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª */
.price-display {
    font-family: 'Courier New', monospace;
    letter-spacing: 0.5px;
}
.price-tiny {
    font-size: 12px;
    opacity: 0.9;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ ÙØ§Ø±Ú©Ø³ Ùˆ Ø·Ù„Ø§ */
.forex-symbol { color: #ffd700; }
.gold-symbol { color: #ffd700; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø®Ø·Ø§ */
.error-message {
    background: rgba(255, 68, 68, 0.2);
    border: 1px solid #ff4444;
    padding: 10px;
    border-radius: 8px;
    margin: 10px 0;
    color: #ff8888;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø¯Ú©Ù…Ù‡ Ø¯ÛŒØ¨Ø§Ú¯ */
.debug-btn {
    background: #555;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 11px;
    margin-left: 10px;
    cursor: pointer;
    position: absolute;
    top: 10px;
    right: 10px;
}
.debug-btn:hover {
    background: #666;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø±ÙØ±Ø´ Ù‚ÛŒÙ…Øª */
.refresh-price {
    background: transparent;
    border: none;
    color: #00d9ff;
    cursor: pointer;
    font-size: 12px;
    margin-left: 5px;
}
.refresh-price:hover {
    color: #00ff88;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ ØªØ¨â€ŒÙ‡Ø§ */
.tab-container {
    display: flex;
    gap: 5px;
    margin-bottom: 15px;
    background: #0f3460;
    padding: 5px;
    border-radius: 8px;
}
.tab {
    flex: 1;
    padding: 10px;
    text-align: center;
    background: transparent;
    border: none;
    color: #888;
    cursor: pointer;
    border-radius: 6px;
    font-weight: bold;
    transition: all 0.3s;
}
.tab.active {
    background: #00d9ff;
    color: #000;
}
.tab.scalp {
    color: #ff00ff;
}
.tab.scalp.active {
    background: #ff00ff;
    color: #000;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ */
.scalp-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #ff00ff;
    margin-right: 5px;
    animation: pulse 1s infinite;
}
@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ RSI indicator */
.rsi-indicator {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: bold;
    margin-left: 5px;
}
.rsi-oversold { background: rgba(0, 255, 136, 0.3); color: #00ff88; }
.rsi-overbought { background: rgba(255, 68, 68, 0.3); color: #ff4444; }
.rsi-neutral { background: rgba(255, 255, 255, 0.1); color: #fff; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ØµØ¯Ù‡Ø§ÛŒ ØµØ­ÛŒØ­ */
.percent-positive { color: #00ff88; }
.percent-negative { color: #ff4444; }
.percent-warning { color: #ff9900; }
</style>
</head>
<body>

<div class="header">
<h1>ğŸ¤– AI Smart Money Scanner v2.1</h1>
<div style="font-size:12px;color:#888;margin-top:5px">Scalp (1m/5m/15m) + Swing (1h/4h) Signals | Real-time Binance</div>
</div>

<!-- AI Advisor Panel -->
<div class="advisor-panel" id="advisorPanel">
    <div class="advisor-header">
        <span>ğŸ¤–</span>
        <span>AI Market Advisor</span>
        <span id="advisorStatus" class="status-indicator status-warning"></span>
    </div>
    
    <div class="advisor-grid" id="advisorGrid">
        <div class="advisor-item warning">
            <div class="advisor-label">API Status</div>
            <div class="advisor-value" id="apiStatusText">CHECKING...</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Market Condition</div>
            <div class="advisor-value" id="marketCondition">ANALYZING...</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Active Signals</div>
            <div class="advisor-value"><span id="activeSignals">0</span> (<span id="scalpSignals">0</span>âš¡)</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Signal Confidence</div>
            <div class="advisor-value" id="signalConfidence">--%</div>
        </div>
    </div>
    
    <div class="advice-box" id="adviceBox">
        <div class="advice-title">ğŸ’¡ AI Recommendation</div>
        <div class="advice-text" id="adviceText">
            Initializing system... Click "TEST CONNECTION" to verify API connection.
        </div>
    </div>
</div>

<!-- Tab Navigation -->
<div class="tab-container">
    <button class="tab active" id="tabAll">All Signals</button>
    <button class="tab scalp" id="tabScalp">âš¡ Scalp (1m/5m/15m)</button>
    <button class="tab" id="tabSwing">ğŸ“Š Swing (1h/4h)</button>
</div>

<div class="controls">
<!-- Market Selection -->
<div class="market-toggle">
<button class="market-btn active" id="cryptoBtn">ğŸ’ CRYPTO</button>
<button class="market-btn" id="forexBtn">ğŸ’± FOREX & GOLD</button>
</div>

<!-- Symbol Search -->
<div class="control-group" style="margin-bottom:10px">
<label>ğŸ” Search Symbol</label>
<input type="text" id="symbolSearch" placeholder="Type BTC, ETH, SOL...">
<div id="symbolList" style="max-height:200px;overflow-y:auto;background:#16213e;border:2px solid #00d9ff;border-radius:6px;margin-top:5px;display:none"></div>
</div>

<!-- Timeframe Selection -->
<div class="control-group" style="margin-bottom:10px">
<label>â° Select Timeframes</label>
<div class="timeframe-grid">
<button class="tf-btn active" id="tf5m">5 Min</button>
<button class="tf-btn active" id="tf15m">15 Min</button>
<button class="tf-btn active" id="tf1h">1 Hour</button>
<button class="tf-btn" id="tf1m">1 Min</button>
<button class="tf-btn" id="tf4h">4 Hour</button>
</div>
</div>

<div class="control-row">
<div class="control-group">
<label>ğŸ“Š Current Symbol</label>
<div style="display:flex;align-items:center">
<input type="text" id="symbol" value="BTCUSDT" readonly style="background:#1a1a2e;color:#00ff88;border:2px solid #00ff88;font-weight:bold;flex:1">
<button class="refresh-price" id="refreshPriceBtn" title="Refresh price">ğŸ”„</button>
</div>
</div>
<div class="control-group">
<label>ğŸ¯ Signal Quality</label>
<select id="quality">
<option value="40">Easy (40%)</option>
<option value="60" selected>PRO (60%)</option>
<option value="75">Expert (75%)</option>
<option value="65">Scalp (65%)</option>
</select>
</div>
</div>

<button class="btn btn-start" id="startBtn">â–¶ START SCANNING</button>
<button class="btn btn-scalp" id="scalpBtn">âš¡ SCALP SCAN</button>
<button class="btn btn-test" id="testBtn">ğŸ§ª TEST CONNECTION</button>
<button class="btn btn-force" id="forceBtn">âš  FULL SCAN</button>
</div>

<div class="status">
<button class="debug-btn" id="priceDebugBtn">ğŸ”§ Debug Price</button>
<div class="status-grid">
<div>
<div class="status-label">ğŸ’ Price</div>
<div class="status-value price-display" id="price" style="color:#00d9ff;cursor:pointer" title="Double-click to refresh price">--</div>
</div>
<div>
<div class="status-label">ğŸ“ˆ Confidence</div>
<div class="status-value" id="confidence">--</div>
</div>
</div>
<div id="priceSource" style="font-size:10px;color:#888;text-align:center;margin-top:5px">--</div>
</div>

<div class="debug" id="debug">
<div class="debug-line success">ğŸš€ AI Smart Money Scanner v2.1 Ready!</div>
<div class="debug-line">âš¡ Scalp Signals (1m/5m/15m) Enabled</div>
<div class="debug-line">ğŸ“Š Swing Signals (1h/4h) Enabled</div>
<div class="debug-line">ğŸŒ API: <span id="apiUrlDisplay">crypto-trading-system-0zab.onrender.com</span></div>
</div>

<div id="connectionError" class="error-message" style="display:none">
âš ï¸ <strong>Connection Error:</strong> <span id="errorMessage">Unable to connect to API</span>
</div>

<div class="signals" id="signals"></div>

<div class="footer">
<div>Signals: <strong id="signalCount">0</strong> (<span id="scalpCount">0</span>âš¡) | Active TF: <strong id="activeTFs">3</strong></div>
<div style="margin-top:5px;font-size:10px">API: <span style="color:#00ff88" id="apiUrlFooter">crypto-trading-system-0zab.onrender.com</span> | Last Scan: <span id="lastUpdate">--</span></div>
</div>

<script>
// ========== CONFIGURATION ==========
const CONFIG = {
    API_URL: 'https://crypto-trading-system-0zab.onrender.com',
    USE_PROXY: false,
    ENABLE_REAL_DATA: true,
    SCAN_INTERVAL: 30000,
    SCALP_INTERVAL: 15000,
    UPDATE_INTERVAL: 10000
};

// ========== GLOBAL VARIABLES ==========
let isScanning = false;
let isScalping = false;
let signalCount = 0;
let scalpSignalCount = 0;
let scanInterval = null;
let scalpInterval = null;
let allSymbols = [];
let currentMarket = 'crypto';
let activeTimeframes = ['5m', '15m', '1h'];
let scalpTimeframes = ['1m', '5m', '15m'];
let apiStatus = 'checking';
let lastRealPrices = {};
let activeTab = 'all';

// ========== PRICE FORMATTING ==========
function formatPrice(price) {
    if (typeof price !== 'number' || isNaN(price)) return '--';
    
    // Ø¨Ø±Ø§ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©
    if (price < 0.00001) return parseFloat(price.toFixed(8)).toString();
    if (price < 0.001) return parseFloat(price.toFixed(6)).toString();
    
    // Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ ØªØ§ 5 Ø±Ù‚Ù… Ø§Ø¹Ø´Ø§Ø±
    const formatted = price.toFixed(5);
    return parseFloat(formatted).toString();
}

// ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª Ø¯Ø± Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ - Ù†Ø³Ø®Ù‡ Ø³Ø§Ø¯Ù‡ Ùˆ Ø¨Ø¯ÙˆÙ† Ø®Ø·Ø§
function formatPriceWithPrecision(price) {
    if (typeof price !== 'number' || isNaN(price)) return '--';
    
    // Ø§Ú¯Ø± Ù‚ÛŒÙ…Øª Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­ Ø§Ø³ØªØŒ Ø§Ø¹Ø´Ø§Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†
    if (Number.isInteger(price)) {
        return price.toFixed(2);
    }
    
    // Ù†Ù…Ø§ÛŒØ´ ØªØ§ 5 Ø±Ù‚Ù… Ø§Ø¹Ø´Ø§Ø±
    const formatted = price.toFixed(5);
    
    // Ø­Ø°Ù ØµÙØ±Ù‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ Ø§Ù†ØªÙ‡Ø§ Ø¨Ù‡ Ø±ÙˆØ´ Ø³Ø§Ø¯Ù‡
    let result = formatted;
    if (result.includes('.')) {
        // Ø­Ø°Ù ØµÙØ±Ù‡Ø§ÛŒ Ø§Ù†ØªÙ‡Ø§ÛŒ Ø§Ø¹Ø´Ø§Ø±
        while (result.endsWith('0')) {
            result = result.slice(0, -1);
        }
        // Ø§Ú¯Ø± Ù†Ù‚Ø·Ù‡ Ø¢Ø®Ø± Ø´Ø¯ØŒ Ø¢Ù† Ø±Ø§ Ù‡Ù… Ø­Ø°Ù Ú©Ù†
        if (result.endsWith('.')) {
            result = result.slice(0, -1);
        }
    }
    
    return result;
}

// ========== REAL-TIME PRICE FUNCTIONS ==========
async function getDirectBinancePrice(symbol) {
    try {
        let binanceSymbol = symbol.toUpperCase();
        
        if (binanceSymbol === 'XAUUSD') binanceSymbol = 'PAXGUSDT';
        if (binanceSymbol === 'XAUTUSD') binanceSymbol = 'XAUTUSDT';
        if (!binanceSymbol.endsWith('USDT') && !binanceSymbol.includes('USD')) {
            binanceSymbol += 'USDT';
        }
        
        const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${binanceSymbol}`, {
            timeout: 8000
        });
        
        if (response.ok) {
            const data = await response.json();
            const price = parseFloat(data.price);
            
            if (!isNaN(price) && price > 0) {
                lastRealPrices[symbol] = {
                    price: price,
                    timestamp: Date.now(),
                    source: 'Binance',
                    symbol: binanceSymbol
                };
                
                return price;
            }
        }
        
        return null;
        
    } catch (error) {
        console.error(`Binance error for ${symbol}:`, error.message);
        return null;
    }
}

async function getCurrentMarketPrice(symbol, forceRefresh = false) {
    const originalSymbol = symbol.toUpperCase();
    
    if (!forceRefresh && lastRealPrices[originalSymbol] && (Date.now() - lastRealPrices[originalSymbol].timestamp < 30000)) {
        const cached = lastRealPrices[originalSymbol];
        return {
            price: cached.price,
            source: cached.source + ' (Cached)',
            isReal: true,
            originalSymbol: originalSymbol
        };
    }
    
    const binancePrice = await getDirectBinancePrice(originalSymbol);
    
    if (binancePrice !== null) {
        return {
            price: binancePrice,
            source: 'Binance Real-time',
            isReal: true,
            originalSymbol: originalSymbol
        };
    }
    
    // Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡ Ø¨Ø§ Ø§Ø¹Ø´Ø§Ø±
    const defaults = {
        'BTCUSDT': { price: 88271.42, source: 'Market Reference' },
        'ETHUSDT': { price: 3450.12, source: 'Market Reference' },
        'BNBUSDT': { price: 590.54, source: 'Market Reference' },
        'SOLUSDT': { price: 175.98, source: 'Market Reference' },
        'EURUSD': { price: 1.08745, source: 'Forex Reference' },
        'XAUUSD': { price: 2387.65, source: 'Gold Reference' },
        'PAXGUSDT': { price: 2387.65, source: 'Gold Reference' },
        'XRPUSDT': { price: 0.51234, source: 'Market Reference' },
        'ADAUSDT': { price: 0.43210, source: 'Market Reference' },
        'DOGEUSDT': { price: 0.12345, source: 'Market Reference' },
        'SHIBUSDT': { price: 0.00002345, source: 'Market Reference' }
    };
    
    if (defaults[originalSymbol]) {
        const defaultPrice = defaults[originalSymbol];
        return {
            price: defaultPrice.price,
            source: defaultPrice.source,
            isReal: false,
            originalSymbol: originalSymbol
        };
    }
    
    return {
        price: 100.50,
        source: 'General Reference',
        isReal: false,
        originalSymbol: originalSymbol
    };
}

// ========== API HELPER ==========
async function makeRequest(endpoint, data = null) {
    const url = `${CONFIG.API_URL}${endpoint}`;
    
    const options = {
        method: data ? 'POST' : 'GET',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
    };
    
    if (data) {
        options.body = JSON.stringify(data);
    }
    
    try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        return await response.json();
        
    } catch (error) {
        console.error(`API Request failed:`, error);
        throw error;
    }
}

// ========== SCALP SCANNING FUNCTION ==========
async function scanScalp() {
    const symbol = document.getElementById('symbol').value;
    const minConfidence = 0.65;
    
    addLog(`âš¡ Scanning scalp signals for ${symbol}...`, 'scalp');
    
    for (const tf of scalpTimeframes) {
        try {
            const scalpSignal = await makeRequest('/api/scalp-signal', {
                symbol: symbol,
                timeframe: tf
            });
            
            const priceInfo = await getCurrentMarketPrice(symbol);
            
            const scalpData = {
                symbol: scalpSignal.symbol || symbol,
                signal: scalpSignal.signal || 'HOLD',
                confidence: scalpSignal.confidence || 0.5,
                entry_price: priceInfo.price,
                rsi: scalpSignal.rsi || 50,
                sma_20: scalpSignal.sma_20 || priceInfo.price * 0.99,
                volume_ratio: 1.2,
                message: scalpSignal.reason || `Scalp signal on ${tf} timeframe`,
                source: scalpSignal.strategy || 'Scalp Analysis',
                targets: scalpSignal.targets || [priceInfo.price * 1.01, priceInfo.price * 1.02],
                stop_loss: scalpSignal.stop_loss || priceInfo.price * 0.99,
                timestamp: new Date().toISOString(),
                price_source: priceInfo.source,
                is_real_price: priceInfo.isReal,
                type: 'SCALP',
                timeframe: tf,
                risk_level: tf === '1m' ? 'HIGH' : 'MEDIUM'
            };
            
            if (scalpData.confidence >= minConfidence && (scalpData.signal === 'BUY' || scalpData.signal === 'SELL')) {
                addSignal(scalpData, tf, 'SCALPâš¡');
                addLog(`âš¡ [${tf}] ${scalpData.signal} - ${(scalpData.confidence * 100).toFixed(0)}% (RSI: ${scalpData.rsi})`, 'success');
                
                scalpSignalCount++;
                document.getElementById('scalpCount').textContent = scalpSignalCount;
                document.getElementById('scalpSignals').textContent = scalpSignalCount;
            }
            
        } catch (error) {
            console.log(`Scalp scan failed for ${tf}:`, error);
            
            // Fallback data
            const priceInfo = await getCurrentMarketPrice(symbol);
            const randomSignal = Math.random() > 0.5 ? 'BUY' : 'SELL';
            const randomConfidence = 0.65 + Math.random() * 0.3;
            const randomRSI = 30 + Math.random() * 40;
            
            const fallbackData = {
                symbol: symbol,
                signal: randomSignal,
                confidence: randomConfidence,
                entry_price: priceInfo.price,
                rsi: randomRSI,
                sma_20: priceInfo.price * (0.99 + Math.random() * 0.02),
                volume_ratio: 1.2,
                message: `Using mock data (API error)`,
                source: 'Mock Scalp Strategy',
                targets: randomSignal === 'BUY' ? 
                    [priceInfo.price * 1.01, priceInfo.price * 1.02] : 
                    [priceInfo.price * 0.99, priceInfo.price * 0.98],
                stop_loss: randomSignal === 'BUY' ? 
                    priceInfo.price * 0.99 : 
                    priceInfo.price * 1.01,
                timestamp: new Date().toISOString(),
                price_source: priceInfo.source,
                is_real_price: false,
                type: 'SCALP',
                timeframe: tf,
                risk_level: 'MEDIUM'
            };
            
            if (fallbackData.confidence >= minConfidence) {
                addSignal(fallbackData, tf, 'SCALPâš¡');
                addLog(`âš¡ [${tf}] ${fallbackData.signal} - ${(fallbackData.confidence * 100).toFixed(0)}% (RSI: ${fallbackData.rsi.toFixed(1)})`, 'warning');
            }
        }
        
        await sleep(500);
    }
}

// ========== REGULAR SCANNING FUNCTION ==========
async function scanMarket(timeframe) {
    const symbol = document.getElementById('symbol').value;
    const minConfidence = parseInt(document.getElementById('quality').value) / 100;
    
    try {
        addLog(`ğŸ“¡ Scanning ${symbol} (${timeframe})...`, 'info');
        
        const priceInfo = await getCurrentMarketPrice(symbol);
        
        let analysisResult;
        
        try {
            analysisResult = await makeRequest('/api/analyze', {
                symbol: symbol,
                timeframe: timeframe
            });
            
            apiStatus = 'online';
            updateApiStatus('online');
            
        } catch (apiError) {
            apiStatus = 'offline';
            updateApiStatus('offline');
            
            // Fallback analysis
            const randomSignal = Math.random() > 0.5 ? 'BUY' : (Math.random() > 0.5 ? 'SELL' : 'HOLD');
            const randomConfidence = 0.5 + Math.random() * 0.4;
            
            analysisResult = {
                symbol: symbol,
                signal: randomSignal,
                confidence: randomConfidence,
                entry_price: priceInfo.price,
                targets: randomSignal === 'BUY' ? 
                    [priceInfo.price * 1.02, priceInfo.price * 1.05] : 
                    randomSignal === 'SELL' ? 
                    [priceInfo.price * 0.98, priceInfo.price * 0.95] : 
                    [],
                stop_loss: randomSignal === 'BUY' ? 
                    priceInfo.price * 0.98 : 
                    randomSignal === 'SELL' ? 
                    priceInfo.price * 1.02 : 
                    priceInfo.price,
                strategy: 'Fallback Analysis'
            };
        }
        
        const safeData = {
            symbol: analysisResult.symbol || symbol,
            signal: analysisResult.signal || 'HOLD',
            confidence: analysisResult.confidence || 0.5,
            entry_price: analysisResult.entry_price || priceInfo.price,
            rsi: analysisResult.rsi || 50,
            volume_ratio: analysisResult.volume_ratio || 1,
            message: analysisResult.recommendation || analysisResult.message || 'Analysis completed',
            source: analysisResult.strategy || 'API Analysis',
            targets: Array.isArray(analysisResult.targets) ? analysisResult.targets : 
                   analysisResult.signal === 'BUY' ? [priceInfo.price * 1.02, priceInfo.price * 1.05] :
                   analysisResult.signal === 'SELL' ? [priceInfo.price * 0.98, priceInfo.price * 0.95] : [],
            stop_loss: analysisResult.stop_loss || 
                     (analysisResult.signal === 'BUY' ? priceInfo.price * 0.98 :
                      analysisResult.signal === 'SELL' ? priceInfo.price * 1.02 : priceInfo.price),
            timestamp: new Date().toISOString(),
            price_source: priceInfo.source,
            is_real_price: priceInfo.isReal,
            type: timeframe === '1h' || timeframe === '4h' ? 'SWING' : 'REGULAR',
            timeframe: timeframe,
            risk_level: 'MEDIUM'
        };
        
        updateStatus(safeData);
        
        if (safeData.confidence >= minConfidence && (safeData.signal === 'BUY' || safeData.signal === 'SELL')) {
            const quality = safeData.confidence >= 0.85 ? 'ULTRAğŸ”¥' :
                          safeData.confidence >= 0.70 ? 'HIGHğŸ”¥' :
                          safeData.confidence >= minConfidence ? 'GOOD' : 'WEAK';
            
            addSignal(safeData, timeframe, quality);
        }
        
        return safeData;
        
    } catch (error) {
        addLog(`âŒ [${timeframe}] Error: ${error.message}`, 'error');
        return null;
    }
}

// ========== UI UPDATE FUNCTIONS ==========
function updateStatus(data) {
    const priceElement = document.getElementById('price');
    const priceSourceElement = document.getElementById('priceSource');
    const priceValue = formatPriceWithPrecision(data.entry_price);
    
    if (data.is_real_price) {
        priceElement.innerHTML = `$${priceValue} <span style="color:#00ff88; font-size:12px">âœ…</span>`;
        priceSourceElement.textContent = `Source: ${data.price_source}`;
        priceSourceElement.style.color = '#00ff88';
    } else {
        priceElement.textContent = `$${priceValue}`;
        priceSourceElement.textContent = `Source: ${data.price_source} (Reference)`;
        priceSourceElement.style.color = '#ff9900';
    }
    
    document.getElementById('confidence').textContent = (data.confidence * 100).toFixed(0) + '%';
    document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
    document.getElementById('signalConfidence').textContent = (data.confidence * 100).toFixed(0) + '%';
    
    updateMarketCondition(data);
}

function updateMarketCondition(data) {
    const conditionElement = document.getElementById('marketCondition');
    const activeSignalsElement = document.getElementById('activeSignals');
    
    if (data.signal === 'BUY' && data.confidence > 0.7) {
        conditionElement.textContent = 'BULLISH';
        conditionElement.parentElement.className = 'advisor-item good';
    } else if (data.signal === 'SELL' && data.confidence > 0.7) {
        conditionElement.textContent = 'BEARISH';
        conditionElement.parentElement.className = 'advisor-item danger';
    } else {
        conditionElement.textContent = 'NEUTRAL';
        conditionElement.parentElement.className = 'advisor-item warning';
    }
    
    activeSignalsElement.textContent = signalCount;
}

function updateApiStatus(status) {
    const statusElement = document.getElementById('apiStatusText');
    const indicator = document.getElementById('advisorStatus');
    const errorDiv = document.getElementById('connectionError');
    const adviceText = document.getElementById('adviceText');
    
    apiStatus = status;
    
    if (status === 'online') {
        statusElement.textContent = 'ONLINE';
        statusElement.parentElement.className = 'advisor-item good';
        indicator.className = 'status-indicator status-online';
        errorDiv.style.display = 'none';
        adviceText.innerHTML = 'âœ… API connection established. Scalp & Swing analysis active.';
    } else if (status === 'offline') {
        statusElement.textContent = 'OFFLINE';
        statusElement.parentElement.className = 'advisor-item danger';
        indicator.className = 'status-indicator status-offline';
        errorDiv.style.display = 'block';
        document.getElementById('errorMessage').textContent = 'Cannot connect to API server';
        adviceText.innerHTML = 'âš ï¸ API connection lost. Using fallback analysis.';
    } else {
        statusElement.textContent = 'CHECKING...';
        statusElement.parentElement.className = 'advisor-item warning';
        indicator.className = 'status-indicator status-warning';
        adviceText.innerHTML = 'Checking API connection...';
    }
}

function addSignal(data, timeframe, quality) {
    signalCount++;
    document.getElementById('signalCount').textContent = signalCount;
    document.getElementById('activeSignals').textContent = signalCount;
    
    const tfClass = timeframe === '1m' ? 'tf-1m' :
                   timeframe === '5m' ? 'tf-5m' :
                   timeframe === '15m' ? 'tf-15m' :
                   timeframe === '1h' ? 'tf-1h' : 'tf-4h';
    
    const tfLabel = timeframe === '1m' ? '1 Min' :
                   timeframe === '5m' ? '5 Min' :
                   timeframe === '15m' ? '15 Min' :
                   timeframe === '1h' ? '1 Hour' : '4 Hour';
    
    const type = data.signal.toLowerCase();
    const isScalp = data.type === 'SCALP';
    const signalClass = isScalp ? 'scalp' : type;
    
    let targetsHtml = '<div style="color:#888">No targets specified</div>';
    if (data.targets && data.targets.length > 0) {
        targetsHtml = data.targets.map((target, index) => {
            const gainPercent = ((target / data.entry_price - 1) * 100).toFixed(2);
            let sign = '';
            let color = '#00ff88';
            
            if (data.signal === 'BUY') {
                // Ø¨Ø±Ø§ÛŒ BUY: ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ Ø¨Ø§Ù„Ø§ØªØ± Ù‡Ø³ØªÙ†Ø¯ (Ù…Ø«Ø¨Øª)
                sign = gainPercent >= 0 ? '+' : '';
                color = '#00ff88';
            } else if (data.signal === 'SELL') {
                // Ø¨Ø±Ø§ÛŒ SELL: ØªØ§Ø±Ú¯Øªâ€ŒÙ‡Ø§ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ù‡Ø³ØªÙ†Ø¯ (Ù…Ù†ÙÛŒ)
                color = '#ff4444';
                sign = gainPercent < 0 ? '-' : '';
            }
            
            // Ù†Ù…Ø§ÛŒØ´ Ù…Ù‚Ø¯Ø§Ø± Ù…Ø·Ù„Ù‚ Ø¯Ø±ØµØ¯
            const percentDisplay = Math.abs(gainPercent);
            
            return `<div>ğŸ¯ TP${index + 1}: $${formatPriceWithPrecision(target)} <span class="percent-${gainPercent >= 0 ? 'positive' : 'negative'}" style="color:${color}">(${sign}${percentDisplay}%)</span></div>`;
        }).join('');
    }
    
    let stopLossHtml = '';
    if (data.stop_loss > 0) {
        const lossPercent = ((data.stop_loss / data.entry_price - 1) * 100).toFixed(2);
        let sign = '';
        let color = '#ff4444';
        
        if (data.signal === 'BUY') {
            // Ø¨Ø±Ø§ÛŒ BUY: Ø§Ø³ØªØ§Ù¾ Ù„Ø§Ø³ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø³Øª (Ù…Ù†ÙÛŒ)
            color = '#ff4444';
            sign = lossPercent < 0 ? '-' : '';
        } else if (data.signal === 'SELL') {
            // Ø¨Ø±Ø§ÛŒ SELL: Ø§Ø³ØªØ§Ù¾ Ù„Ø§Ø³ Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø³Øª (Ù…Ø«Ø¨Øª)
            color = '#ff9900';
            sign = lossPercent >= 0 ? '+' : '';
        }
        
        // Ù†Ù…Ø§ÛŒØ´ Ù…Ù‚Ø¯Ø§Ø± Ù…Ø·Ù„Ù‚ Ø¯Ø±ØµØ¯
        const percentDisplay = Math.abs(lossPercent);
        
        stopLossHtml = `<div>ğŸ›‘ Stop Loss: $${formatPriceWithPrecision(data.stop_loss)} <span class="percent-${lossPercent >= 0 ? 'warning' : 'negative'}" style="color:${color}">(${sign}${percentDisplay}%)</span></div>`;
    }
    
    // RSI indicator
    let rsiHtml = '';
    if (data.rsi) {
        const rsiClass = data.rsi < 30 ? 'rsi-oversold' : data.rsi > 70 ? 'rsi-overbought' : 'rsi-neutral';
        rsiHtml = `<span class="rsi-indicator ${rsiClass}">RSI: ${data.rsi.toFixed(1)}</span>`;
    }
    
    const realPriceBadge = data.is_real_price ? 
        `<span style="color:#00ff88; font-size:10px; margin-left:5px">âœ… Live</span>` : 
        `<span style="color:#ff9900; font-size:10px; margin-left:5px">âš ï¸ Ref</span>`;
    
    const scalpBadge = isScalp ? `<span class="scalp-indicator"></span>` : '';
    
    const card = `
        <div class="signal-card ${signalClass}" data-type="${data.type}" data-timeframe="${timeframe}">
            <div class="signal-header">
                <div class="signal-type">
                    ${scalpBadge}${type === 'buy' ? 'ğŸŸ¢ BUY' : type === 'sell' ? 'ğŸ”´ SELL' : 'ğŸŸ¡ HOLD'} 
                    <span class="tf-indicator ${tfClass}">${tfLabel}</span>
                    ${rsiHtml}
                </div>
                <div class="signal-badge" style="background: ${isScalp ? 'rgba(255,0,255,0.2)' : type === 'buy' ? 'rgba(0,255,136,0.2)' : type === 'sell' ? 'rgba(255,68,68,0.2)' : 'rgba(255,255,0,0.2)'}">
                    ${isScalp ? 'âš¡ ' : ''}${quality} ${realPriceBadge}
                </div>
            </div>
            <div class="signal-details">
                <div><strong>${data.symbol}</strong> â€¢ ${data.source} ${data.risk_level ? `<span style="color:#ff9900;font-size:10px">(${data.risk_level} Risk)</span>` : ''}</div>
                <div class="price-display">ğŸ’° Entry: <strong>$${formatPriceWithPrecision(data.entry_price)}</strong> ${data.is_real_price ? 'âœ…' : 'âš ï¸'}</div>
                <div>ğŸ“Š Confidence: <strong>${(data.confidence * 100).toFixed(1)}%</strong></div>
                ${data.sma_20 ? `<div class="price-display">ğŸ“ˆ SMA20: <strong>$${formatPriceWithPrecision(data.sma_20)}</strong></div>` : ''}
                <div>ğŸ’¡ ${data.message}</div>
                <div class="targets">
                    <strong>ğŸ¯ Targets:</strong>
                    ${targetsHtml}
                    ${stopLossHtml}
                </div>
                <div style="margin-top:10px;color:#888;font-size:11px">
                    â° ${new Date(data.timestamp).toLocaleTimeString()} â€¢ ${data.price_source} â€¢ ${data.type}
                </div>
            </div>
        </div>`;
    
    const container = document.getElementById('signals');
    
    // Filter based on active tab
    if (activeTab === 'all' || 
        (activeTab === 'scalp' && isScalp) || 
        (activeTab === 'swing' && data.type === 'SWING')) {
        container.insertAdjacentHTML('afterbegin', card);
    }
    
    // Keep only last 15 signals
    if (container.children.length > 15) {
        container.removeChild(container.lastChild);
    }
    
    // Update signal counters
    updateSignalCounters();
}

function updateSignalCounters() {
    const signals = document.querySelectorAll('.signal-card');
    let scalpCount = 0;
    let swingCount = 0;
    let regularCount = 0;
    
    signals.forEach(signal => {
        const type = signal.dataset.type;
        if (type === 'SCALP') scalpCount++;
        else if (type === 'SWING') swingCount++;
        else regularCount++;
    });
    
    document.getElementById('scalpCount').textContent = scalpCount;
    document.getElementById('scalpSignals').textContent = scalpCount;
}

// ========== TAB MANAGEMENT ==========
function setupTabs() {
    document.getElementById('tabAll').addEventListener('click', () => switchTab('all'));
    document.getElementById('tabScalp').addEventListener('click', () => switchTab('scalp'));
    document.getElementById('tabSwing').addEventListener('click', () => switchTab('swing'));
}

function switchTab(tab) {
    activeTab = tab;
    
    // Update tab buttons
    document.getElementById('tabAll').classList.toggle('active', tab === 'all');
    document.getElementById('tabScalp').classList.toggle('active', tab === 'scalp');
    document.getElementById('tabSwing').classList.toggle('active', tab === 'swing');
    
    // Filter signals
    const signals = document.querySelectorAll('.signal-card');
    signals.forEach(signal => {
        const signalType = signal.dataset.type;
        const timeframe = signal.dataset.timeframe;
        
        let shouldShow = false;
        
        if (tab === 'all') {
            shouldShow = true;
        } else if (tab === 'scalp') {
            shouldShow = signalType === 'SCALP';
        } else if (tab === 'swing') {
            shouldShow = signalType === 'SWING';
        }
        
        signal.style.display = shouldShow ? 'block' : 'none';
    });
    
    addLog(`ğŸ“Š Switched to ${tab.toUpperCase()} tab`, 'info');
}

// ========== SYMBOL MANAGEMENT ==========
function loadAllSymbols() {
    allSymbols = [
        'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT',
        'AVAXUSDT', 'DOTUSDT', 'DOGEUSDT', 'MATICUSDT', 'SHIBUSDT', 'LTCUSDT',
        'UNIUSDT', 'LINKUSDT', 'ATOMUSDT', 'ETCUSDT', 'XLMUSDT', 'ALGOUSDT',
        'VETUSDT', 'FILUSDT', 'TRXUSDT', 'EOSUSDT', 'AAVEUSDT', 'XTZUSDT',
        'SANDUSDT', 'MANAUSDT', 'GALAUSDT', 'APEUSDT', 'CHZUSDT', 'ENJUSDT',
        'COMPUSDT', 'MKRUSDT', 'SNXUSDT', 'CRVUSDT', '1INCHUSDT',
        'NEARUSDT', 'FTMUSDT', 'ICPUSDT', 'HBARUSDT',
        'PEPEUSDT', 'FLOKIUSDT', 'BONKUSDT',
        'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
        'EURGBP', 'EURJPY', 'GBPJPY', 'AUDJPY', 'XAUUSD', 'XAGUSD',
        'PAXGUSDT', 'XAUTUSDT'
    ].sort();
    
    addLog(`âœ… ${allSymbols.length} symbols loaded`, 'success');
}

function handleSearch(e) {
    const query = e.target.value.toUpperCase();
    const list = document.getElementById('symbolList');
    
    if (!query.trim()) {
        list.style.display = 'none';
        return;
    }
    
    const filtered = allSymbols
        .filter(s => s.includes(query))
        .slice(0, 10);
    
    if (filtered.length > 0) {
        list.innerHTML = filtered.map(symbol => {
            const displayName = symbol.replace('USDT', '').replace('USD', '');
            return `<div class="symbol-list-item" data-symbol="${symbol}">
                      ${displayName} <span style="color:#888;font-size:11px">(${symbol})</span>
                    </div>`;
        }).join('');
        
        list.querySelectorAll('.symbol-list-item').forEach(item => {
            item.addEventListener('click', function() {
                selectSymbol(this.dataset.symbol);
            });
        });
        
        list.style.display = 'block';
    } else {
        list.innerHTML = '<div style="padding:10px;color:#888">No symbols found</div>';
        list.style.display = 'block';
    }
}

async function selectSymbol(symbol) {
    document.getElementById('symbol').value = symbol;
    document.getElementById('symbolSearch').value = '';
    document.getElementById('symbolList').style.display = 'none';
    addLog(`âœ… Selected symbol: ${symbol}`, 'success');
    
    if (isForexGoldSymbol(symbol)) {
        switchMarket('forex');
    } else {
        switchMarket('crypto');
    }
    
    const priceInfo = await getCurrentMarketPrice(symbol, true);
    const formattedPrice = formatPriceWithPrecision(priceInfo.price);
    document.getElementById('price').textContent = '$' + formattedPrice;
    document.getElementById('priceSource').textContent = `Source: ${priceInfo.source}`;
    document.getElementById('priceSource').style.color = priceInfo.isReal ? '#00ff88' : '#ff9900';
    addLog(`ğŸ’° ${symbol} price: $${formattedPrice} (${priceInfo.source})`, 'info');
}

function isForexGoldSymbol(symbol) {
    const forexGoldSymbols = [
        'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
        'EURGBP', 'EURJPY', 'GBPJPY', 'AUDJPY', 'XAUUSD', 'XAGUSD', 'PAXG', 'XAUT'
    ];
    
    return forexGoldSymbols.some(forexSymbol => 
        symbol.includes(forexSymbol) || forexSymbol.includes(symbol)
    );
}

// ========== EVENT HANDLERS ==========
function setupEventListeners() {
    document.getElementById('cryptoBtn').addEventListener('click', () => switchMarket('crypto'));
    document.getElementById('forexBtn').addEventListener('click', () => switchMarket('forex'));
    
    document.getElementById('tf1m').addEventListener('click', () => toggleTimeframe('1m'));
    document.getElementById('tf5m').addEventListener('click', () => toggleTimeframe('5m'));
    document.getElementById('tf15m').addEventListener('click', () => toggleTimeframe('15m'));
    document.getElementById('tf1h').addEventListener('click', () => toggleTimeframe('1h'));
    document.getElementById('tf4h').addEventListener('click', () => toggleTimeframe('4h'));
    
    document.getElementById('startBtn').addEventListener('click', toggleScanning);
    document.getElementById('scalpBtn').addEventListener('click', toggleScalping);
    document.getElementById('testBtn').addEventListener('click', testConnection);
    document.getElementById('forceBtn').addEventListener('click', forceScan);
    document.getElementById('priceDebugBtn').addEventListener('click', debugPrice);
    document.getElementById('refreshPriceBtn').addEventListener('click', refreshCurrentPrice);
    
    document.getElementById('symbolSearch').addEventListener('input', handleSearch);
    
    document.getElementById('price').addEventListener('dblclick', refreshCurrentPrice);
    
    setupTabs();
}

async function refreshCurrentPrice() {
    const symbol = document.getElementById('symbol').value;
    addLog(`ğŸ”„ Refreshing price for ${symbol}...`, 'info');
    
    try {
        const priceInfo = await getCurrentMarketPrice(symbol, true);
        const formattedPrice = formatPriceWithPrecision(priceInfo.price);
        
        if (priceInfo.isReal) {
            document.getElementById('price').innerHTML = `$${formattedPrice} <span style="color:#00ff88; font-size:12px">âœ…</span>`;
            document.getElementById('priceSource').textContent = `Source: ${priceInfo.source} (Live)`;
            document.getElementById('priceSource').style.color = '#00ff88';
        } else {
            document.getElementById('price').textContent = '$' + formattedPrice;
            document.getElementById('priceSource').textContent = `Source: ${priceInfo.source} (Reference)`;
            document.getElementById('priceSource').style.color = '#ff9900';
        }
        
    } catch (error) {
        addLog(`âŒ Price refresh failed: ${error.message}`, 'error');
    }
}

async function debugPrice() {
    const symbol = document.getElementById('symbol').value;
    const priceInfo = await getCurrentMarketPrice(symbol, true);
    
    const debugInfo = `Price Debug for ${symbol}:\n\n` +
          `Formatted Price: $${formatPriceWithPrecision(priceInfo.price)}\n` +
          `Raw Price: ${priceInfo.price}\n` +
          `Source: ${priceInfo.source}\n` +
          `Real Price: ${priceInfo.isReal ? 'âœ… Yes' : 'âŒ No'}\n` +
          `Market: ${currentMarket}\n\n` +
          `Cached: ${lastRealPrices[symbol] ? 'Yes' : 'No'}`;
    
    alert(debugInfo);
}

function toggleScanning() {
    const btn = document.getElementById('startBtn');
    
    if (!isScanning) {
        isScanning = true;
        btn.textContent = 'â¸ STOP SCANNING';
        btn.classList.add('active');
        addLog('ğŸš€ Regular scanning started', 'success');
        
        forceScan();
        scanInterval = setInterval(() => {
            if (isScanning) forceScan();
        }, CONFIG.SCAN_INTERVAL);
        
    } else {
        isScanning = false;
        btn.textContent = 'â–¶ START SCANNING';
        btn.classList.remove('active');
        addLog('ğŸ›‘ Regular scanning stopped', 'error');
        
        if (scanInterval) {
            clearInterval(scanInterval);
            scanInterval = null;
        }
    }
}

function toggleScalping() {
    const btn = document.getElementById('scalpBtn');
    
    if (!isScalping) {
        isScalping = true;
        btn.textContent = 'â¸ STOP SCALP';
        btn.classList.add('active');
        addLog('âš¡ Scalp scanning started', 'success');
        
        scanScalp();
        scalpInterval = setInterval(() => {
            if (isScalping) scanScalp();
        }, CONFIG.SCALP_INTERVAL);
        
    } else {
        isScalping = false;
        btn.textContent = 'âš¡ SCALP SCAN';
        btn.classList.remove('active');
        addLog('ğŸ›‘ Scalp scanning stopped', 'error');
        
        if (scalpInterval) {
            clearInterval(scalpInterval);
            scalpInterval = null;
        }
    }
}

async function forceScan() {
    if (activeTimeframes.length === 0) {
        addLog('âš ï¸ Please select at least one timeframe', 'warning');
        return;
    }
    
    const symbol = document.getElementById('symbol').value;
    addLog(`ğŸ” Full scan for ${symbol}...`, 'info');
    
    // Regular timeframes
    for (const tf of activeTimeframes) {
        await scanMarket(tf);
        await sleep(1000);
    }
    
    addLog('âœ… Full scan completed', 'success');
}

async function testConnection() {
    addLog('ğŸ§ª Testing connection and features...', 'warning');
    updateApiStatus('checking');
    
    try {
        // Test API health
        try {
            const health = await makeRequest('/api/health');
            addLog(`âœ… API Health: ${health.status}`, 'success');
            addLog(`ğŸ“Š Version: ${health.version}`, 'info');
            updateApiStatus('online');
            
            if (health.scalp_support && health.scalp_support.enabled) {
                addLog(`âš¡ Scalp support: ENABLED (${health.scalp_support.timeframes.join('/')})`, 'success');
            }
            
        } catch (e) {
            addLog(`âŒ Health endpoint: ${e.message}`, 'error');
            updateApiStatus('offline');
        }
        
        // Test price
        try {
            const priceInfo = await getCurrentMarketPrice('BTCUSDT', true);
            addLog(`ğŸ’° BTC Price: $${formatPriceWithPrecision(priceInfo.price)} (${priceInfo.source})`, 'success');
        } catch (e) {
            addLog(`âŒ Price check: ${e.message}`, 'error');
        }
        
        // Test scalp signal
        try {
            const scalpSignal = await makeRequest('/api/scalp-signal', {
                symbol: 'BTCUSDT',
                timeframe: '5m'
            });
            
            addLog(`âš¡ Scalp test: ${scalpSignal.signal} - ${(scalpSignal.confidence * 100).toFixed(0)}% (RSI: ${scalpSignal.rsi})`, 'success');
            
            // Create test scalp signal
            const priceInfo = await getCurrentMarketPrice('BTCUSDT');
            const testData = {
                symbol: 'BTCUSDT (Scalp Test)',
                signal: scalpSignal.signal,
                confidence: scalpSignal.confidence,
                entry_price: priceInfo.price,
                rsi: scalpSignal.rsi,
                sma_20: scalpSignal.sma_20,
                volume_ratio: 1.5,
                message: `Scalp API test: ${scalpSignal.reason}`,
                source: 'Scalp Test',
                targets: scalpSignal.targets || [],
                stop_loss: scalpSignal.stop_loss || 0,
                timestamp: new Date().toISOString(),
                price_source: priceInfo.source,
                is_real_price: priceInfo.isReal,
                type: 'SCALP',
                timeframe: '5m',
                risk_level: 'MEDIUM'
            };
            
            addSignal(testData, '5m', 'TESTâš¡');
            
        } catch (e) {
            addLog(`âš ï¸ Scalp test: ${e.message}`, 'warning');
        }
        
        // Test regular analysis
        try {
            const analysis = await makeRequest('/api/analyze', {
                symbol: 'BTCUSDT',
                timeframe: '5m'
            });
            
            addLog(`ğŸ“Š Analysis test: ${analysis.signal} - ${(analysis.confidence * 100).toFixed(0)}%`, 'success');
            
        } catch (e) {
            addLog(`âš ï¸ Analysis test: ${e.message}`, 'warning');
        }
        
    } catch (error) {
        addLog(`âŒ Connection test failed: ${error.message}`, 'error');
        updateApiStatus('offline');
    }
}

function switchMarket(market) {
    currentMarket = market;
    document.getElementById('cryptoBtn').classList.toggle('active', market === 'crypto');
    document.getElementById('forexBtn').classList.toggle('active', market === 'forex');
    
    const placeholder = market === 'crypto' 
        ? 'Search Crypto (BTC, ETH, SOL...)' 
        : 'Search Forex/Gold (EURUSD, XAUUSD, PAXG...)';
    
    document.getElementById('symbolSearch').placeholder = placeholder;
    addLog(`ğŸŒ Switched to ${market.toUpperCase()} market`, 'info');
    
    const currentSymbol = document.getElementById('symbol').value;
    if (market === 'forex' && !isForexGoldSymbol(currentSymbol)) {
        selectSymbol('EURUSD');
    } else if (market === 'crypto' && isForexGoldSymbol(currentSymbol)) {
        selectSymbol('BTCUSDT');
    }
}

function toggleTimeframe(tf) {
    const btn = document.getElementById(`tf${tf.replace('m', '').replace('h', '')}`);
    const index = activeTimeframes.indexOf(tf);
    
    if (index > -1) {
        if (activeTimeframes.length > 1) {
            activeTimeframes.splice(index, 1);
            btn.classList.remove('active');
            addLog(`âŒ Disabled ${tf} timeframe`, 'warning');
        } else {
            addLog('âš ï¸ At least one timeframe must be active', 'error');
            return;
        }
    } else {
        activeTimeframes.push(tf);
        btn.classList.add('active');
        addLog(`âœ… Enabled ${tf} timeframe`, 'success');
    }
    
    document.getElementById('activeTFs').textContent = activeTimeframes.length;
}

// ========== UTILITY FUNCTIONS ==========
function addLog(message, type = 'info') {
    const debug = document.getElementById('debug');
    const time = new Date().toLocaleTimeString();
    const icon = type === 'success' ? 'âœ…' : 
                 type === 'error' ? 'âŒ' : 
                 type === 'warning' ? 'âš ï¸' : 
                 type === 'scalp' ? 'âš¡' : 'â„¹ï¸';
    
    const line = `<div class="debug-line ${type}">${icon} [${time}] ${message}</div>`;
    
    debug.insertAdjacentHTML('afterbegin', line);
    
    if (debug.children.length > 25) {
        debug.removeChild(debug.lastChild);
    }
    
    console.log(`[${type.toUpperCase()}] ${message}`);
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// ========== INITIALIZATION ==========
document.addEventListener('DOMContentLoaded', function() {
    console.log('ğŸš€ AI Smart Money Scanner v2.1 loaded');
    console.log('âš¡ Scalp scanning enabled');
    console.log('ğŸ“Š Swing analysis enabled');
    
    document.getElementById('apiUrlDisplay').textContent = CONFIG.API_URL.replace('https://', '');
    document.getElementById('apiUrlFooter').textContent = CONFIG.API_URL.replace('https://', '');
    
    loadAllSymbols();
    setupEventListeners();
    
    addLog('ğŸš€ AI Smart Money Scanner v2.1 Initialized', 'success');
    addLog(`ğŸ”— API: ${CONFIG.API_URL}`, 'info');
    addLog('âš¡ Scalp Signals (1m/5m/15m) Enabled', 'scalp');
    addLog('ğŸ“Š Swing Analysis (1h/4h) Enabled', 'info');
    
    // Get initial price
    getCurrentMarketPrice('BTCUSDT', true).then(priceInfo => {
        const formattedPrice = formatPriceWithPrecision(priceInfo.price);
        
        if (priceInfo.isReal) {
            document.getElementById('price').innerHTML = `$${formattedPrice} <span style="color:#00ff88; font-size:12px">âœ…</span>`;
            document.getElementById('priceSource').textContent = `Source: ${priceInfo.source}`;
            document.getElementById('priceSource').style.color = '#00ff88';
            addLog(`ğŸ’° Current BTC: $${formattedPrice} (Live)`, 'success');
        } else {
            document.getElementById('price').textContent = '$' + formattedPrice;
            document.getElementById('priceSource').textContent = `Source: ${priceInfo.source} (Reference)`;
            document.getElementById('priceSource').style.color = '#ff9900';
            addLog(`ğŸ’° Current BTC: $${formattedPrice} (Reference)`, 'warning');
        }
    });
    
    // Auto-update price
    setInterval(() => {
        const symbol = document.getElementById('symbol').value;
        getCurrentMarketPrice(symbol).then(priceInfo => {
            const priceElement = document.getElementById('price');
            const priceSourceElement = document.getElementById('priceSource');
            
            if (priceInfo.isReal) {
                priceElement.innerHTML = `$${formatPriceWithPrecision(priceInfo.price)} <span style="color:#00ff88; font-size:12px">âœ…</span>`;
                priceSourceElement.textContent = `Source: ${priceInfo.source}`;
                priceSourceElement.style.color = '#00ff88';
            } else {
                priceElement.textContent = '$' + formatPriceWithPrecision(priceInfo.price);
                priceSourceElement.textContent = `Source: ${priceInfo.source} (Reference)`;
                priceSourceElement.style.color = '#ff9900';
            }
            
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        });
    }, CONFIG.UPDATE_INTERVAL);
    
    // Auto test after 3 seconds
    setTimeout(() => {
        testConnection();
    }, 3000);
});
</script>
</body>
</html>