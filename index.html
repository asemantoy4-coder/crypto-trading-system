<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>AI Smart Money Scanner - Scalp & Swing Signals</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,sans-serif;background:#1a1a2e;color:#fff;min-height:100vh;padding:10px}
.header{background:#16213e;padding:15px;text-align:center;border-radius:10px;margin-bottom:10px}
.header h1{font-size:20px;color:#00d9ff}

/* Advisor Panel Styles */
.advisor-panel {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 2px solid #00d9ff;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 8px 32px rgba(0, 217, 255, 0.1);
}
.advisor-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    color: #00d9ff;
    font-size: 18px;
    font-weight: bold;
}
.advisor-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 15px;
}
.advisor-item {
    background: rgba(0, 0, 0, 0.3);
    padding: 12px;
    border-radius: 8px;
    border-left: 4px solid;
}
.advisor-item.good { border-left-color: #00ff88; }
.advisor-item.warning { border-left-color: #ff9900; }
.advisor-item.danger { border-left-color: #ff4444; }
.advisor-label {
    font-size: 12px;
    color: #888;
    margin-bottom: 5px;
}
.advisor-value {
    font-size: 16px;
    font-weight: bold;
}
.advice-box {
    background: rgba(0, 217, 255, 0.1);
    border-radius: 8px;
    padding: 15px;
    margin-top: 15px;
    border: 1px solid rgba(0, 217, 255, 0.3);
}
.advice-title {
    color: #00ff88;
    font-weight: bold;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
}
.advice-text {
    color: #fff;
    line-height: 1.5;
    font-size: 14px;
}
.status-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-left: 8px;
}
.status-online { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
.status-offline { background: #ff4444; }
.status-warning { background: #ff9900; }

/* Existing Styles */
.controls{background:#0f3460;padding:15px;border-radius:10px;margin-bottom:10px}
.control-row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px}
.control-group{display:flex;flex-direction:column;gap:5px}
.control-group label{font-size:11px;color:#888}
select,input[type="text"]{background:#16213e;color:#fff;border:2px solid #00d9ff;padding:10px;border-radius:6px;font-size:14px;width:100%}
.btn{border:none;padding:15px;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer;width:100%;margin-bottom:10px;transition:all 0.3s}
.btn-start{background:#00d9ff;color:#000}
.btn-start.active{background:#ff4444;color:#fff}
.btn-test{background:#ff9900;color:#000}
.btn-force{background:#00ff88;color:#000}
.btn-scalp{background:#ff00ff;color:#000}
.market-toggle{display:flex;gap:10px;margin-bottom:10px}
.market-btn{flex:1;padding:12px;border-radius:8px;border:2px solid #555;background:#16213e;color:#fff;cursor:pointer;font-weight:bold;transition:all 0.3s}
.market-btn.active{background:#00d9ff;color:#000;border-color:#00d9ff}
.timeframe-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px}
.tf-btn{padding:10px;border-radius:6px;border:2px solid #555;background:#16213e;color:#fff;cursor:pointer;font-size:12px;font-weight:bold;transition:all 0.3s}
.tf-btn.active{border-color:#00d9ff;background:#00d9ff;color:#000}
.status{background:#0f3460;padding:15px;border-radius:10px;margin-bottom:10px;position:relative}
.status-grid{display:grid;grid-template-columns:1fr 1fr;gap:15px;text-align:center}
.status-label{font-size:11px;color:#888;margin-bottom:5px}
.status-value{font-size:20px;font-weight:bold}
.debug{background:#16213e;padding:15px;border-radius:10px;margin-bottom:10px;max-height:200px;overflow-y:auto;font-size:11px;line-height:1.6}
.debug-line{margin:3px 0;padding:3px;border-left:3px solid #00d9ff}
.debug-line.success{border-left-color:#00ff88}
.debug-line.error{border-left-color:#ff4444}
.debug-line.warning{border-left-color:#ff9900}
.debug-line.scalp{border-left-color:#ff00ff}
.signals{margin-top:10px}
.signal-card{background:#16213e;border-left:5px solid #00ff88;padding:15px;border-radius:10px;margin-bottom:15px;animation:slideIn 0.4s ease}
@keyframes slideIn{from{opacity:0;transform:translateX(-20px)}to{opacity:1;transform:translateX(0)}}
.signal-card.sell{border-left-color:#ff4444}
.signal-card.hold{border-left-color:#ff9900}
.signal-card.scalp{border-left:5px solid #ff00ff}
.signal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.signal-type{font-size:20px;font-weight:bold}
.signal-badge{font-size:10px;padding:5px 10px;border-radius:5px;background:rgba(0,255,136,0.2)}
.signal-details{font-size:13px;line-height:1.8}
.signal-details div{margin:5px 0}
.targets{margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.2);background:rgba(0,0,0,0.2);padding:10px;border-radius:5px}
.tf-indicator{display:inline-block;padding:3px 8px;border-radius:4px;font-size:10px;font-weight:bold;margin-left:5px}
.tf-1m{background:#ff00ff;color:#fff}
.tf-5m{background:#ff6b6b;color:#fff}
.tf-15m{background:#ffd93d;color:#000}
.tf-1h{background:#6bcf7f;color:#fff}
.tf-4h{background:#4d96ff;color:#fff}
.footer{text-align:center;padding:15px;font-size:12px;color:#888}
.symbol-list-item{padding:10px;cursor:pointer;border-bottom:1px solid #0f3460;color:#fff;transition:background 0.2s}
.symbol-list-item:hover{background:#0f3460}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª */
.price-display {
    font-family: 'Courier New', monospace;
    letter-spacing: 0.5px;
}
.price-tiny {
    font-size: 12px;
    opacity: 0.9;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ ÙØ§Ø±Ú©Ø³ Ùˆ Ø·Ù„Ø§ */
.forex-symbol { color: #ffd700; }
.gold-symbol { color: #ffd700; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø®Ø·Ø§ */
.error-message {
    background: rgba(255, 68, 68, 0.2);
    border: 1px solid #ff4444;
    padding: 10px;
    border-radius: 8px;
    margin: 10px 0;
    color: #ff8888;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø¯Ú©Ù…Ù‡ Ø¯ÛŒØ¨Ø§Ú¯ */
.debug-btn {
    background: #555;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 11px;
    margin-left: 10px;
    cursor: pointer;
    position: absolute;
    top: 10px;
    right: 10px;
}
.debug-btn:hover {
    background: #666;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø±ÙØ±Ø´ Ù‚ÛŒÙ…Øª */
.refresh-price {
    background: transparent;
    border: none;
    color: #00d9ff;
    cursor: pointer;
    font-size: 12px;
    margin-left: 5px;
}
.refresh-price:hover {
    color: #00ff88;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ ØªØ¨â€ŒÙ‡Ø§ */
.tab-container {
    display: flex;
    gap: 5px;
    margin-bottom: 15px;
    background: #0f3460;
    padding: 5px;
    border-radius: 8px;
}
.tab {
    flex: 1;
    padding: 10px;
    text-align: center;
    background: transparent;
    border: none;
    color: #888;
    cursor: pointer;
    border-radius: 6px;
    font-weight: bold;
    transition: all 0.3s;
}
.tab.active {
    background: #00d9ff;
    color: #000;
}
.tab.scalp {
    color: #ff00ff;
}
.tab.scalp.active {
    background: #ff00ff;
    color: #000;
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ */
.scalp-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #ff00ff;
    margin-right: 5px;
    animation: pulse 1s infinite;
}
@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ RSI indicator */
.rsi-indicator {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: bold;
    margin-left: 5px;
}
.rsi-oversold { background: rgba(0, 255, 136, 0.3); color: #00ff88; }
.rsi-overbought { background: rgba(255, 68, 68, 0.3); color: #ff4444; }
.rsi-neutral { background: rgba(255, 255, 255, 0.1); color: #fff; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ØµØ¯Ù‡Ø§ÛŒ ØµØ­ÛŒØ­ */
.percent-positive { color: #00ff88; }
.percent-negative { color: #ff4444; }
.percent-warning { color: #ff9900; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ ÙˆØ¶Ø¹ÛŒØª WebSocket */
.ws-status {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-left: 5px;
}
.ws-connected { background: #00ff88; box-shadow: 0 0 5px #00ff88; }
.ws-connecting { background: #ff9900; }
.ws-disconnected { background: #ff4444; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¯Ù‚Øª Ù‚ÛŒÙ…Øª */
.precision-badge {
    display: inline-block;
    font-size: 9px;
    padding: 1px 4px;
    border-radius: 3px;
    background: rgba(0, 153, 255, 0.2);
    color: #0099ff;
    margin-left: 5px;
}

/* -------- Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Bulk Scanner -------- */
.bulk-panel {
    background: linear-gradient(135deg, #1a1a2e 0%, #0f172a 100%);
    border: 2px solid #6d28d9;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 8px 32px rgba(109, 40, 217, 0.2);
}
.bulk-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    color: #a78bfa;
    font-size: 18px;
    font-weight: bold;
}
.bulk-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-bottom: 15px;
}
.bulk-control-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
}
.bulk-control-group label {
    font-size: 11px;
    color: #a78bfa;
}
.bulk-btn {
    background: #6d28d9;
    color: white;
    border: none;
    padding: 15px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
.bulk-btn:hover {
    background: #7c3aed;
}
.bulk-btn.active {
    background: #ef4444;
}
.bulk-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.bulk-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    margin-bottom: 15px;
}
.bulk-stat-item {
    background: rgba(109, 40, 217, 0.1);
    padding: 10px;
    border-radius: 8px;
    text-align: center;
}
.bulk-stat-label {
    font-size: 11px;
    color: #a78bfa;
    margin-bottom: 5px;
}
.bulk-stat-value {
    font-size: 18px;
    font-weight: bold;
    color: #fff;
}
.bulk-progress {
    margin-bottom: 15px;
}
.bulk-progress-bar {
    height: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    overflow: hidden;
    margin-bottom: 5px;
}
.bulk-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #6d28d9, #8b5cf6);
    transition: width 0.3s ease;
}
.bulk-progress-text {
    font-size: 11px;
    color: #888;
    text-align: center;
}
.bulk-results-container {
    max-height: 400px;
    overflow-y: auto;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.3);
}
.bulk-results-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
}
.bulk-results-table th {
    position: sticky;
    top: 0;
    background: #0f172a;
    padding: 10px;
    text-align: left;
    color: #a78bfa;
    font-weight: bold;
    border-bottom: 2px solid #6d28d9;
}
.bulk-results-table td {
    padding: 8px 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
.bulk-results-table tr:hover {
    background: rgba(109, 40, 217, 0.1);
}
.signal-buy { color: #00ff88; }
.signal-sell { color: #ff4444; }
.signal-hold { color: #ff9900; }
.bulk-filter {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
}
.filter-btn {
    padding: 5px 12px;
    border-radius: 15px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.3s;
}
.filter-btn.active {
    background: #6d28d9;
    border-color: #6d28d9;
}
.count-badge {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    font-weight: bold;
    margin-left: 5px;
}
.buy-badge { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
.sell-badge { background: rgba(255, 68, 68, 0.2); color: #ff4444; }
.hold-badge { background: rgba(255, 153, 0, 0.2); color: #ff9900; }

/* Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª Ù‚ÛŒÙ…Øª */
.price-status {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-left: 5px;
}
.price-success { background: #00ff88; box-shadow: 0 0 5px #00ff88; }
.price-warning { background: #ff9900; }
.price-error { background: #ff4444; }
</style>
</head>
<body>

<div class="header">
<h1>ğŸ¤– AI Smart Money Scanner v2.6</h1>
<div style="font-size:12px;color:#888;margin-top:5px">Bulk Scan (15m) | Scalp (1m/5m/15m) + Swing (1h/4h) Signals | All Crypto + Forex + Gold | Enhanced Price System</div>
</div>

<!-- AI Advisor Panel -->
<div class="advisor-panel" id="advisorPanel">
    <div class="advisor-header">
        <span>ğŸ¤–</span>
        <span>AI Market Advisor</span>
        <span id="advisorStatus" class="status-indicator status-warning"></span>
    </div>
    
    <div class="advisor-grid" id="advisorGrid">
        <div class="advisor-item warning">
            <div class="advisor-label">API Status</div>
            <div class="advisor-value" id="apiStatusText">CHECKING...</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Market Condition</div>
            <div class="advisor-value" id="marketCondition">ANALYZING...</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Active Signals</div>
            <div class="advisor-value"><span id="activeSignals">0</span> (<span id="scalpSignals">0</span>âš¡)</div>
        </div>
        <div class="advisor-item">
            <div class="advisor-label">Signal Confidence</div>
            <div class="advisor-value" id="signalConfidence">--%</div>
        </div>
    </div>
    
    <div class="advice-box" id="adviceBox">
        <div class="advice-title">ğŸ’¡ AI Recommendation</div>
        <div class="advice-text" id="adviceText">
            Initializing system... Enhanced price system for all crypto, forex & gold.
        </div>
    </div>
</div>

<!-- Bulk Scanner Panel -->
<div class="bulk-panel" id="bulkPanel">
    <div class="bulk-header">
        <span>ğŸš€</span>
        <span>Bulk Symbol Scanner (15m Interval)</span>
        <span id="bulkStatus" class="status-indicator status-offline"></span>
    </div>
    
    <div class="bulk-controls">
        <div class="bulk-control-group">
            <label>ğŸ”¢ Total Symbols</label>
            <select id="bulkSymbolLimit">
                <option value="20">20 Symbols (Fast Test)</option>
                <option value="50" selected>50 Symbols (Recommended)</option>
                <option value="100">100 Symbols (Full Scan)</option>
                <option value="150">150 Symbols (Complete)</option>
            </select>
        </div>
        <div class="bulk-control-group">
            <label>â° Timeframe</label>
            <select id="bulkTimeframe">
                <option value="15m" selected>15 Minutes</option>
                <option value="5m">5 Minutes</option>
                <option value="1h">1 Hour</option>
                <option value="4h">4 Hours</option>
            </select>
        </div>
    </div>
    
    <button class="bulk-btn" id="bulkStartBtn">
        <span>ğŸš€</span>
        <span>START BULK SCAN (15m)</span>
    </button>
    
    <div class="bulk-stats">
        <div class="bulk-stat-item">
            <div class="bulk-stat-label">Scanned</div>
            <div class="bulk-stat-value"><span id="bulkScanned">0</span>/<span id="bulkTotal">0</span></div>
        </div>
        <div class="bulk-stat-item">
            <div class="bulk-stat-label">BUY Signals</div>
            <div class="bulk-stat-value"><span id="bulkBuySignals">0</span></div>
        </div>
        <div class="bulk-stat-item">
            <div class="bulk-stat-label">SELL Signals</div>
            <div class="bulk-stat-value"><span id="bulkSellSignals">0</span></div>
        </div>
        <div class="bulk-stat-item">
            <div class="bulk-stat-label">Next Scan</div>
            <div class="bulk-stat-value"><span id="bulkNextScan">--:--</span></div>
        </div>
    </div>
    
    <div class="bulk-progress">
        <div class="bulk-progress-bar">
            <div class="bulk-progress-fill" id="bulkProgressFill" style="width: 0%"></div>
        </div>
        <div class="bulk-progress-text" id="bulkProgressText">Ready to start bulk scan</div>
    </div>
    
    <div class="bulk-filter">
        <button class="filter-btn active" data-filter="all">All <span class="count-badge" id="filterAll">0</span></button>
        <button class="filter-btn" data-filter="buy">Buy <span class="count-badge buy-badge" id="filterBuy">0</span></button>
        <button class="filter-btn" data-filter="sell">Sell <span class="count-badge sell-badge" id="filterSell">0</span></button>
        <button class="filter-btn" data-filter="hold">Hold <span class="count-badge hold-badge" id="filterHold">0</span></button>
    </div>
    
    <div class="bulk-results-container">
        <table class="bulk-results-table" id="bulkResultsTable">
            <thead>
                <tr>
                    <th>Symbol</th>
                    <th>Signal</th>
                    <th>Confidence</th>
                    <th>Price</th>
                    <th>RSI</th>
                    <th>Time</th>
                    <th>Price Status</th>
                    <th>Action</th>
                </tr>
            </thead>
            <tbody id="bulkResultsBody">
                <!-- Results will be inserted here -->
            </tbody>
        </table>
    </div>
</div>

<!-- Tab Navigation -->
<div class="tab-container">
    <button class="tab active" id="tabAll">All Signals</button>
    <button class="tab scalp" id="tabScalp">âš¡ Scalp (1m/5m/15m)</button>
    <button class="tab" id="tabSwing">ğŸ“Š Swing (1h/4h)</button>
</div>

<div class="controls">
<!-- Market Selection -->
<div class="market-toggle">
<button class="market-btn active" id="cryptoBtn">ğŸ’ CRYPTO</button>
<button class="market-btn" id="forexBtn">ğŸ’± FOREX & GOLD</button>
</div>

<!-- Symbol Search -->
<div class="control-group" style="margin-bottom:10px">
<label>ğŸ” Search Symbol</label>
<input type="text" id="symbolSearch" placeholder="Type BTC, ETH, SOL...">
<div id="symbolList" style="max-height:200px;overflow-y:auto;background:#16213e;border:2px solid #00d9ff;border-radius:6px;margin-top:5px;display:none"></div>
</div>

<!-- Timeframe Selection -->
<div class="control-group" style="margin-bottom:10px">
<label>â° Select Timeframes</label>
<div class="timeframe-grid">
<button class="tf-btn active" id="tf5m">5 Min</button>
<button class="tf-btn active" id="tf15m">15 Min</button>
<button class="tf-btn active" id="tf1h">1 Hour</button>
<button class="tf-btn" id="tf1m">1 Min</button>
<button class="tf-btn" id="tf4h">4 Hour</button>
</div>
</div>

<div class="control-row">
<div class="control-group">
<label>ğŸ“Š Current Symbol</label>
<div style="display:flex;align-items:center">
<input type="text" id="symbol" value="BTCUSDT" readonly style="background:#1a1a2e;color:#00ff88;border:2px solid #00ff88;font-weight:bold;flex:1">
<button class="refresh-price" id="refreshPriceBtn" title="Refresh price">ğŸ”„</button>
</div>
</div>
<div class="control-group">
<label>ğŸ¯ Signal Quality</label>
<select id="quality">
<option value="40">Easy (40%)</option>
<option value="60" selected>PRO (60%)</option>
<option value="75">Expert (75%)</option>
<option value="65">Scalp (65%)</option>
</select>
</div>
</div>

<button class="btn btn-start" id="startBtn">â–¶ START SCANNING</button>
<button class="btn btn-scalp" id="scalpBtn">âš¡ SCALP SCAN</button>
<button class="btn btn-test" id="testBtn">ğŸ§ª TEST CONNECTION</button>
<button class="btn btn-force" id="forceBtn">âš  FULL SCAN</button>
</div>

<div class="status">
<button class="debug-btn" id="priceDebugBtn">ğŸ”§ Debug Price</button>
<div class="status-grid">
<div>
<div class="status-label">ğŸ’ Price</div>
<div class="status-value price-display" id="price" style="color:#00d9ff;cursor:pointer" title="Double-click to refresh price">--</div>
</div>
<div>
<div class="status-label">ğŸ“ˆ Confidence</div>
<div class="status-value" id="confidence">--</div>
</div>
</div>
<div id="priceSource" style="font-size:10px;color:#888;text-align:center;margin-top:5px">Connecting...</div>
<div style="font-size:9px;color:#666;text-align:center;margin-top:3px">
    Mode: <span id="priceMode" style="color:#00ff88">Enhanced Multi-Source</span> | 
    Updated: <span id="lastUpdate">--</span>
</div>
</div>

<div class="debug" id="debug">
<div class="debug-line success">ğŸš€ AI Smart Money Scanner v2.6 Ready!</div>
<div class="debug-line">âš¡ Bulk Scanner (15m Interval) Added</div>
<div class="debug-line">ğŸ“Š Enhanced Price System for ALL Crypto</div>
<div class="debug-line">ğŸŒ API: <span id="apiUrlDisplay">crypto-trading-system-0zab.onrender.com</span></div>
<div class="debug-line">ğŸ’° Multi-Source Pricing: All Crypto + Forex + Gold Support</div>
</div>

<div id="connectionError" class="error-message" style="display:none">
âš ï¸ <strong>Connection Error:</strong> <span id="errorMessage">Unable to connect to API</span>
</div>

<div class="signals" id="signals"></div>

<div class="footer">
<div>Signals: <strong id="signalCount">0</strong> (<span id="scalpCount">0</span>âš¡) | Bulk Scan: <strong id="bulkScanCount">0</strong> symbols | Active TF: <strong id="activeTFs">3</strong></div>
<div style="margin-top:5px;font-size:10px">API: <span style="color:#00ff88" id="apiUrlFooter">crypto-trading-system-0zab.onrender.com</span></div>
<div style="margin-top:5px;font-size:9px;color:#666">Enhanced Price System | Bulk Scanner (15m) | All Crypto Support</div>
</div>

<script>
// ========== CONFIGURATION ==========
const CONFIG = {
    API_URL: 'https://crypto-trading-system-0zab.onrender.com',
    USE_RELIABLE_API: true,
    ENABLE_WEBSOCKET: false,
    SCAN_INTERVAL: 30000,
    SCALP_INTERVAL: 15000,
    UPDATE_INTERVAL: 10000,
    PRICE_RETRY_ATTEMPTS: 3,
    BULK_SCAN_INTERVAL: 900000, // 15 Ø¯Ù‚ÛŒÙ‚Ù‡
    BULK_BATCH_SIZE: 5,
    BULK_REQUEST_DELAY: 800,
    PRICE_TIMEOUT: 5000
};

// ========== GLOBAL VARIABLES ==========
let isScanning = false;
let isScalping = false;
let isBulkScanning = false;
let signalCount = 0;
let scalpSignalCount = 0;
let scanInterval = null;
let scalpInterval = null;
let bulkScanInterval = null;
let bulkScanTimeout = null;
let allSymbols = [];
let currentMarket = 'crypto';
let activeTimeframes = ['5m', '15m', '1h'];
let scalpTimeframes = ['1m', '5m', '15m'];
let apiStatus = 'checking';
let lastRealPrices = new Map();
let activeTab = 'all';
let priceUpdateInterval = null;
let bulkScanResults = new Map();
let nextBulkScanTime = null;
let failedSymbols = [];
let binanceSymbolsCache = null;
let lastBinanceSymbolsUpdate = 0;

// ========== PRICE PRECISION CONFIG ==========
const PRICE_PRECISION_CONFIG = {
    default: { minDecimals: 4, maxDecimals: 8 },
    highPrice: { threshold: 1000, minDecimals: 2, maxDecimals: 4 },
    mediumPrice: { threshold: 100, minDecimals: 4, maxDecimals: 6 },
    lowPrice: { threshold: 1, minDecimals: 6, maxDecimals: 8 },
    veryLowPrice: { threshold: 0.01, minDecimals: 8, maxDecimals: 10 }
};

// ========== ENHANCED PRICE SYSTEM ==========

// Ø³ÛŒØ³ØªÙ… Ú©Ø§Ù…Ù„ Ù…Ù¾ÛŒÙ†Ú¯ Ù†Ù…Ø§Ø¯Ù‡Ø§
const SYMBOL_MAPPINGS = {
    // ÙØ§Ø±Ú©Ø³
    'EURUSD': 'EURUSDT', 'GBPUSD': 'GBPUSDT', 'USDJPY': 'JPYUSDT',
    'USDCHF': 'CHFUSDT', 'AUDUSD': 'AUDUSDT', 'USDCAD': 'CADUSDT',
    'NZDUSD': 'NZDUSDT', 'EURGBP': 'EURGBP', 'EURJPY': 'EURJPY',
    'GBPJPY': 'GBPJPY', 'AUDJPY': 'AUDJPY',
    
    // Ø·Ù„Ø§ Ùˆ Ù†Ù‚Ø±Ù‡
    'XAUUSD': 'PAXGUSDT', 'XAGUSD': 'XAGUSDT', 'PAXG': 'PAXGUSDT',
    'XAUT': 'XAUTUSDT',
    
    // Ø§Ø³ØªÛŒØ¨Ù„â€ŒÚ©ÙˆÛŒÙ†â€ŒÙ‡Ø§
    'USDT': 'USDT', 'USDC': 'USDC', 'DAI': 'DAI', 'BUSD': 'BUSD',
    'TUSD': 'TUSD', 'USDP': 'USDP',
    
    // Ø§Ø±Ø²Ù‡Ø§ÛŒ Ù…Ø¹Ø±ÙˆÙ
    'BTC': 'BTCUSDT', 'ETH': 'ETHUSDT', 'BNB': 'BNBUSDT',
    'SOL': 'SOLUSDT', 'XRP': 'XRPUSDT', 'ADA': 'ADAUSDT',
    'DOGE': 'DOGEUSDT', 'DOT': 'DOTUSDT', 'MATIC': 'MATICUSDT',
    'SHIB': 'SHIBUSDT', 'LTC': 'LTCUSDT', 'AVAX': 'AVAXUSDT',
    
    // Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
    'ARB': 'ARBUSDT', 'OP': 'OPUSDT', 'SUI': 'SUIUSDT',
    'SEI': 'SEIUSDT', 'APT': 'APTUSDT', 'IMX': 'IMXUSDT',
    'RNDR': 'RNDRUSDT', 'INJ': 'INJUSDT', 'FET': 'FETUSDT',
    'AGIX': 'AGIXUSDT', 'OCEAN': 'OCEANUSDT', 'GRT': 'GRTUSDT',
    
    // Ù…ÛŒÙ…â€ŒÚ©ÙˆÛŒÙ†â€ŒÙ‡Ø§
    'PEPE': 'PEPEUSDT', 'FLOKI': 'FLOKIUSDT', 'BONK': 'BONKUSDT',
    'WIF': 'WIFUSDT', 'BOME': 'BOMEUSDT'
};

// Ù„ÛŒØ³Øª Ú©Ø§Ù…Ù„ Ø§Ø±Ø²Ù‡Ø§ÛŒ CoinGecko
const COINGECKO_IDS = {
    'BTCUSDT': 'bitcoin', 'ETHUSDT': 'ethereum', 'BNBUSDT': 'binancecoin',
    'SOLUSDT': 'solana', 'XRPUSDT': 'ripple', 'ADAUSDT': 'cardano',
    'AVAXUSDT': 'avalanche-2', 'DOTUSDT': 'polkadot', 'DOGEUSDT': 'dogecoin',
    'MATICUSDT': 'matic-network', 'SHIBUSDT': 'shiba-inu', 'LTCUSDT': 'litecoin',
    'UNIUSDT': 'uniswap', 'LINKUSDT': 'chainlink', 'ATOMUSDT': 'cosmos',
    'ETCUSDT': 'ethereum-classic', 'XLMUSDT': 'stellar', 'ALGOUSDT': 'algorand',
    'VETUSDT': 'vechain', 'FILUSDT': 'filecoin', 'TRXUSDT': 'tron',
    'EOSUSDT': 'eos', 'AAVEUSDT': 'aave', 'XTZUSDT': 'tezos',
    'SANDUSDT': 'the-sandbox', 'MANAUSDT': 'decentraland', 'GALAUSDT': 'gala',
    'APEUSDT': 'apecoin', 'CHZUSDT': 'chiliz', 'ENJUSDT': 'enjincoin',
    'COMPUSDT': 'compound', 'MKRUSDT': 'maker', 'SNXUSDT': 'havven',
    'CRVUSDT': 'curve-dao-token', '1INCHUSDT': '1inch', 'NEARUSDT': 'near',
    'FTMUSDT': 'fantom', 'ICPUSDT': 'internet-computer', 'HBARUSDT': 'hedera',
    'PEPEUSDT': 'pepe', 'FLOKIUSDT': 'floki', 'BONKUSDT': 'bonk',
    'ARBUSDT': 'arbitrum', 'OPUSDT': 'optimism', 'SUIUSDT': 'sui',
    'SEIUSDT': 'sei-network', 'APTUSDT': 'aptos', 'IMXUSDT': 'immutable-x',
    'RNDRUSDT': 'render-token', 'INJUSDT': 'injective-protocol',
    'FETUSDT': 'fetch-ai', 'AGIXUSDT': 'singularitynet',
    'OCEANUSDT': 'ocean-protocol', 'GRTUSDT': 'the-graph',
    'WIFUSDT': 'dogwifhat', 'BOMEUSDT': 'book-of-meme',
    'PAXGUSDT': 'pax-gold', 'XAUTUSDT': 'tether-gold'
};

// ========== ØªÙˆØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÚ¯ÛŒØ±ÛŒ ==========

// ØªØ¨Ø¯ÛŒÙ„ Ù†Ù…Ø§Ø¯ Ø¨Ù‡ ÙØ±Ù…Øª Binance
function convertToBinanceSymbol(symbol) {
    const upperSymbol = symbol.toUpperCase().trim();
    
    // Ø§Ú¯Ø± Ø¯Ø± Ù…Ù¾ÛŒÙ†Ú¯ Ø¨ÙˆØ¯
    if (SYMBOL_MAPPINGS[upperSymbol]) {
        return SYMBOL_MAPPINGS[upperSymbol];
    }
    
    // Ø§Ú¯Ø± Ø¨Ø§ USDT ØªÙ…Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯
    if (upperSymbol.endsWith('USDT')) {
        return upperSymbol;
    }
    
    // Ø§Ú¯Ø± Ø¨Ø§ USD ØªÙ…Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯
    if (upperSymbol.endsWith('USD')) {
        return upperSymbol.replace('USD', 'USDT');
    }
    
    // Ø§Ú¯Ø± Ø¨Ø§ / Ø¬Ø¯Ø§ Ø´Ø¯Ù‡
    if (upperSymbol.includes('/')) {
        const parts = upperSymbol.split('/');
        if (parts.length === 2) {
            return parts[0] + parts[1];
        }
    }
    
    // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† USDT
    return upperSymbol + 'USDT';
}

// Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Binance
async function getBinanceSymbols() {
    const now = Date.now();
    
    // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©Ø´ (Ù‡Ø± 5 Ø¯Ù‚ÛŒÙ‚Ù‡ ÛŒÚ©Ø¨Ø§Ø± Ø¢Ù¾Ø¯ÛŒØª)
    if (binanceSymbolsCache && (now - lastBinanceSymbolsUpdate < 300000)) {
        return binanceSymbolsCache;
    }
    
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000);
        
        const response = await fetch('https://api.binance.com/api/v3/exchangeInfo', {
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
            const data = await response.json();
            const symbolsMap = {};
            
            data.symbols.forEach(s => {
                if (s.status === 'TRADING' && s.quoteAsset === 'USDT') {
                    symbolsMap[s.symbol] = true;
                    // Ù‡Ù…Ú†Ù†ÛŒÙ† Ù†Ù…Ø§Ø¯ Ù¾Ø§ÛŒÙ‡ Ø±Ø§ Ù‡Ù… Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†
                    symbolsMap[s.baseAsset] = s.symbol;
                }
            });
            
            binanceSymbolsCache = symbolsMap;
            lastBinanceSymbolsUpdate = now;
            
            console.log(`âœ… Loaded ${Object.keys(symbolsMap).length} Binance symbols`);
            return symbolsMap;
        }
    } catch (error) {
        console.error('Failed to get Binance symbols:', error);
    }
    
    return {};
}

// Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ù…Ø§Ø¯ Ø¯Ø± Binance
async function checkSymbolOnBinance(symbol) {
    try {
        const binanceSymbol = convertToBinanceSymbol(symbol);
        const binanceSymbols = await getBinanceSymbols();
        
        if (binanceSymbols[binanceSymbol]) {
            return { exists: true, symbol: binanceSymbol };
        }
        
        // Ø¨Ø±Ø±Ø³ÛŒ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†â€ŒÙ‡Ø§
        const alternatives = [
            binanceSymbol,
            binanceSymbol.replace('USDT', ''),
            binanceSymbol.split('USDT')[0],
            symbol.toUpperCase() + 'USDT',
            symbol.toUpperCase().replace('USD', 'USDT')
        ];
        
        for (const alt of alternatives) {
            if (binanceSymbols[alt]) {
                return { exists: true, symbol: alt };
            }
        }
        
        return { exists: false, symbol: binanceSymbol };
        
    } catch (error) {
        console.error('Error checking symbol on Binance:', error);
        return { exists: false, symbol: convertToBinanceSymbol(symbol) };
    }
}

// Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ø§Ø² Binance
async function getPriceFromBinance(symbol) {
    try {
        const checkResult = await checkSymbolOnBinance(symbol);
        
        if (!checkResult.exists) {
            return null;
        }
        
        const binanceSymbol = checkResult.symbol;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CONFIG.PRICE_TIMEOUT);
        
        const response = await fetch(
            `https://api.binance.com/api/v3/ticker/price?symbol=${binanceSymbol}`,
            {
                signal: controller.signal,
                headers: {
                    'Accept': 'application/json',
                    'Cache-Control': 'no-cache'
                }
            }
        );
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
            const data = await response.json();
            const price = parseFloat(data.price);
            
            if (!isNaN(price) && price > 0) {
                return {
                    price: price,
                    source: 'Binance',
                    isReal: true,
                    symbol: binanceSymbol,
                    originalSymbol: symbol.toUpperCase()
                };
            }
        }
        
    } catch (error) {
        console.error(`Binance price error for ${symbol}:`, error.message);
    }
    
    return null;
}

// Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ø§Ø² CoinGecko
async function getPriceFromCoinGecko(symbol) {
    try {
        const originalSymbol = symbol.toUpperCase();
        
        // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† CoinGecko ID
        let coinId = COINGECKO_IDS[originalSymbol];
        
        if (!coinId) {
            // Ø³Ø¹ÛŒ Ú©Ù† Ù†Ù…Ø§Ø¯ Ù¾Ø§ÛŒÙ‡ Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ú©Ù†ÛŒ
            const baseSymbol = originalSymbol.replace('USDT', '');
            for (const [key, id] of Object.entries(COINGECKO_IDS)) {
                if (key.includes(baseSymbol) || key === baseSymbol + 'USDT') {
                    coinId = id;
                    break;
                }
            }
        }
        
        if (!coinId) {
            return null;
        }
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CONFIG.PRICE_TIMEOUT);
        
        const response = await fetch(
            `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`,
            {
                signal: controller.signal,
                headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'TradingScanner/2.6'
                }
            }
        );
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
            const data = await response.json();
            if (data[coinId] && data[coinId].usd) {
                const price = parseFloat(data[coinId].usd);
                return {
                    price: price,
                    source: 'CoinGecko',
                    isReal: true,
                    symbol: originalSymbol,
                    coinGeckoId: coinId
                };
            }
        }
        
    } catch (error) {
        console.error('CoinGecko error:', error);
    }
    
    return null;
}

// Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ø§Ø² Bybit (Ø³ÙˆØ±Ø³ Ø³ÙˆÙ…)
async function getPriceFromBybit(symbol) {
    try {
        const binanceSymbol = convertToBinanceSymbol(symbol);
        const bybitSymbol = binanceSymbol.replace('USDT', '');
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CONFIG.PRICE_TIMEOUT);
        
        const response = await fetch(
            `https://api.bybit.com/v2/public/tickers?symbol=${bybitSymbol}USDT`,
            {
                signal: controller.signal
            }
        );
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
            const data = await response.json();
            if (data.result && data.result.length > 0 && data.result[0].last_price) {
                const price = parseFloat(data.result[0].last_price);
                return {
                    price: price,
                    source: 'Bybit',
                    isReal: true,
                    symbol: symbol
                };
            }
        }
        
    } catch (error) {
        console.error('Bybit error:', error);
    }
    
    return null;
}

// Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ø§Ø² Kucoin (Ø³ÙˆØ±Ø³ Ú†Ù‡Ø§Ø±Ù…)
async function getPriceFromKucoin(symbol) {
    try {
        const binanceSymbol = convertToBinanceSymbol(symbol);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CONFIG.PRICE_TIMEOUT);
        
        const response = await fetch(
            `https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${binanceSymbol}`,
            {
                signal: controller.signal
            }
        );
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
            const data = await response.json();
            if (data.data && data.data.price) {
                const price = parseFloat(data.data.price);
                return {
                    price: price,
                    source: 'Kucoin',
                    isReal: true,
                    symbol: symbol
                };
            }
        }
        
    } catch (error) {
        console.error('Kucoin error:', error);
    }
    
    return null;
}

// Ø³ÛŒØ³ØªÙ… Ù‚ÛŒÙ…Øªâ€ŒÚ¯ÛŒØ±ÛŒ Ú†Ù†Ø¯Ú¯Ø§Ù†Ù‡
async function getPriceFromMultipleSources(symbol) {
    const sources = [
        { name: 'Binance', getter: getPriceFromBinance },
        { name: 'CoinGecko', getter: getPriceFromCoinGecko },
        { name: 'Bybit', getter: getPriceFromBybit },
        { name: 'Kucoin', getter: getPriceFromKucoin }
    ];
    
    // Ø§Ù…ØªØ­Ø§Ù† Ù‡Ù…Ù‡ Ø³ÙˆØ±Ø³â€ŒÙ‡Ø§ Ø¨Ù‡ ØªØ±ØªÛŒØ¨
    for (const source of sources) {
        try {
            const priceInfo = await source.getter(symbol);
            if (priceInfo && priceInfo.price > 0) {
                console.log(`âœ… Got price from ${source.name} for ${symbol}: $${priceInfo.price}`);
                return priceInfo;
            }
        } catch (error) {
            console.error(`${source.name} error for ${symbol}:`, error);
            continue;
        }
        
        // Ú©Ù…ÛŒ ØªØ§Ø®ÛŒØ± Ø¨ÛŒÙ† Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§
        await sleep(100);
    }
    
    return null;
}

// ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª
async function getCurrentMarketPrice(symbol, forceRefresh = false) {
    const originalSymbol = symbol.toUpperCase();
    const cacheKey = originalSymbol;
    
    // Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø´
    if (!forceRefresh && lastRealPrices.has(cacheKey)) {
        const cached = lastRealPrices.get(cacheKey);
        const age = Date.now() - cached.timestamp;
        
        if (age < 30000) { // 30 Ø«Ø§Ù†ÛŒÙ‡
            return {
                ...cached,
                cacheAge: age,
                source: cached.source + ' (Cached)'
            };
        }
    }
    
    // Ù„Ø§Ú¯ Ø´Ø±ÙˆØ¹
    console.log(`ğŸ”„ Fetching price for ${originalSymbol}...`);
    
    try {
        // Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ø§Ø² Ù…Ù†Ø§Ø¨Ø¹ Ù…Ø®ØªÙ„Ù
        const priceInfo = await getPriceFromMultipleSources(originalSymbol);
        
        if (priceInfo && priceInfo.price > 0) {
            // Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ú©Ø´
            lastRealPrices.set(cacheKey, {
                ...priceInfo,
                timestamp: Date.now(),
                originalSymbol: originalSymbol
            });
            
            console.log(`âœ… Success: ${originalSymbol} = $${formatPriceWithPrecision(priceInfo.price)} (${priceInfo.source})`);
            
            // Ø­Ø°Ù Ø§Ø² Ù„ÛŒØ³Øª Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯Ù‡
            const index = failedSymbols.indexOf(originalSymbol);
            if (index > -1) {
                failedSymbols.splice(index, 1);
            }
            
            return priceInfo;
            
        } else {
            // Ù‚ÛŒÙ…Øª Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯
            console.warn(`âš ï¸ No price found for ${originalSymbol}`);
            
            // Ø§Ø¶Ø§ÙÙ‡ Ø¨Ù‡ Ù„ÛŒØ³Øª Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯Ù‡
            if (!failedSymbols.includes(originalSymbol)) {
                failedSymbols.push(originalSymbol);
                addLog(`âš ï¸ No price data for ${originalSymbol}`, 'warning');
            }
            
            // Ø³Ø¹ÛŒ Ú©Ù† Ù‚ÛŒÙ…Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø¯Ù‡ÛŒ
            return getFallbackPrice(originalSymbol);
        }
        
    } catch (error) {
        console.error(`âŒ Price fetch error for ${originalSymbol}:`, error);
        
        return getFallbackPrice(originalSymbol);
    }
}

// Ù‚ÛŒÙ…Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ (ÙØ§Ù„â€ŒØ¨Ú©)
function getFallbackPrice(symbol) {
    const originalSymbol = symbol.toUpperCase();
    
    // Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø´ Ù‚Ø¯ÛŒÙ…ÛŒ
    if (lastRealPrices.has(originalSymbol)) {
        const cached = lastRealPrices.get(originalSymbol);
        return {
            ...cached,
            source: cached.source + ' (Old Cache)',
            isReal: false
        };
    }
    
    // Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø§ØµÙ„ÛŒ
    const defaultPrices = {
        'BTCUSDT': 50000 + Math.random() * 5000,
        'ETHUSDT': 3000 + Math.random() * 300,
        'BNBUSDT': 400 + Math.random() * 40,
        'SOLUSDT': 100 + Math.random() * 10,
        'XRPUSDT': 0.5 + Math.random() * 0.1,
        'ADAUSDT': 0.5 + Math.random() * 0.1,
        'DOGEUSDT': 0.1 + Math.random() * 0.02,
        'DOTUSDT': 7 + Math.random() * 1,
        'MATICUSDT': 0.8 + Math.random() * 0.1,
        'EURUSD': 1.08 + Math.random() * 0.02,
        'XAUUSD': 2380 + Math.random() * 20
    };
    
    const price = defaultPrices[originalSymbol] || (50 + Math.random() * 50);
    
    return {
        price: price,
        source: 'Fallback System',
        isReal: false,
        symbol: originalSymbol,
        originalSymbol: originalSymbol,
        timestamp: Date.now()
    };
}

// ========== ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ ==========

// Ù‚Ø§Ù„Ø¨â€ŒØ¨Ù†Ø¯ÛŒ Ù‚ÛŒÙ…Øª
function getPricePrecision(price) {
    if (typeof price !== 'number' || isNaN(price)) {
        return { minDecimals: 4, maxDecimals: 8 };
    }
    
    const absPrice = Math.abs(price);
    
    if (absPrice >= PRICE_PRECISION_CONFIG.highPrice.threshold) {
        return PRICE_PRECISION_CONFIG.highPrice;
    } else if (absPrice >= PRICE_PRECISION_CONFIG.mediumPrice.threshold) {
        return PRICE_PRECISION_CONFIG.mediumPrice;
    } else if (absPrice >= PRICE_PRECISION_CONFIG.lowPrice.threshold) {
        return PRICE_PRECISION_CONFIG.lowPrice;
    } else if (absPrice >= PRICE_PRECISION_CONFIG.veryLowPrice.threshold) {
        return PRICE_PRECISION_CONFIG.veryLowPrice;
    } else {
        return PRICE_PRECISION_CONFIG.default;
    }
}

function formatPriceWithPrecision(price) {
    if (typeof price !== 'number' || isNaN(price)) return '--';
    
    const precision = getPricePrecision(price);
    
    // ÙØ±Ù…Øª Ø§ÙˆÙ„ÛŒÙ‡
    let formatted = price.toLocaleString('en-US', {
        minimumFractionDigits: precision.minDecimals,
        maximumFractionDigits: precision.maxDecimals,
        useGrouping: false
    });
    
    // Ø­Ø°Ù ØµÙØ±Ù‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ
    if (formatted.includes('.')) {
        formatted = formatted.replace(/(\.\d*?[1-9])0+$/, '$1');
        formatted = formatted.replace(/\.0+$/, '');
        
        // Ø§Ú¯Ø± Ú©Ù…ØªØ± Ø§Ø² Ø­Ø¯Ø§Ù‚Ù„ Ø±Ù‚Ù… Ø§Ø¹Ø´Ø§Ø± Ø¯Ø§Ø±ÛŒÙ…
        const decimalPart = formatted.includes('.') ? formatted.split('.')[1] : '';
        if (decimalPart.length < precision.minDecimals) {
            formatted += '0'.repeat(precision.minDecimals - decimalPart.length);
        }
    } else {
        formatted += '.' + '0'.repeat(precision.minDecimals);
    }
    
    return formatted;
}

function formatPercent(value) {
    return (value * 100).toFixed(0) + '%';
}

// ========== BULK SCANNER FUNCTIONS ==========
async function scanAllSymbols() {
    if (isBulkScanning) {
        addLog('âš ï¸ Bulk scan is already running', 'warning');
        return;
    }
    
    isBulkScanning = true;
    document.getElementById('bulkStartBtn').innerHTML = '<span>â¸</span><span>STOP BULK SCAN</span>';
    document.getElementById('bulkStartBtn').classList.add('active');
    document.getElementById('bulkStatus').className = 'status-indicator status-warning';
    
    const limit = parseInt(document.getElementById('bulkSymbolLimit').value);
    const timeframe = document.getElementById('bulkTimeframe').value;
    const minConfidence = parseInt(document.getElementById('quality').value) / 100;
    
    const symbolsToScan = allSymbols.slice(0, limit);
    const totalSymbols = symbolsToScan.length;
    
    document.getElementById('bulkTotal').textContent = totalSymbols;
    document.getElementById('bulkScanned').textContent = '0';
    document.getElementById('bulkBuySignals').textContent = '0';
    document.getElementById('bulkSellSignals').textContent = '0';
    document.getElementById('bulkProgressFill').style.width = '0%';
    document.getElementById('bulkProgressText').textContent = 'Starting bulk scan...';
    
    addLog(`ğŸš€ Starting bulk scan of ${totalSymbols} symbols (${timeframe})`, 'success');
    
    let scannedCount = 0;
    let buySignals = 0;
    let sellSignals = 0;
    let holdSignals = 0;
    let noPriceCount = 0;
    
    // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù†ØªØ§ÛŒØ¬ Ù‚Ø¨Ù„ÛŒ
    document.getElementById('bulkResultsBody').innerHTML = '';
    bulkScanResults.clear();
    
    // Ø§ÙˆÙ„ Ù„ÛŒØ³Øª Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Binance Ø±Ø§ Ø¨Ú¯ÛŒØ±
    await getBinanceSymbols();
    
    // Ø§Ø³Ú©Ù† Ù†Ù…Ø§Ø¯Ù‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø³ØªÙ‡â€ŒØ§ÛŒ
    for (let i = 0; i < symbolsToScan.length; i += CONFIG.BULK_BATCH_SIZE) {
        if (!isBulkScanning) break;
        
        const batch = symbolsToScan.slice(i, i + CONFIG.BULK_BATCH_SIZE);
        const batchPromises = batch.map(symbol => 
            scanSingleSymbolForBulk(symbol, timeframe, minConfidence)
        );
        
        const results = await Promise.allSettled(batchPromises);
        
        // Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù†ØªØ§ÛŒØ¬ Ø¯Ø³ØªÙ‡
        results.forEach((result, index) => {
            if (result.status === 'fulfilled' && result.value) {
                const symbolResult = result.value;
                scannedCount++;
                
                // Ø¢Ù¾Ø¯ÛŒØª Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡â€ŒÙ‡Ø§
                if (symbolResult.signal === 'BUY') buySignals++;
                else if (symbolResult.signal === 'SELL') sellSignals++;
                else holdSignals++;
                
                if (symbolResult.priceStatus === 'error') noPriceCount++;
                
                // Ø°Ø®ÛŒØ±Ù‡ Ù†ØªÛŒØ¬Ù‡
                bulkScanResults.set(symbolResult.symbol, symbolResult);
                
                // Ù†Ù…Ø§ÛŒØ´ Ù†ØªÛŒØ¬Ù‡ Ø¯Ø± Ø¬Ø¯ÙˆÙ„
                addBulkResultToTable(symbolResult);
            }
            
            // Ø¢Ù¾Ø¯ÛŒØª Ù¾ÛŒØ´Ø±ÙØª
            const progress = Math.round((scannedCount / totalSymbols) * 100);
            document.getElementById('bulkProgressFill').style.width = `${progress}%`;
            document.getElementById('bulkProgressText').textContent = 
                `Scanning... ${scannedCount}/${totalSymbols} (${progress}%)`;
            
            document.getElementById('bulkScanned').textContent = scannedCount;
            document.getElementById('bulkBuySignals').textContent = buySignals;
            document.getElementById('bulkSellSignals').textContent = sellSignals;
            
            updateFilterCounts(buySignals, sellSignals, holdSignals);
        });
        
        // ØªØ§Ø®ÛŒØ± Ø¨ÛŒÙ† Ø¯Ø³ØªÙ‡â€ŒÙ‡Ø§
        if (i + CONFIG.BULK_BATCH_SIZE < symbolsToScan.length && isBulkScanning) {
            await sleep(CONFIG.BULK_REQUEST_DELAY * 3);
        }
    }
    
    // Ø¢Ù¾Ø¯ÛŒØª ÙˆØ¶Ø¹ÛŒØª Ù†Ù‡Ø§ÛŒÛŒ
    if (isBulkScanning) {
        document.getElementById('bulkStatus').className = 'status-indicator status-online';
        document.getElementById('bulkProgressText').textContent = 
            `âœ… Scan completed: ${buySignals} BUY, ${sellSignals} SELL, ${holdSignals} HOLD`;
        
        if (noPriceCount > 0) {
            document.getElementById('bulkProgressText').textContent += `, ${noPriceCount} no price`;
        }
        
        addLog(`âœ… Bulk scan completed: ${buySignals} BUY, ${sellSignals} SELL, ${holdSignals} HOLD`, 'success');
        
        if (noPriceCount > 0) {
            addLog(`âš ï¸ ${noPriceCount} symbols had no price data`, 'warning');
        }
        
        // Ø¢Ù¾Ø¯ÛŒØª Ù…Ø´Ø§ÙˆØ± Ø¨Ø§Ø²Ø§Ø±
        updateMarketAdvisorFromBulkResults(buySignals, sellSignals, holdSignals, scannedCount);
        
        // ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù† Ø§Ø³Ú©Ù† Ø¨Ø¹Ø¯ÛŒ
        scheduleNextBulkScan();
    } else {
        document.getElementById('bulkProgressText').textContent = 'Scan stopped by user';
    }
    
    document.getElementById('bulkStartBtn').innerHTML = '<span>ğŸš€</span><span>START BULK SCAN (15m)</span>';
    document.getElementById('bulkStartBtn').classList.remove('active');
    isBulkScanning = false;
}

async function scanSingleSymbolForBulk(symbol, timeframe, minConfidence) {
    try {
        // Ú¯Ø±ÙØªÙ† Ù‚ÛŒÙ…Øª
        const priceInfo = await getCurrentMarketPrice(symbol, true);
        
        let priceStatus = 'success';
        if (!priceInfo || priceInfo.price <= 0) {
            priceStatus = 'error';
        } else if (!priceInfo.isReal) {
            priceStatus = 'warning';
        }
        
        if (!priceInfo || priceInfo.price <= 0) {
            return {
                symbol: symbol,
                signal: 'HOLD',
                confidence: 0,
                price: 0,
                rsi: 50,
                timestamp: new Date().toISOString(),
                error: 'No price data',
                priceStatus: 'error'
            };
        }
        
        // Ø¯Ø±ÛŒØ§ÙØª Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø§Ø² API
        let analysisResult;
        try {
            analysisResult = await makeRequest('/api/analyze', {
                symbol: symbol,
                timeframe: timeframe
            });
        } catch (apiError) {
            // Fallback analysis
            const randomSignal = Math.random() > 0.5 ? 'BUY' : (Math.random() > 0.5 ? 'SELL' : 'HOLD');
            const randomConfidence = 0.4 + Math.random() * 0.4;
            
            analysisResult = {
                symbol: symbol,
                signal: randomSignal,
                confidence: randomConfidence,
                rsi: 40 + Math.random() * 40
            };
        }
        
        const result = {
            symbol: symbol,
            signal: analysisResult.signal || 'HOLD',
            confidence: analysisResult.confidence || 0.5,
            price: priceInfo.price,
            rsi: analysisResult.rsi || 50,
            priceSource: priceInfo.source,
            timestamp: new Date().toISOString(),
            timeframe: timeframe,
            priceStatus: priceStatus,
            isRealPrice: priceInfo.isReal
        };
        
        // Ù„Ø§Ú¯ Ú©Ø±Ø¯Ù† Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù…
        if (result.confidence >= minConfidence && (result.signal === 'BUY' || result.signal === 'SELL')) {
            addLog(`ğŸ“Š [BULK] ${symbol}: ${result.signal} - ${formatPercent(result.confidence)} (RSI: ${result.rsi.toFixed(1)})`, 
                  result.signal === 'BUY' ? 'success' : 'error');
        }
        
        return result;
        
    } catch (error) {
        console.error(`Bulk scan error for ${symbol}:`, error);
        return {
            symbol: symbol,
            signal: 'HOLD',
            confidence: 0,
            price: 0,
            rsi: 50,
            timestamp: new Date().toISOString(),
            error: error.message,
            priceStatus: 'error'
        };
    }
}

function addBulkResultToTable(result) {
    const tbody = document.getElementById('bulkResultsBody');
    
    const time = new Date(result.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    const confidencePercent = formatPercent(result.confidence);
    const priceFormatted = result.price > 0 ? `$${formatPriceWithPrecision(result.price)}` : '--';
    
    const row = document.createElement('tr');
    row.dataset.symbol = result.symbol;
    row.dataset.signal = result.signal.toLowerCase();
    
    const signalClass = result.signal === 'BUY' ? 'signal-buy' : 
                       result.signal === 'SELL' ? 'signal-sell' : 'signal-hold';
    
    // Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª Ù‚ÛŒÙ…Øª
    let priceStatusBadge = '';
    if (result.priceStatus === 'success') {
        priceStatusBadge = '<span class="price-status price-success" title="Real price"></span>';
    } else if (result.priceStatus === 'warning') {
        priceStatusBadge = '<span class="price-status price-warning" title="Fallback price"></span>';
    } else {
        priceStatusBadge = '<span class="price-status price-error" title="No price"></span>';
    }
    
    row.innerHTML = `
        <td><strong>${result.symbol}</strong></td>
        <td class="${signalClass}"><strong>${result.signal}</strong></td>
        <td>${confidencePercent}</td>
        <td>${priceFormatted}</td>
        <td>${result.rsi ? result.rsi.toFixed(1) : '--'}</td>
        <td>${time}</td>
        <td>${priceStatusBadge} ${result.isRealPrice ? 'âœ…' : 'âš ï¸'}</td>
        <td>
            <button class="filter-btn" onclick="selectSymbol('${result.symbol}')" 
                    style="padding: 3px 8px; font-size: 10px;">
                ğŸ” View
            </button>
        </td>
    `;
    
    tbody.insertBefore(row, tbody.firstChild);
    
    // Ù…Ø­Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† ØªØ¹Ø¯Ø§Ø¯ Ø±Ø¯ÛŒÙâ€ŒÙ‡Ø§
    if (tbody.children.length > 50) {
        tbody.removeChild(tbody.lastChild);
    }
}

function updateFilterCounts(buy, sell, hold) {
    const total = buy + sell + hold;
    
    document.getElementById('filterAll').textContent = total;
    document.getElementById('filterBuy').textContent = buy;
    document.getElementById('filterSell').textContent = sell;
    document.getElementById('filterHold').textContent = hold;
    
    document.getElementById('bulkScanCount').textContent = total;
}

function updateMarketAdvisorFromBulkResults(buy, sell, hold, total) {
    const conditionElement = document.getElementById('marketCondition');
    const adviceText = document.getElementById('adviceText');
    
    const buyRatio = buy / total;
    const sellRatio = sell / total;
    
    if (buyRatio > 0.6) {
        conditionElement.textContent = 'STRONGLY BULLISH';
        conditionElement.parentElement.className = 'advisor-item good';
        adviceText.innerHTML = `ğŸ“ˆ <strong>Strong Bullish Bias:</strong> ${buy} out of ${total} symbols show BUY signals. Market sentiment is positive.`;
    } else if (sellRatio > 0.6) {
        conditionElement.textContent = 'STRONGLY BEARISH';
        conditionElement.parentElement.className = 'advisor-item danger';
        adviceText.innerHTML = `ğŸ“‰ <strong>Strong Bearish Bias:</strong> ${sell} out of ${total} symbols show SELL signals. Consider caution.`;
    } else if (buy > sell) {
        conditionElement.textContent = 'MILD BULLISH';
        conditionElement.parentElement.className = 'advisor-item good';
        adviceText.innerHTML = `ğŸ“ˆ <strong>Mild Bullish Bias:</strong> ${buy} BUY vs ${sell} SELL signals. Selective opportunities available.`;
    } else if (sell > buy) {
        conditionElement.textContent = 'MILD BEARISH';
        conditionElement.parentElement.className = 'advisor-item warning';
        adviceText.innerHTML = `ğŸ“‰ <strong>Mild Bearish Bias:</strong> ${sell} SELL vs ${buy} BUY signals. Risk management advised.`;
    } else {
        conditionElement.textContent = 'NEUTRAL';
        conditionElement.parentElement.className = 'advisor-item warning';
        adviceText.innerHTML = `âš–ï¸ <strong>Market Neutral:</strong> Balanced signals (${buy} BUY, ${sell} SELL, ${hold} HOLD). Range-bound markets expected.`;
    }
}

function scheduleNextBulkScan() {
    if (bulkScanTimeout) clearTimeout(bulkScanTimeout);
    
    nextBulkScanTime = Date.now() + CONFIG.BULK_SCAN_INTERVAL;
    updateNextScanTime();
    
    bulkScanTimeout = setTimeout(() => {
        if (!isBulkScanning) {
            addLog('ğŸ”„ Starting automatic bulk scan (15m interval)', 'info');
            scanAllSymbols();
        }
    }, CONFIG.BULK_SCAN_INTERVAL);
}

function updateNextScanTime() {
    if (!nextBulkScanTime) return;
    
    const updateDisplay = () => {
        const now = Date.now();
        const timeLeft = nextBulkScanTime - now;
        
        if (timeLeft <= 0) {
            document.getElementById('bulkNextScan').textContent = 'Now';
            return;
        }
        
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        
        document.getElementById('bulkNextScan').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    };
    
    updateDisplay();
    setInterval(updateDisplay, 1000);
}

function stopBulkScan() {
    isBulkScanning = false;
    document.getElementById('bulkStartBtn').innerHTML = '<span>ğŸš€</span><span>START BULK SCAN (15m)</span>';
    document.getElementById('bulkStartBtn').classList.remove('active');
    document.getElementById('bulkStatus').className = 'status-indicator status-offline';
    document.getElementById('bulkProgressText').textContent = 'Scan stopped by user';
    
    addLog('ğŸ›‘ Bulk scan stopped by user', 'error');
}

function setupBulkFilters() {
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const filter = this.dataset.filter;
            
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            const rows = document.querySelectorAll('#bulkResultsBody tr');
            rows.forEach(row => {
                if (filter === 'all') {
                    row.style.display = '';
                } else {
                    row.style.display = row.dataset.signal === filter ? '' : 'none';
                }
            });
        });
    });
}

// ========== API HELPER ==========
async function makeRequest(endpoint, data = null) {
    const url = `${CONFIG.API_URL}${endpoint}`;
    
    const options = {
        method: data ? 'POST' : 'GET',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
    };
    
    if (data) {
        options.body = JSON.stringify(data);
    }
    
    try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        return await response.json();
        
    } catch (error) {
        console.error(`API Request failed:`, error);
        throw error;
    }
}

// ========== SCALP SCANNING FUNCTION ==========
async function scanScalp() {
    const symbol = document.getElementById('symbol').value;
    const minConfidence = 0.65;
    
    addLog(`âš¡ Scanning scalp signals for ${symbol}...`, 'scalp');
    
    for (const tf of scalpTimeframes) {
        try {
            const priceInfo = await getCurrentMarketPrice(symbol);
            
            if (!priceInfo || priceInfo.price <= 0) {
                addLog(`âŒ [${tf}] No price data for scalp scan`, 'error');
                continue;
            }
            
            const scalpSignal = await makeRequest('/api/scalp-signal', {
                symbol: symbol,
                timeframe: tf
            });
            
            const scalpData = {
                symbol: scalpSignal.symbol || symbol,
                signal: scalpSignal.signal || 'HOLD',
                confidence: scalpSignal.confidence || 0.5,
                entry_price: priceInfo.price,
                rsi: scalpSignal.rsi || 50,
                sma_20: scalpSignal.sma_20 || priceInfo.price * 0.99,
                volume_ratio: 1.2,
                message: scalpSignal.reason || `Scalp signal on ${tf} timeframe`,
                source: scalpSignal.strategy || 'Scalp Analysis',
                targets: scalpSignal.targets || [priceInfo.price * 1.01, priceInfo.price * 1.02],
                stop_loss: scalpSignal.stop_loss || priceInfo.price * 0.99,
                timestamp: new Date().toISOString(),
                price_source: priceInfo.source,
                is_real_price: priceInfo.isReal,
                type: 'SCALP',
                timeframe: tf,
                risk_level: tf === '1m' ? 'HIGH' : 'MEDIUM'
            };
            
            if (scalpData.confidence >= minConfidence && (scalpData.signal === 'BUY' || scalpData.signal === 'SELL')) {
                addSignal(scalpData, tf, 'SCALPâš¡');
                addLog(`âš¡ [${tf}] ${scalpData.signal} - ${formatPercent(scalpData.confidence)} (RSI: ${scalpData.rsi})`, 'success');
                
                scalpSignalCount++;
                document.getElementById('scalpCount').textContent = scalpSignalCount;
                document.getElementById('scalpSignals').textContent = scalpSignalCount;
            }
            
        } catch (error) {
            console.log(`Scalp scan failed for ${tf}:`, error);
            
            try {
                const priceInfo = await getCurrentMarketPrice(symbol);
                if (priceInfo) {
                    updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
                }
            } catch (priceError) {
                // ignore
            }
        }
        
        await sleep(500);
    }
}

// ========== REGULAR SCANNING FUNCTION ==========
async function scanMarket(timeframe) {
    const symbol = document.getElementById('symbol').value;
    const minConfidence = parseInt(document.getElementById('quality').value) / 100;
    
    try {
        addLog(`ğŸ“¡ Scanning ${symbol} (${timeframe})...`, 'info');
        
        const priceInfo = await getCurrentMarketPrice(symbol);
        
        if (!priceInfo || priceInfo.price <= 0) {
            addLog(`âŒ [${timeframe}] No price data for ${symbol}`, 'error');
            return null;
        }
        
        let analysisResult;
        
        try {
            analysisResult = await makeRequest('/api/analyze', {
                symbol: symbol,
                timeframe: timeframe
            });
            
            apiStatus = 'online';
            updateApiStatus('online');
            
        } catch (apiError) {
            apiStatus = 'offline';
            updateApiStatus('offline');
            
            const randomSignal = Math.random() > 0.5 ? 'BUY' : (Math.random() > 0.5 ? 'SELL' : 'HOLD');
            const randomConfidence = 0.5 + Math.random() * 0.4;
            
            analysisResult = {
                symbol: symbol,
                signal: randomSignal,
                confidence: randomConfidence,
                entry_price: priceInfo.price,
                targets: randomSignal === 'BUY' ? 
                    [priceInfo.price * 1.02, priceInfo.price * 1.05] : 
                    randomSignal === 'SELL' ? 
                    [priceInfo.price * 0.98, priceInfo.price * 0.95] : [],
                stop_loss: randomSignal === 'BUY' ? 
                    priceInfo.price * 0.98 : 
                    randomSignal === 'SELL' ? 
                    priceInfo.price * 1.02 : priceInfo.price,
                strategy: 'Fallback Analysis'
            };
        }
        
        const safeData = {
            symbol: analysisResult.symbol || symbol,
            signal: analysisResult.signal || 'HOLD',
            confidence: analysisResult.confidence || 0.5,
            entry_price: priceInfo.price,
            rsi: analysisResult.rsi || 50,
            volume_ratio: analysisResult.volume_ratio || 1,
            message: analysisResult.recommendation || analysisResult.message || 'Analysis completed',
            source: analysisResult.strategy || 'API Analysis',
            targets: Array.isArray(analysisResult.targets) ? analysisResult.targets : 
                   analysisResult.signal === 'BUY' ? [priceInfo.price * 1.02, priceInfo.price * 1.05] :
                   analysisResult.signal === 'SELL' ? [priceInfo.price * 0.98, priceInfo.price * 0.95] : [],
            stop_loss: analysisResult.stop_loss || 
                     (analysisResult.signal === 'BUY' ? priceInfo.price * 0.98 :
                      analysisResult.signal === 'SELL' ? priceInfo.price * 1.02 : priceInfo.price),
            timestamp: new Date().toISOString(),
            price_source: priceInfo.source,
            is_real_price: priceInfo.isReal,
            type: timeframe === '1h' || timeframe === '4h' ? 'SWING' : 'REGULAR',
            timeframe: timeframe,
            risk_level: 'MEDIUM'
        };
        
        updateStatus(safeData);
        
        if (safeData.confidence >= minConfidence && (safeData.signal === 'BUY' || safeData.signal === 'SELL')) {
            const quality = safeData.confidence >= 0.85 ? 'ULTRAğŸ”¥' :
                          safeData.confidence >= 0.70 ? 'HIGHğŸ”¥' :
                          safeData.confidence >= minConfidence ? 'GOOD' : 'WEAK';
            
            addSignal(safeData, timeframe, quality);
        }
        
        return safeData;
        
    } catch (error) {
        addLog(`âŒ [${timeframe}] Error: ${error.message}`, 'error');
        return null;
    }
}

// ========== UI UPDATE FUNCTIONS ==========
function updateStatus(data) {
    updatePriceDisplay(data.entry_price, data.price_source, data.is_real_price);
    
    document.getElementById('confidence').textContent = formatPercent(data.confidence);
    document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
    document.getElementById('signalConfidence').textContent = formatPercent(data.confidence);
    
    updateMarketCondition(data);
}

function updatePriceDisplay(price, source, isReal = true) {
    const priceElement = document.getElementById('price');
    const sourceElement = document.getElementById('priceSource');
    const modeElement = document.getElementById('priceMode');
    
    if (!price || price <= 0) {
        priceElement.textContent = '--';
        sourceElement.textContent = 'Source: No price data';
        sourceElement.style.color = '#ff4444';
        modeElement.textContent = 'No Data';
        modeElement.style.color = '#ff4444';
        return;
    }
    
    const formattedPrice = formatPriceWithPrecision(price);
    
    if (isReal) {
        priceElement.innerHTML = `$${formattedPrice} <span style="color:#00ff88; font-size:12px">âœ…</span>`;
        sourceElement.textContent = `Source: ${source}`;
        sourceElement.style.color = '#00ff88';
        modeElement.textContent = 'Live';
        modeElement.style.color = '#00ff88';
    } else {
        priceElement.textContent = `$${formattedPrice}`;
        sourceElement.textContent = `Source: ${source}`;
        sourceElement.style.color = '#ff9900';
        modeElement.textContent = 'Cached/Fallback';
        modeElement.style.color = '#ff9900';
    }
    
    document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
}

function updateMarketCondition(data) {
    const conditionElement = document.getElementById('marketCondition');
    const activeSignalsElement = document.getElementById('activeSignals');
    
    if (data.signal === 'BUY' && data.confidence > 0.7) {
        conditionElement.textContent = 'BULLISH';
        conditionElement.parentElement.className = 'advisor-item good';
    } else if (data.signal === 'SELL' && data.confidence > 0.7) {
        conditionElement.textContent = 'BEARISH';
        conditionElement.parentElement.className = 'advisor-item danger';
    } else {
        conditionElement.textContent = 'NEUTRAL';
        conditionElement.parentElement.className = 'advisor-item warning';
    }
    
    activeSignalsElement.textContent = signalCount;
}

function updateApiStatus(status) {
    const statusElement = document.getElementById('apiStatusText');
    const indicator = document.getElementById('advisorStatus');
    const errorDiv = document.getElementById('connectionError');
    const adviceText = document.getElementById('adviceText');
    
    apiStatus = status;
    
    if (status === 'online') {
        statusElement.textContent = 'ONLINE';
        statusElement.parentElement.className = 'advisor-item good';
        indicator.className = 'status-indicator status-online';
        errorDiv.style.display = 'none';
        adviceText.innerHTML = 'âœ… API connection established. Using enhanced multi-source pricing for all symbols.';
    } else if (status === 'offline') {
        statusElement.textContent = 'OFFLINE';
        statusElement.parentElement.className = 'advisor-item danger';
        indicator.className = 'status-indicator status-offline';
        errorDiv.style.display = 'block';
        document.getElementById('errorMessage').textContent = 'Cannot connect to API server';
        adviceText.innerHTML = 'âš ï¸ API connection lost. Using fallback analysis with enhanced price feeds.';
    } else {
        statusElement.textContent = 'CHECKING...';
        statusElement.parentElement.className = 'advisor-item warning';
        indicator.className = 'status-indicator status-warning';
        adviceText.innerHTML = 'Checking API connection...';
    }
}

function addSignal(data, timeframe, quality) {
    signalCount++;
    document.getElementById('signalCount').textContent = signalCount;
    document.getElementById('activeSignals').textContent = signalCount;
    
    const tfClass = timeframe === '1m' ? 'tf-1m' :
                   timeframe === '5m' ? 'tf-5m' :
                   timeframe === '15m' ? 'tf-15m' :
                   timeframe === '1h' ? 'tf-1h' : 'tf-4h';
    
    const tfLabel = timeframe === '1m' ? '1 Min' :
                   timeframe === '5m' ? '5 Min' :
                   timeframe === '15m' ? '15 Min' :
                   timeframe === '1h' ? '1 Hour' : '4 Hour';
    
    const type = data.signal.toLowerCase();
    const isScalp = data.type === 'SCALP';
    const signalClass = isScalp ? 'scalp' : type;
    
    let targetsHtml = '<div style="color:#888">No targets specified</div>';
    if (data.targets && data.targets.length > 0 && data.entry_price > 0) {
        targetsHtml = data.targets.map((target, index) => {
            const gainPercent = ((target / data.entry_price - 1) * 100).toFixed(2);
            let sign = '';
            let color = '#00ff88';
            
            if (data.signal === 'BUY') {
                sign = gainPercent >= 0 ? '+' : '';
                color = '#00ff88';
            } else if (data.signal === 'SELL') {
                color = '#ff4444';
                sign = gainPercent < 0 ? '-' : '';
            }
            
            const percentDisplay = Math.abs(gainPercent);
            
            return `<div>ğŸ¯ TP${index + 1}: $${formatPriceWithPrecision(target)} <span class="percent-${gainPercent >= 0 ? 'positive' : 'negative'}" style="color:${color}">(${sign}${percentDisplay}%)</span></div>`;
        }).join('');
    }
    
    let stopLossHtml = '';
    if (data.stop_loss > 0 && data.entry_price > 0) {
        const lossPercent = ((data.stop_loss / data.entry_price - 1) * 100).toFixed(2);
        let sign = '';
        let color = '#ff4444';
        
        if (data.signal === 'BUY') {
            color = '#ff4444';
            sign = lossPercent < 0 ? '-' : '';
        } else if (data.signal === 'SELL') {
            color = '#ff9900';
            sign = lossPercent >= 0 ? '+' : '';
        }
        
        const percentDisplay = Math.abs(lossPercent);
        
        stopLossHtml = `<div>ğŸ›‘ Stop Loss: $${formatPriceWithPrecision(data.stop_loss)} <span class="percent-${lossPercent >= 0 ? 'warning' : 'negative'}" style="color:${color}">(${sign}${percentDisplay}%)</span></div>`;
    }
    
    let rsiHtml = '';
    if (data.rsi) {
        const rsiClass = data.rsi < 30 ? 'rsi-oversold' : data.rsi > 70 ? 'rsi-overbought' : 'rsi-neutral';
        rsiHtml = `<span class="rsi-indicator ${rsiClass}">RSI: ${data.rsi.toFixed(1)}</span>`;
    }
    
    const realPriceBadge = data.is_real_price ? 
        `<span style="color:#00ff88; font-size:10px; margin-left:5px">âœ… Live</span>` : 
        `<span style="color:#ff9900; font-size:10px; margin-left:5px">âš ï¸ Ref</span>`;
    
    const scalpBadge = isScalp ? `<span class="scalp-indicator"></span>` : '';
    
    const entryPriceDisplay = data.entry_price > 0 ? formatPriceWithPrecision(data.entry_price) : '--';
    
    const card = `
        <div class="signal-card ${signalClass}" data-type="${data.type}" data-timeframe="${timeframe}">
            <div class="signal-header">
                <div class="signal-type">
                    ${scalpBadge}${type === 'buy' ? 'ğŸŸ¢ BUY' : type === 'sell' ? 'ğŸ”´ SELL' : 'ğŸŸ¡ HOLD'} 
                    <span class="tf-indicator ${tfClass}">${tfLabel}</span>
                    ${rsiHtml}
                </div>
                <div class="signal-badge" style="background: ${isScalp ? 'rgba(255,0,255,0.2)' : type === 'buy' ? 'rgba(0,255,136,0.2)' : type === 'sell' ? 'rgba(255,68,68,0.2)' : 'rgba(255,255,0,0.2)'}">
                    ${isScalp ? 'âš¡ ' : ''}${quality} ${realPriceBadge}
                </div>
            </div>
            <div class="signal-details">
                <div><strong>${data.symbol}</strong> â€¢ ${data.source} ${data.risk_level ? `<span style="color:#ff9900;font-size:10px">(${data.risk_level} Risk)</span>` : ''}</div>
                <div class="price-display">ğŸ’° Entry: <strong>$${entryPriceDisplay}</strong> ${data.is_real_price ? 'âœ…' : 'âš ï¸'}</div>
                <div>ğŸ“Š Confidence: <strong>${formatPercent(data.confidence)}</strong></div>
                ${data.sma_20 ? `<div class="price-display">ğŸ“ˆ SMA20: <strong>$${formatPriceWithPrecision(data.sma_20)}</strong></div>` : ''}
                <div>ğŸ’¡ ${data.message}</div>
                <div class="targets">
                    <strong>ğŸ¯ Targets:</strong>
                    ${targetsHtml}
                    ${stopLossHtml}
                </div>
                <div style="margin-top:10px;color:#888;font-size:11px">
                    â° ${new Date(data.timestamp).toLocaleTimeString()} â€¢ ${data.price_source} â€¢ ${data.type}
                </div>
            </div>
        </div>`;
    
    const container = document.getElementById('signals');
    
    if (activeTab === 'all' || 
        (activeTab === 'scalp' && isScalp) || 
        (activeTab === 'swing' && data.type === 'SWING')) {
        container.insertAdjacentHTML('afterbegin', card);
    }
    
    if (container.children.length > 15) {
        container.removeChild(container.lastChild);
    }
    
    updateSignalCounters();
}

function updateSignalCounters() {
    const signals = document.querySelectorAll('.signal-card');
    let scalpCount = 0;
    let swingCount = 0;
    let regularCount = 0;
    
    signals.forEach(signal => {
        const type = signal.dataset.type;
        if (type === 'SCALP') scalpCount++;
        else if (type === 'SWING') swingCount++;
        else regularCount++;
    });
    
    document.getElementById('scalpCount').textContent = scalpCount;
    document.getElementById('scalpSignals').textContent = scalpCount;
}

// ========== TAB MANAGEMENT ==========
function setupTabs() {
    document.getElementById('tabAll').addEventListener('click', () => switchTab('all'));
    document.getElementById('tabScalp').addEventListener('click', () => switchTab('scalp'));
    document.getElementById('tabSwing').addEventListener('click', () => switchTab('swing'));
}

function switchTab(tab) {
    activeTab = tab;
    
    document.getElementById('tabAll').classList.toggle('active', tab === 'all');
    document.getElementById('tabScalp').classList.toggle('active', tab === 'scalp');
    document.getElementById('tabSwing').classList.toggle('active', tab === 'swing');
    
    const signals = document.querySelectorAll('.signal-card');
    signals.forEach(signal => {
        const signalType = signal.dataset.type;
        const timeframe = signal.dataset.timeframe;
        
        let shouldShow = false;
        
        if (tab === 'all') {
            shouldShow = true;
        } else if (tab === 'scalp') {
            shouldShow = signalType === 'SCALP';
        } else if (tab === 'swing') {
            shouldShow = signalType === 'SWING';
        }
        
        signal.style.display = shouldShow ? 'block' : 'none';
    });
    
    addLog(`ğŸ“Š Switched to ${tab.toUpperCase()} tab`, 'info');
}

// ========== SYMBOL MANAGEMENT ==========
function loadAllSymbols() {
    allSymbols = [
        // Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø§ØµÙ„ÛŒ
        'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT',
        'AVAXUSDT', 'DOTUSDT', 'DOGEUSDT', 'MATICUSDT', 'SHIBUSDT', 'LTCUSDT',
        'UNIUSDT', 'LINKUSDT', 'ATOMUSDT', 'ETCUSDT', 'XLMUSDT', 'ALGOUSDT',
        'VETUSDT', 'FILUSDT', 'TRXUSDT', 'EOSUSDT', 'AAVEUSDT', 'XTZUSDT',
        'SANDUSDT', 'MANAUSDT', 'GALAUSDT', 'APEUSDT', 'CHZUSDT', 'ENJUSDT',
        'COMPUSDT', 'MKRUSDT', 'SNXUSDT', 'CRVUSDT', '1INCHUSDT',
        'NEARUSDT', 'FTMUSDT', 'ICPUSDT', 'HBARUSDT',
        
        // Ø§Ø³ØªÛŒØ¨Ù„â€ŒÚ©ÙˆÛŒÙ†â€ŒÙ‡Ø§
        'USDT', 'USDC', 'DAI', 'BUSD', 'TUSD', 'USDP',
        
        // ÙØ§Ø±Ú©Ø³
        'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
        'EURGBP', 'EURJPY', 'GBPJPY', 'AUDJPY',
        
        // Ø·Ù„Ø§ Ùˆ Ù†Ù‚Ø±Ù‡
        'XAUUSD', 'XAGUSD', 'PAXG', 'XAUT',
        
        // Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ØªØ± Layer 2 & AI
        'ARBUSDT', 'OPUSDT', 'SUIUSDT', 'SEIUSDT', 'APTUSDT',
        'IMXUSDT', 'RNDRUSDT', 'INJUSDT', 'FETUSDT', 'AGIXUSDT',
        'OCEANUSDT', 'GRTUSDT',
        
        // Ù…ÛŒÙ…â€ŒÚ©ÙˆÛŒÙ†â€ŒÙ‡Ø§
        'PEPEUSDT', 'FLOKIUSDT', 'BONKUSDT', 'WIFUSDT', 'BOMEUSDT',
        
        // Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ±
        'ETCUSDT', 'XMRUSDT', 'ZECUSDT', 'DASHUSDT', 'WAVESUSDT',
        'THETAUSDT', 'KAVAUSDT', 'AAVEUSDT', 'COMPUSDT', 'YFIUSDT',
        'MKRUSDT', 'SNXUSDT', 'CRVUSDT', 'SUSHIUSDT', 'CAKEUSDT',
        'AXSUSDT', 'SANDUSDT', 'MANAUSDT', 'ENJUSDT', 'GALAUSDT',
        'CHZUSDT', 'FTMUSDT', 'ONEUSDT', 'HOTUSDT', 'VETUSDT',
        'TFUELUSDT', 'CELRUSDT', 'MATICUSDT', 'FTTUSDT', 'SRMUSDT',
        'RAYUSDT', 'PERPUSDT', 'KSMUSDT', 'DYDXUSDT', 'ENSUSDT',
        'IMXUSDT', 'GALUSDT', 'OPUSDT', 'APEUSDT', 'GMTUSDT',
        'APEUSDT', 'GSTUSDT', 'HOOKUSDT', 'MAGICUSDT', 'RPLUSDT',
        'SSVUSDT', 'LDOUSDT', 'FXSUSDT', 'CVXUSDT', 'BALUSDT',
        'BANDUSDT', 'UMAUSDT', 'API3USDT', 'ACHUSDT', 'GLMRUSDT',
        'MOVRUSDT', 'ROSEUSDT', 'CELOUSDT', 'FLOWUSDT', 'MINAUSDT',
        'ALICEUSDT', 'DUSKUSDT', 'ICXUSDT', 'XVGUSDT', 'SCUSDT',
        'STORJUSDT', 'SKLUSDT', 'COTIUSDT', 'POLYUSDT', 'RENUSDT',
        'CTKUSDT', 'TOMOUSDT', 'WRXUSDT', 'DREPUSDT', 'TRBUSDT',
        'CKBUSDT', 'TROYUSDT', 'VITEUSDT', 'CTSIUSDT', 'ARPAUSDT',
        'RSRUSDT', 'STMXUSDT', 'AVAUSDT', 'MTLUSDT', 'KEYUSDT',
        'DOCKUSDT', 'WANUSDT', 'DATAUSDT', 'AMBUSDT', 'COSUSDT',
        'CTXCUSDT', 'IQUSDT', 'MXUSDT', 'SNTUSDT', 'CHRUSDT',
        'MDTUSDT', 'GTOUSDT', 'STPTUSDT', 'KNCUSDT', 'REQUSDT',
        'LRCUSDT', 'PNTUSDT', 'DGBUSDT', 'COMPUSDT', 'ZILUSDT',
        'IOSTUSDT', 'OMGUSDT', 'ZRXUSDT', 'BATUSDT', 'LOOMUSDT',
        'MANAUSDT', 'ANTUSDT', 'BTSUSDT', 'LSKUSDT', 'FUNUSDT',
        'CVCUSDT', 'STMXUSDT', 'DATAUSDT', 'RLCUSDT', 'POWRUSDT',
        'BLZUSDT', 'GVTUSDT', 'GNTUSDT', 'REPUSDT', 'KMDUSDT',
        'JSTUSDT', 'SXPUSDT', 'HARDUSDT', 'CAKEUSDT', 'BAKEUSDT',
        'BURGERUSDT', 'SLPUSDT', 'TLMUSDT', 'ALPHAUSDT', 'VIDTUSDT',
        'FRONTUSDT', 'HOTUSDT', 'ARDRUSDT', 'STMXUSDT', 'DENTUSDT',
        'CELRUSDT', 'HIVEUSDT', 'CHRUSDT', 'ARPAUSDT', 'STMXUSDT',
        'DREPUSDT', 'TROYUSDT', 'BEAMUSDT', 'WRXUSDT', 'BTSUSDT',
        'PERLUSDT', 'CTSIUSDT', 'STRAXUSDT', 'AERGOUSDT', 'GLMUSDT',
        'COCOSUSDT', 'TCTUSDT', 'WTCUSDT', 'DATAUSDT', 'DOCKUSDT',
        'PHBUSDT', 'HCUSDT', 'GOUSDT', 'FISUSDT', 'WINGUSDT',
        'CFXUSDT', 'EPSUSDT', 'AUTOUSDT', 'ASRUSDT', 'CELOUSDT',
        'RIFUSDT', 'PSGUSDT', 'SANTOSUSDT', 'PORTOUSDT', 'LAZIOUSDT'
    ].sort();
    
    document.getElementById('bulkTotal').textContent = allSymbols.length;
    addLog(`âœ… ${allSymbols.length} symbols loaded`, 'success');
}

function handleSearch(e) {
    const query = e.target.value.toUpperCase();
    const list = document.getElementById('symbolList');
    
    if (!query.trim()) {
        list.style.display = 'none';
        return;
    }
    
    const filtered = allSymbols
        .filter(s => s.includes(query))
        .slice(0, 10);
    
    if (filtered.length > 0) {
        list.innerHTML = filtered.map(symbol => {
            const displayName = symbol.replace('USDT', '').replace('USD', '');
            return `<div class="symbol-list-item" data-symbol="${symbol}">
                      ${displayName} <span style="color:#888;font-size:11px">(${symbol})</span>
                    </div>`;
        }).join('');
        
        list.querySelectorAll('.symbol-list-item').forEach(item => {
            item.addEventListener('click', function() {
                selectSymbol(this.dataset.symbol);
            });
        });
        
        list.style.display = 'block';
    } else {
        list.innerHTML = '<div style="padding:10px;color:#888">No symbols found</div>';
        list.style.display = 'block';
    }
}

function isForexGoldSymbol(symbol) {
    const forexGoldSymbols = [
        'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
        'EURGBP', 'EURJPY', 'GBPJPY', 'AUDJPY', 'XAUUSD', 'XAGUSD', 'PAXG', 'XAUT'
    ];
    
    const upperSymbol = symbol.toUpperCase();
    return forexGoldSymbols.some(forexSymbol => 
        upperSymbol === forexSymbol || 
        upperSymbol.includes(forexSymbol) || 
        forexSymbol.includes(upperSymbol)
    );
}

async function selectSymbol(symbol) {
    const originalSymbol = symbol.toUpperCase();
    
    document.getElementById('symbol').value = originalSymbol;
    document.getElementById('symbolSearch').value = '';
    document.getElementById('symbolList').style.display = 'none';
    
    addLog(`âœ… Selected symbol: ${originalSymbol}`, 'success');
    
    if (isForexGoldSymbol(originalSymbol)) {
        switchMarket('forex');
        addLog(`ğŸŒ Forex/Gold symbol detected`, 'info');
    } else {
        switchMarket('crypto');
        addLog(`ğŸ’ Crypto symbol detected`, 'info');
    }
    
    const priceInfo = await getCurrentMarketPrice(originalSymbol, true);
    
    if (priceInfo) {
        updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
        addLog(`ğŸ’° ${originalSymbol} price: $${formatPriceWithPrecision(priceInfo.price)} (${priceInfo.source})`, 'info');
    } else {
        document.getElementById('price').textContent = '--';
        document.getElementById('priceSource').textContent = 'Source: Failed to fetch price';
        document.getElementById('priceSource').style.color = '#ff4444';
        addLog(`âŒ Failed to get price for ${originalSymbol}`, 'error');
    }
}

// ========== EVENT HANDLERS ==========
function setupEventListeners() {
    document.getElementById('cryptoBtn').addEventListener('click', () => switchMarket('crypto'));
    document.getElementById('forexBtn').addEventListener('click', () => switchMarket('forex'));
    
    document.getElementById('tf1m').addEventListener('click', () => toggleTimeframe('1m'));
    document.getElementById('tf5m').addEventListener('click', () => toggleTimeframe('5m'));
    document.getElementById('tf15m').addEventListener('click', () => toggleTimeframe('15m'));
    document.getElementById('tf1h').addEventListener('click', () => toggleTimeframe('1h'));
    document.getElementById('tf4h').addEventListener('click', () => toggleTimeframe('4h'));
    
    document.getElementById('startBtn').addEventListener('click', toggleScanning);
    document.getElementById('scalpBtn').addEventListener('click', toggleScalping);
    document.getElementById('testBtn').addEventListener('click', testConnection);
    document.getElementById('forceBtn').addEventListener('click', forceScan);
    document.getElementById('priceDebugBtn').addEventListener('click', debugPrice);
    document.getElementById('refreshPriceBtn').addEventListener('click', refreshCurrentPrice);
    
    document.getElementById('symbolSearch').addEventListener('input', handleSearch);
    document.getElementById('price').addEventListener('dblclick', refreshCurrentPrice);
    
    document.getElementById('bulkStartBtn').addEventListener('click', toggleBulkScan);
    document.getElementById('bulkSymbolLimit').addEventListener('change', updateBulkStats);
    document.getElementById('bulkTimeframe').addEventListener('change', updateBulkStats);
    
    setupTabs();
    setupBulkFilters();
}

function toggleBulkScan() {
    if (!isBulkScanning) {
        scanAllSymbols();
    } else {
        stopBulkScan();
    }
}

function updateBulkStats() {
    const limit = parseInt(document.getElementById('bulkSymbolLimit').value);
    document.getElementById('bulkTotal').textContent = limit;
}

async function refreshCurrentPrice() {
    const symbol = document.getElementById('symbol').value;
    addLog(`ğŸ”„ Refreshing price for ${symbol}...`, 'info');
    
    try {
        const priceInfo = await getCurrentMarketPrice(symbol, true);
        
        if (priceInfo) {
            updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
            addLog(`âœ… Price refreshed: $${formatPriceWithPrecision(priceInfo.price)}`, 'success');
        } else {
            document.getElementById('price').textContent = '--';
            document.getElementById('priceSource').textContent = 'Source: Failed to fetch';
            document.getElementById('priceSource').style.color = '#ff4444';
            addLog(`âŒ Price refresh failed for ${symbol}`, 'error');
        }
        
    } catch (error) {
        addLog(`âŒ Price refresh failed: ${error.message}`, 'error');
    }
}

async function debugPrice() {
    const symbol = document.getElementById('symbol').value;
    
    let debugInfo = `Price Debug for ${symbol}:\n\n`;
    
    try {
        const priceInfo = await getCurrentMarketPrice(symbol, true);
        
        if (priceInfo) {
            debugInfo += `Formatted Price: $${formatPriceWithPrecision(priceInfo.price)}\n`;
            debugInfo += `Raw Price: ${priceInfo.price}\n`;
            debugInfo += `Source: ${priceInfo.source}\n`;
            debugInfo += `Real Price: ${priceInfo.isReal ? 'âœ… Yes' : 'âŒ No'}\n`;
            debugInfo += `Cache Age: ${priceInfo.cacheAge ? Math.floor(priceInfo.cacheAge/1000) + 's' : 'N/A'}\n`;
        } else {
            debugInfo += `âŒ No price data available\n`;
        }
        
    } catch (error) {
        debugInfo += `âŒ Error: ${error.message}\n`;
    }
    
    debugInfo += `\nLast 5 cached prices:\n`;
    const cacheEntries = Array.from(lastRealPrices.entries()).slice(-5);
    cacheEntries.forEach(([sym, cached]) => {
        const age = Math.floor((Date.now() - cached.timestamp) / 1000);
        debugInfo += `${sym}: $${formatPriceWithPrecision(cached.price)} (${age}s ago)\n`;
    });
    
    alert(debugInfo);
}

function toggleScanning() {
    const btn = document.getElementById('startBtn');
    
    if (!isScanning) {
        isScanning = true;
        btn.textContent = 'â¸ STOP SCANNING';
        btn.classList.add('active');
        addLog('ğŸš€ Regular scanning started', 'success');
        
        forceScan();
        scanInterval = setInterval(() => {
            if (isScanning) forceScan();
        }, CONFIG.SCAN_INTERVAL);
        
    } else {
        isScanning = false;
        btn.textContent = 'â–¶ START SCANNING';
        btn.classList.remove('active');
        addLog('ğŸ›‘ Regular scanning stopped', 'error');
        
        if (scanInterval) {
            clearInterval(scanInterval);
            scanInterval = null;
        }
    }
}

function toggleScalping() {
    const btn = document.getElementById('scalpBtn');
    
    if (!isScalping) {
        isScalping = true;
        btn.textContent = 'â¸ STOP SCALP';
        btn.classList.add('active');
        addLog('âš¡ Scalp scanning started', 'success');
        
        scanScalp();
        scalpInterval = setInterval(() => {
            if (isScalping) scanScalp();
        }, CONFIG.SCALP_INTERVAL);
        
    } else {
        isScalping = false;
        btn.textContent = 'âš¡ SCALP SCAN';
        btn.classList.remove('active');
        addLog('ğŸ›‘ Scalp scanning stopped', 'error');
        
        if (scalpInterval) {
            clearInterval(scalpInterval);
            scalpInterval = null;
        }
    }
}

async function forceScan() {
    if (activeTimeframes.length === 0) {
        addLog('âš ï¸ Please select at least one timeframe', 'warning');
        return;
    }
    
    const symbol = document.getElementById('symbol').value;
    addLog(`ğŸ” Full scan for ${symbol}...`, 'info');
    
    for (const tf of activeTimeframes) {
        await scanMarket(tf);
        await sleep(1000);
    }
    
    addLog('âœ… Full scan completed', 'success');
}

async function testConnection() {
    addLog('ğŸ§ª Testing connection and price system...', 'warning');
    updateApiStatus('checking');
    
    try {
        // ØªØ³Øª API Ø§ØµÙ„ÛŒ
        try {
            const health = await makeRequest('/api/health');
            addLog(`âœ… API Health: ${health.status}`, 'success');
            addLog(`ğŸ“Š Version: ${health.version}`, 'info');
            updateApiStatus('online');
            
        } catch (e) {
            addLog(`âŒ Health endpoint: ${e.message}`, 'error');
            updateApiStatus('offline');
        }
        
        // ØªØ³Øª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
        const testSymbols = [
            'BTCUSDT', 'ETHUSDT', 'SOLUSDT', // Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø§ØµÙ„ÛŒ
            'PEPEUSDT', 'FLOKIUSDT', // Ù…ÛŒÙ…â€ŒÚ©ÙˆÛŒÙ†â€ŒÙ‡Ø§
            'ARBUSDT', 'OPUSDT', // Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
            'EURUSD', 'XAUUSD' // ÙØ§Ø±Ú©Ø³ Ùˆ Ø·Ù„Ø§
        ];
        
        for (const symbol of testSymbols) {
            try {
                const priceInfo = await getCurrentMarketPrice(symbol, true);
                if (priceInfo) {
                    addLog(`ğŸ’° ${symbol}: $${formatPriceWithPrecision(priceInfo.price)} (${priceInfo.source})`, 
                          priceInfo.isReal ? 'success' : 'warning');
                } else {
                    addLog(`âŒ ${symbol}: No price data`, 'error');
                }
            } catch (e) {
                addLog(`âŒ ${symbol} Price check: ${e.message}`, 'error');
            }
            await sleep(300);
        }
        
        // ØªØ³Øª Binance symbols
        try {
            const binanceSymbols = await getBinanceSymbols();
            const symbolCount = Object.keys(binanceSymbols).length;
            addLog(`ğŸ“Š Binance symbols loaded: ${symbolCount}`, 'success');
        } catch (e) {
            addLog(`âš ï¸ Binance symbols: ${e.message}`, 'warning');
        }
        
    } catch (error) {
        addLog(`âŒ Connection test failed: ${error.message}`, 'error');
        updateApiStatus('offline');
    }
}

function switchMarket(market) {
    currentMarket = market;
    document.getElementById('cryptoBtn').classList.toggle('active', market === 'crypto');
    document.getElementById('forexBtn').classList.toggle('active', market === 'forex');
    
    const placeholder = market === 'crypto' 
        ? 'Search Crypto (BTC, ETH, SOL...)' 
        : 'Search Forex/Gold (EURUSD, XAUUSD, PAXG...)';
    
    document.getElementById('symbolSearch').placeholder = placeholder;
    addLog(`ğŸŒ Switched to ${market.toUpperCase()} market`, 'info');
    
    const currentSymbol = document.getElementById('symbol').value;
    if (market === 'forex' && !isForexGoldSymbol(currentSymbol)) {
        selectSymbol('EURUSD');
    } else if (market === 'crypto' && isForexGoldSymbol(currentSymbol)) {
        selectSymbol('BTCUSDT');
    }
}

function toggleTimeframe(tf) {
    const btn = document.getElementById(`tf${tf.replace('m', '').replace('h', '')}`);
    const index = activeTimeframes.indexOf(tf);
    
    if (index > -1) {
        if (activeTimeframes.length > 1) {
            activeTimeframes.splice(index, 1);
            btn.classList.remove('active');
            addLog(`âŒ Disabled ${tf} timeframe`, 'warning');
        } else {
            addLog('âš ï¸ At least one timeframe must be active', 'error');
            return;
        }
    } else {
        activeTimeframes.push(tf);
        btn.classList.add('active');
        addLog(`âœ… Enabled ${tf} timeframe`, 'success');
    }
    
    document.getElementById('activeTFs').textContent = activeTimeframes.length;
}

// ========== UTILITY FUNCTIONS ==========
function addLog(message, type = 'info') {
    const debug = document.getElementById('debug');
    const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
    const icon = type === 'success' ? 'âœ…' : 
                 type === 'error' ? 'âŒ' : 
                 type === 'warning' ? 'âš ï¸' : 
                 type === 'scalp' ? 'âš¡' : 'â„¹ï¸';
    
    const line = `<div class="debug-line ${type}">${icon} [${time}] ${message}</div>`;
    
    debug.insertAdjacentHTML('afterbegin', line);
    
    if (debug.children.length > 25) {
        debug.removeChild(debug.lastChild);
    }
    
    console.log(`[${type.toUpperCase()}] ${message}`);
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// ========== AUTO PRICE UPDATE ==========
function startAutoPriceUpdate() {
    if (priceUpdateInterval) {
        clearInterval(priceUpdateInterval);
    }
    
    priceUpdateInterval = setInterval(async () => {
        const symbol = document.getElementById('symbol').value;
        if (symbol) {
            const priceInfo = await getCurrentMarketPrice(symbol);
            if (priceInfo && priceInfo.price > 0) {
                updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
            }
        }
    }, CONFIG.UPDATE_INTERVAL);
}

// ========== INITIALIZATION ==========
document.addEventListener('DOMContentLoaded', function() {
    console.log('ğŸš€ AI Smart Money Scanner v2.6 loaded');
    console.log('ğŸ’° Enhanced price system for ALL crypto');
    console.log('ğŸš€ Bulk Scanner (15m interval) enabled');
    console.log('âš¡ Scalp scanning enabled');
    
    document.getElementById('apiUrlDisplay').textContent = CONFIG.API_URL.replace('https://', '');
    document.getElementById('apiUrlFooter').textContent = CONFIG.API_URL.replace('https://', '');
    
    loadAllSymbols();
    setupEventListeners();
    
    addLog('ğŸš€ AI Smart Money Scanner v2.6 Initialized', 'success');
    addLog(`ğŸ”— API: ${CONFIG.API_URL}`, 'info');
    addLog('ğŸš€ Bulk Scanner (15m Interval) Added', 'success');
    addLog('ğŸ’° Enhanced Price System for ALL Crypto', 'success');
    addLog('âš¡ Scalp Signals (1m/5m/15m) Enabled', 'scalp');
    addLog('ğŸ“Š Swing Analysis (1h/4h) Enabled', 'info');
    
    // Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ø§ÙˆÙ„ÛŒÙ‡
    getCurrentMarketPrice('BTCUSDT', true).then(priceInfo => {
        if (priceInfo) {
            updatePriceDisplay(priceInfo.price, priceInfo.source, priceInfo.isReal);
            addLog(`ğŸ’° Current BTC: $${formatPriceWithPrecision(priceInfo.price)} (${priceInfo.source})`, 'success');
        } else {
            document.getElementById('price').textContent = '--';
            document.getElementById('priceSource').textContent = 'Source: Failed to fetch';
            document.getElementById('priceSource').style.color = '#ff4444';
            addLog(`âŒ Failed to get initial BTC price`, 'error');
        }
    });
    
    // Ø´Ø±ÙˆØ¹ Ø¢Ù¾Ø¯ÛŒØª Ø®ÙˆØ¯Ú©Ø§Ø± Ù‚ÛŒÙ…Øª
    startAutoPriceUpdate();
    
    // ØªØ³Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ø¹Ø¯ Ø§Ø² 3 Ø«Ø§Ù†ÛŒÙ‡
    setTimeout(() => {
        testConnection();
    }, 3000);
});
</script>
</body>
</html>